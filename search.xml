<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>误删两行代码引发的测量View问题</title>
      <link href="/2022/06/15/%E8%AF%AF%E5%88%A0%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E6%B5%8B%E9%87%8FView%E9%97%AE%E9%A2%98/"/>
      <url>/2022/06/15/%E8%AF%AF%E5%88%A0%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%BC%95%E5%8F%91%E7%9A%84%E6%B5%8B%E9%87%8FView%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今天解决的一个bug很有意思，涉及View测量流程，故记之。</p><h4 id="bug描述："><a href="#bug描述：" class="headerlink" title="bug描述："></a>bug描述：</h4><p>Launcher中，当用户点击<strong>任一全屏App</strong>返回后，GridLayout 中的 ItemView 大小测量不正常了。如下图所示：</p><img src="/images/image-20220615204045941.png"><p>Launcher的布局结构是一个ViewPager，每一页是一个GridLayout，以下是对应的代码（也可以忽略不看）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class AppPagerAdapter extends PagerAdapter &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">// 刷新每一个页的内容</span><br><span class="line">// 一个页面是简单的 FrameLayout &gt; GridLayout 结构</span><br><span class="line">    private void refreshItemLayout(int position, ViewGroup c_item_layout) &#123;</span><br><span class="line">        AppGridItemView c_app_view;</span><br><span class="line">        GridLayout c_grid_layout = (GridLayout) c_item_layout.getChildAt(0);</span><br><span class="line">        for (int c_page_index = 0; c_page_index &lt; m_page_count_per_page; c_page_index++) &#123;</span><br><span class="line">        // 根据在第几页、第几项确定对应的app</span><br><span class="line">            int c_app_index = (position * m_page_count_per_page) + c_page_index;</span><br><span class="line">            View view = c_grid_layout.getChildAt(c_page_index);</span><br><span class="line">            if (view == null || !(view instanceof AppGridItemView)) &#123;</span><br><span class="line">            // 第一个创建 GridLayout 中的 ItemView</span><br><span class="line">                c_app_view = (AppGridItemView) View.inflate(this.m_context, R.layout.app_item_layout, (ViewGroup) null);</span><br><span class="line">                c_app_view.setShortCutClickListener(this.m_listener);</span><br><span class="line">                GridLayout.LayoutParams c_para = new GridLayout.LayoutParams();</span><br><span class="line">                // 关键是这里，误删掉了这两行，导致出现了Bug</span><br><span class="line">//                c_para.width = 0;</span><br><span class="line">//                c_para.height = 0;</span><br><span class="line">                c_para.columnSpec = GridLayout.spec(c_page_index % m_page_colum_num, 1.0f);</span><br><span class="line">                c_para.rowSpec = GridLayout.spec(c_page_index / m_page_colum_num, 1.0f);</span><br><span class="line">                c_app_view.setLayoutParams(c_para);</span><br><span class="line">                c_grid_layout.addView(c_app_view);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                c_app_view = (AppGridItemView) view;</span><br><span class="line">            &#125;</span><br><span class="line">            if (c_app_index &lt; this.m_app_list.size()) &#123;</span><br><span class="line">                c_app_view.setAppInfo(this.m_app_list.get(c_app_index));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                c_app_view.setAppInfo((AppInfo) null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// ViewPager中创建一个页面</span><br><span class="line">    public Object instantiateItem(@NonNull ViewGroup container, int position) &#123;</span><br><span class="line">        // 复用整个页面View，其结构（FrameLayout &gt; GridLayout）</span><br><span class="line">        FrameLayout c_item_layout = getFreeLayout();</span><br><span class="line">// 针对每一页创建内容</span><br><span class="line">        refreshItemLayout(position, c_item_layout);</span><br><span class="line">        </span><br><span class="line">        this.m_use_layout_list.add(c_item_layout);</span><br><span class="line">        container.addView(c_item_layout);</span><br><span class="line">        c_item_layout.setTag(Integer.valueOf(position));</span><br><span class="line">        return c_item_layout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bug原因"><a href="#bug原因" class="headerlink" title="bug原因"></a>bug原因</h4><p>先给出Bug原因：创建GridLayout子项的布局参数中，我把 宽高==0 改为了 宽高==wrap_content。</p><h4 id="追溯我写bug的起因"><a href="#追溯我写bug的起因" class="headerlink" title="追溯我写bug的起因"></a>追溯我写bug的起因</h4><p>创建的 GridLayout 中的 ItemView 时，我将 ” itemView 的 LayoutParam 宽高设为了0“ 的两行代码注释掉了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                GridLayout.LayoutParams c_para = new GridLayout.LayoutParams();</span><br><span class="line">                // 关键是这里，我误删掉了这两行，导致出现了Bug</span><br><span class="line">//                c_para.width = 0;</span><br><span class="line">//                c_para.height = 0;</span><br></pre></td></tr></table></figure><p>回想我怎么干出这样的”蠢事”？</p><p>应该是想到了，一个属性值默认为0，就不需要额外设置了呀。</p><p>一般情况下， <code>ViewGroup.LayoutParams</code>　无参构造方法中，默认的宽高的是0。</p><p>但是，<code>GridLayout.LayoutPrams</code> 的无参构造方法中，会将默认的宽高设为<code>wrap_content</code>。</p><p>这样，因为我的想当然，将布局参数由 <code>0</code>  改为了 <code>wrap_content</code>。</p><h4 id="bug-的分析-布局参数-0-和-wrap-content的不同"><a href="#bug-的分析-布局参数-0-和-wrap-content的不同" class="headerlink" title="bug 的分析　布局参数 0 和 wrap_content的不同"></a>bug 的分析　布局参数 0 和 wrap_content的不同</h4><p>直接给出结论：</p><p>0 时，对应的测量模式是exactly，导致父容器大小变化时，不会重新测量自己，而wrap_content会在每次父容器大小变化时测量自己。</p><p>具体针对本bug，则是在全屏应用切换时，导致 gridLayout的大小发生了变化，进而触发子项view重新测量自己。当从全屏应用返回后，触发了一次重新测量的流程，若是参数为0时，则itemView不会重新测量。</p><blockquote><p>其实深究这个问题，还是存在不清楚的地方：</p><p>为什么进入其他全屏应用时会触发重新测量，而返回Launcher时没有触发测量？</p><p>或是说，仅是从全屏应用返回后，Launcher触发了重新测量，但是测量时状态栏仍是处于隐藏的状态，故而导致此情况。</p></blockquote><h4 id="bug延伸，源码追踪-为什么０和-wrap-content不同"><a href="#bug延伸，源码追踪-为什么０和-wrap-content不同" class="headerlink" title="bug延伸，源码追踪,为什么０和 wrap_content不同"></a>bug延伸，源码追踪,为什么０和 wrap_content不同</h4><p>从GridLayout的 onMeasure() 开始追踪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">   protected void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 第一次测量，（1）</span><br><span class="line">       measureChildrenWithMargins(widthSpecSansPadding, heightSpecSansPadding, true);</span><br><span class="line">// 第二次测量</span><br><span class="line">measureChildrenWithMargins(widthSpecSansPadding, heightSpecSansPadding, false);</span><br><span class="line"></span><br><span class="line">// 确定当前 GridLayout 的大小</span><br><span class="line">       setMeasuredDimension(</span><br><span class="line">               resolveSizeAndState(measuredWidth,   widthSpec, 0),</span><br><span class="line">               resolveSizeAndState(measuredHeight, heightSpec, 0));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   private void measureChildrenWithMargins(int widthSpec, int heightSpec, boolean firstPass) &#123;</span><br><span class="line">       for (int i = 0, N = getChildCount(); i &lt; N; i++) &#123;</span><br><span class="line">           View c = getChildAt(i);</span><br><span class="line">           // 这里，就是使用布局参数的地方</span><br><span class="line">           LayoutParams lp = getLayoutParams(c);</span><br><span class="line">           if (firstPass) &#123;</span><br><span class="line">// 结合父级的spec和子View的想要的大小，来确定子View的大小 （2）</span><br><span class="line">               measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, lp.height);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               boolean horizontal = (mOrientation == HORIZONTAL);</span><br><span class="line">               Spec spec = horizontal ? lp.columnSpec : lp.rowSpec;</span><br><span class="line">               if (spec.getAbsoluteAlignment(horizontal) == FILL) &#123;</span><br><span class="line">                   Interval span = spec.span;</span><br><span class="line">                   Axis axis = horizontal ? mHorizontalAxis : mVerticalAxis;</span><br><span class="line">                   int[] locations = axis.getLocations();</span><br><span class="line">                   int cellSize = locations[span.max] - locations[span.min];</span><br><span class="line">                   int viewSize = cellSize - getTotalMargin(c, horizontal);</span><br><span class="line">                   if (horizontal) &#123;</span><br><span class="line">                   // 若是水平的，即GridLayout限制了水平方向有固定N个，将父级width平分N分后，做为itemView的宽</span><br><span class="line">                   // 而在垂直方向，仍尊重孩子自己申请的大小</span><br><span class="line">                       measureChildWithMargins2(c, widthSpec, heightSpec, viewSize, lp.height);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, viewSize);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void measureChildWithMargins2(View child, int parentWidthSpec, int parentHeightSpec,</span><br><span class="line">           int childWidth, int childHeight) &#123;</span><br><span class="line">       // itemView 测量自身使用 measureSpec 的确定过程，</span><br><span class="line">       int childWidthSpec = getChildMeasureSpec(parentWidthSpec,</span><br><span class="line">               getTotalMargin(child, true), childWidth);</span><br><span class="line">       int childHeightSpec = getChildMeasureSpec(parentHeightSpec,</span><br><span class="line">               getTotalMargin(child, false), childHeight);</span><br><span class="line">       // itemView 得到 spec 后来测量自身</span><br><span class="line">       child.measure(childWidthSpec, childHeightSpec);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">// ViewGroup.java</span><br><span class="line">   public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class="line">   // spec 的拆分，前2位来存储mode, 后30位存储期望的值</span><br><span class="line">       int specMode = MeasureSpec.getMode(spec);</span><br><span class="line">       int specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">       int resultSize = 0;</span><br><span class="line">       int resultMode = 0;</span><br><span class="line"></span><br><span class="line">       switch (specMode) &#123;</span><br><span class="line">       // Parent has imposed an exact size on us</span><br><span class="line">      // 正常情况，GridLayout 传下来的是 exactly, 即gridLayout本身确定了自己的大小，不期望收到孩子的影响</span><br><span class="line">       case MeasureSpec.EXACTLY:</span><br><span class="line">       // 这里，孩子的布局参数设置为0时，即导致孩子使用的spec为 (exactly + 0) 组成</span><br><span class="line">           if (childDimension &gt;= 0) &#123;</span><br><span class="line">               resultSize = childDimension;</span><br><span class="line">               resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">           &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">               // Child wants to be our size. So be it.</span><br><span class="line">               resultSize = size;</span><br><span class="line">               resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">           &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">               // 当我们使用默认的 wrap_content时，孩子会使用的 spec 为 (at_most + size)</span><br><span class="line">               // 注意这个size为GridLayout已经确定好的size</span><br><span class="line">               resultSize = size;</span><br><span class="line">               resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">       return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>到这里，我们完成了从 LayoutParam的到 spec 的转变过程。</p><p>为了描述本Bug，分为了两种情况，</p><ol><li>布局参数宽高设为  wrap_content， 即 GridLayout.LayoutParam 默认方法</li><li>布局参数宽高设为  0，即我们解决bug的情况</li></ol><p>第一种 spec 为 (at_most + size)，即孩子的大小未确定，只是限制了最大值为size，即父级大小减去一些padding.第二种 spec 为 (exatly + 0)，当孩子使用这个 spec时，会确定自己大小为 0 ? </p><p> 开始追到这里会有一些疑惑，当使用 spec 为 （exactly + 0 ）去调用 child.measure()时，那么ItemView得大小不是应该为 0吗？实际上，就是这样。但这只是初步的结果，回顾发现，会GridLayout区分了第一次测量和第二次测量，此时，第一次测量结果就是孩子得大小都为 0。</p><p>这里，我们可以做一个初步的总结，GridLayout测量孩子时，会分为两次测量，第一次会询问孩子想要的大小，</p><p>若是wrap_content，那么孩子会根据自身出发先报出自己想要的大小，作为暂定值。</p><p>若是 &gt;=0的值，那么也暂定大小为当前申请的值，比如我们报的值0.</p><p>当然还有一种额外的情况，就是 match_parent，暂定大小与父级容忍的最大值相同。</p><p>无论布局参数参数是哪种，都会先得到一个暂定值。</p><p>接下来，我们进入GridLayout 的第二次测量的过程。</p><p>回头看代码，firstPass == false的情况，</p><p>讨论GridLayout是水平的，即GridLayout限制了水平方向有固定N个itemView，将父级的宽度平分N分后，做为itemView的宽度，而在垂直方向，仍尊重孩子自己申请的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">measureChildWithMargins2(c, widthSpec, heightSpec, viewSize, lp.height);// viewSize即划分父级为N份的大小</span><br></pre></td></tr></table></figure><p>接下来再次得到一个 spec 后，进入 child.measure(childWidthSpec, childHeightSpec)，我们这里追踪进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  // View.java</span><br><span class="line">  </span><br><span class="line">  public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">// 传统的cache流程，忽略</span><br><span class="line">      // Suppress sign extension for the low bytes</span><br><span class="line">      long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;</span><br><span class="line">      if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);</span><br><span class="line"></span><br><span class="line">// 当前View是否申请有强制布局，即某个地方已经判断该View是脏的</span><br><span class="line">      final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line"></span><br><span class="line">// 翻译：当前子View已经测量出正确尺寸时，父级会传参exatcly，（避免无效测量），以达到优化布局目的</span><br><span class="line">      // Optimize layout by avoiding an extra EXACTLY pass when the view is</span><br><span class="line">      // already measured as the correct size. In API 23 and below, this</span><br><span class="line">      // extra pass is required to make LinearLayout re-distribute weight.</span><br><span class="line">      final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec</span><br><span class="line">              || heightMeasureSpec != mOldHeightMeasureSpec;</span><br><span class="line">      final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY</span><br><span class="line">              &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;</span><br><span class="line">      final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">              &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">              </span><br><span class="line">      // 是否需要重新布局（当然包括测量了）？</span><br><span class="line">// spec是否已经变化了？</span><br><span class="line">// 与第一次传进来的的spec相比，当然是变化了。</span><br><span class="line">// 即使变化了，也不一定需要重新</span><br><span class="line">      final boolean needsLayout = specChanged</span><br><span class="line">              &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line">      if (forceLayout || needsLayout) &#123;</span><br><span class="line">      </span><br><span class="line">      // 测量本身</span><br><span class="line">       onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">// 测量后，标记需要进入layout流程。</span><br><span class="line">          mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第二次进入时，看看是否会触发 needLayout ？首先specChanged必然是 ture 的，然后看三个标志：(sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize)</p><ol><li>sAlwaysRemeasureExactly  是否设置了强制重新测量，这里先忽略，正常请情况应该都是false的</li><li>!isSpecExactly  测量模式不是 exactly</li><li>!matchesSpecSize 已经测量的值 不等于 spec期望的值</li></ol><p>三个标志位任一条件满足都会触发重新测量，但这么看人还是挺懵的，反过来看，什么时候会避免重新测量呢？</p><p>结合日常工作的常见的情况，什么时候，子View会避免重新测量呢？即 needLayout = false的情况</p><ol><li><p>当父级 spec不变，即父级大小不变，自然不会要求孩子重测了</p></li><li><p>当 spec变了，即父级大小变化了，孩子仍能避免重新测量</p></li></ol><p>第二种情况比较有趣，也是注释里面提到的优化点，即：当前子View已经测量出正确尺寸时，父级会传参exatcly，（避免无效测量），以达到优化布局目的。</p><p>此时，父级传来的 spec(mode + size ) 的size变化了，但是 mode 仍然是 exactly，可以判断不必测量自己View。</p><p>但若是 spec的mode是非 exatcly，即子View设置了wrap_content转换的 at_most，则会每次父级变化，自己本身也会要求重新测量。</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平静的感觉</title>
      <link href="/2022/04/06/%E5%B9%B3%E9%9D%99%E7%9A%84%E6%84%9F%E8%A7%89/"/>
      <url>/2022/04/06/%E5%B9%B3%E9%9D%99%E7%9A%84%E6%84%9F%E8%A7%89/</url>
      
        <content type="html"><![CDATA[<p>清明收假回来上班，没什么活，坐在电脑前，带着降噪耳机，享受这平静的感觉。</p><p>平静下来，脑子也会浮现出很多事情，比如</p><ul><li>清明去广州玩遇到一贩卖机借机器故障之名拉人关注公众号</li><li>老婆去广州知识城学习，因为崇拜这个城市，连同将卖地摊衣服一眼误认为高大上的赠品</li><li>加了一个副业群，看着他人在讨论做什么产品好挣钱，感觉大家的想法往往会源自自己的生活，做的产品一般都是自己能够接触到的事物。</li></ul><p>关于副业的挣钱的事，以下展开来说。</p><p>副业自己能做什么，有什么好的点子呢？</p><p>自己所能想到的点子，往往是自己生活接触到的，自己受用的。据说，程序员搞副业的最火热的点子是前端搞导航页，移动端搞Todo、记账、日记。这些点子，因为自己平常都熟悉它的功能流程，所以在作为练手项目可以让我们专注于技术的实现。作为副业，这几个点子用于需求很多，但也存在竞争火热的特点，不太容易出众。</p><p>若想要做一个脱离自己的认知的范围的 App，试图找一个完全没人涉足的领域，做一个第一个吃螃蟹的人，着实不太实际。过于小众的需求，用户量就会太小撑不起一个app, 想起来自己做过一个小众工具的实践，解决用户想台式机电脑端控制手机蓝牙音乐的需求，实在太小众且不符合电脑自带蓝牙的趋势。最近在考科三练习模拟灯光时，开始以为自己发现了一个蓝海的需求，对于这个单一需求，市面上app过于古老没法用了，小程序只是很简单的文字选择题，再继续调查，发现在市场排行第一的“驾考宝典”已经支持了这个一功能，效果做的非常好，实物贴图了实车的灯光控制开关，开通使用这一功能还能开通其他功能，满足正常人贪全的心理，体验到这我也就心灰意冷了。小众单一的需求往往已经包括在大平台的一个小模块当中。</p><p>一个点子合不合适，小众或大众似乎也不是决定因素，大众的需求，即使竞争者很多，可市场可容纳的量也很大。瞎想这些东西也没什么意思。</p><p>记录一个感触，做一些顺应趋势的东西。随着物质水平的提高，大家压力都挺大，记录植物浇灌的app也出现了。养狗、养猫、养花花草草，要求是在依次降低的，在农村、别墅养个狗可以，在小出租房养猫方便，养花花草草条件要求更低了，应该适用于那些安静的人使用，而且，养了花花草草的人，应该都挺孤单的吧，养了花花草草的时候，应该是能享受这片刻的平静，也会耐心做一些纪录浇水施肥的过程。哈，养狗》猫》花草的过程的物质水平似乎趋向是更低的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dart异步编程：Isolate和事件循环（译）</title>
      <link href="/2021/09/10/dart%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%9AIsolate%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88%E8%AF%91%EF%BC%89/"/>
      <url>/2021/09/10/dart%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%9AIsolate%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88%E8%AF%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a" target="_blank" rel="noopener">原文</a></p></blockquote><p>Dart, 尽管作为一个单线程语言，但也提供了一系列的API，诸如Future, Stream，来帮助我们编写一个现代、异步、响应式的程序。本文主要讲述Dart在底层如何支持这样的后台任务，包括 isolate, 事件循环。</p><h2 id="Isolate"><a href="#Isolate" class="headerlink" title="Isolate"></a>Isolate</h2><p>Isolate，指代码运行之处，指Dart程序所拥有的内存空间，以及在其之上运行的事件循环。</p><p>在一些类似C++的语言中，支持多个线程共享一段内存空间，每个线程可以运行你想要的代码块（堆、方法区共享）。而在dart中，一个线程就是一个isolate和其持有的内存区，其线程就只是一直在处理事件。</p><p>通常一个Dart程序只会开启一个Isolate, 但也支持开启多个。若是有一个耗时任务在主线程中执行，会导致app丢帧，就可以用 <code>Isolsate.spawn()</code>, <code>Flutter的 compute()</code>方法，两者都会开启一个新的Isolate， 使得主Isolate忙于重建、渲染widget。</p><p>新的Isolate拥有自己的事件循环和内存空间，即使是由父类孵化(Spawn)出来的，父级也不允许访问孵化出来的Isolate。也就如其名所言，Isolate岛屿之意。</p><p>实际上，Isolate之间的交互只能通过相互发送信息。，相比于Java/C++不同线程共享一个内存空间的机制而言，这种缺乏共享内存的设计可能看起来过于严格，效率不高。但Dart定位为客户端语言来说，却也有一定好处。比如，内存分配，垃圾回收不必需要使用锁了。因为只有一个线程，对于一个段内存空间而言，在某一个时刻，永远只会有一个CPU在访问。这样的特点，非常适用于客户端程序，因为需要频繁的重建、销毁原来的widget对象。</p><h2 id="Event-Loops-事件循环"><a href="#Event-Loops-事件循环" class="headerlink" title="Event Loops 事件循环"></a>Event Loops 事件循环</h2><p>以上简单介绍了Isolate，让我们继续探究一个单线程如何实现异步的，即事件循环。</p><p>想象一个app的生命周期，包括了开始、结束、和中间一些系列事件的发生，包括io事件、用户点击事件等。</p><p>你的程序并不能预测这些事件何时会发生，所以你只能开始时定义好收到什么事件时，该如何处理。</p><blockquote><blockquote><p>不想继续翻译了，后面重复一个概念，告诉我们，所有无论是启动一个Callback、或开启一个Future，都是在添加一个事件处理到事件循环中，当其被调用时，只是收到了一个事件。</p></blockquote></blockquote><h2 id="本人后续思考补充"><a href="#本人后续思考补充" class="headerlink" title="本人后续思考补充"></a>本人后续思考补充</h2><h3 id="关于dart单线程的设计在客户端中具有优势？"><a href="#关于dart单线程的设计在客户端中具有优势？" class="headerlink" title="关于dart单线程的设计在客户端中具有优势？"></a>关于dart单线程的设计在客户端中具有优势？</h3><p>感觉优势不是很大呀。即便在支持多线程的语言的Android中，管理UI会由唯一的UI线程来处理。即便是对于SurfaceView的场景来说，有了额外的线程来绘制UI，在展示时还是得交由UI线程保证每一帧的有序。但，这应该不是dart所提到相对优势的点，多个线程同时处理一个UI的框架，似乎没有遇到过。</p><h3 id="dart有俩个队列，micro-event，为啥Android只有一个队列呢？"><a href="#dart有俩个队列，micro-event，为啥Android只有一个队列呢？" class="headerlink" title="dart有俩个队列，micro, event，为啥Android只有一个队列呢？"></a>dart有俩个队列，micro, event，为啥Android只有一个队列呢？</h3><p>问答这个问题，得先了解dart为什么要分了俩个队列，其作用是什么？</p><p><img src="https://dart.cn/articles/archive/images/both-queues.png" alt="flowchart: main() -&gt; microtasks -&gt; next event -&gt; microtasks -&gt; ..."></p><p>通过这个图，可知，microtask的优先级很高，每次从event队列取出一task时，会先把micro队列的task执行完。</p><p>假设我们 new 俩个future，相当于把俩个task A, B 依次放入到 event队列中，这里，我们可以保证 A &gt; B的顺序。</p><p>在执行A时，我们又 new 了 task C, 那么，可以保证顺序 A &gt; B &gt; C。</p><p>若是在执行 task A时，需要执行一个比较急迫的任务 urgentC，需要保证 A &gt; ugentC &gt; B,  故需要将urgentC放入到micro队列。</p><p>为什么会有这么一个需求呢？因为我们不知道后续的B需要执行多久，或是A，B同时修改一个状态时，我们的 urgentC需要依赖A修改后的状态。或是，我们在执行A时，发现不需要后续的B执行了。这个有点像Android Handler的removeMessage，比如急着将对象引用断开。可以注意到的是，这个急迫的 urgentC的队列为啥叫 microtask queue, 相比于急迫，更重要的是要保证该任务是轻量的。 实际上很多task放入event队列，比如响应用户的事件。</p><p>简单说，microd task就是保证该任务会优先于后续的event task执行。既然存在这么一个需求，dart存在micro task方案，那么在Android中肯定也有对应的方案。是的，MessageQueue存在一个同步屏障的概念，sync barrier。postSyncBarrier() 有这么一段注释:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;      * This method is used to immediately postpone execution of all subsequently posted</span><br><span class="line">&gt;      * synchronous messages until a condition is met that releases the barrier.</span><br><span class="line">&gt;      * Asynchronous messages (see &#123;@link Message#isAsynchronous&#125; are exempt from the barrier</span><br><span class="line">&gt;      * and continue to be processed as usual.</span><br><span class="line">&gt; </span><br><span class="line">&gt;       该方法用于推迟处理后续提交同步消息，直至同步屏障的释放。而异步消息则免于其干扰正常执行。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>在Android中急迫的task是根据 异步任务和同步屏障配合而生效的，入队列的任务，当 barrier出现时，先优先执行异步消息。</p><p>异步任务与dart的micro task有一点区别，dart一旦发布micro task，必将优先一个个执行完。而android的异步任务，其优先性的是依赖barrier而生效的，可以说异步任务更为灵活点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> code flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈对声明式框架的理解</title>
      <link href="/2021/08/28/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2021/08/28/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>昨晚把<code>React</code>的官方入门Demo敲了一遍，感觉对声明式的框架 <code>React,Flutter,Android-Compose</code>都有了一些认知，故想记录下。</p><p>我开始学习的是Flutter，看了文档，敲Demo，对比Android原生开发的一些熟悉概念，后面看到Android也推出了Compose，又跑去玩玩Compose，发现两个框架都在”抄” React，忍不住去认认这”祖师爷”，通过不同框架对同一概念的实现，从而加深对声明式框架的理解。</p><p>前端，主要干的活，定义如何展示数据，处理数据和视图的关系，处理事件到来后数据变化，重新渲染数据成视图。</p><p>其中，由于数据在视图中是变化的，故，我们将之称为状态state，而对于一部分数据对本视图而言，它是不可变的，我们称之为属性props，要注意的是这里的可变或不可变是对于本视图而言的，一般，父亲的state对孩子的来说就是props。而，事件通常分为用户产生，如触摸事件，和系统产生，如时钟滴答导致状态进入下一个生命周期，我们称之为动作action。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = props + state 　// 数据由不变的属性和可变状态组成</span><br><span class="line">view = render(model)    // 视图通过渲染model形成</span><br></pre></td></tr></table></figure><p>此后便是声明式和传统的开发的区分</p><p>传统的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">action(model) &gt;&gt; diff   // 事件过来进行处理，产生一些变化diff</span><br><span class="line">new_view = view + renderDiff(dff)   // 根据这个diff渲染出一部分区别的view,　再将这个差别view融入原来的view以形成新的view</span><br></pre></td></tr></table></figure><p>存在的问题是，我们渲染数据的逻辑变得很复杂，为何？一个事件，产生一个变化diff，需要对这个diff添加新的渲染代码，即随着事件的远远不断地到来，我们要不断地维护更新这个视图树，随着事件变多，往往会出现，model和view不同步的情况，因为我们在修改model的同时，也要同时修改view。</p><p>而声明式的方法是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">action(model) &gt;&gt; new_model  // 事件过来产生一个新的model</span><br><span class="line">new_view = render(new_model)    // 由于新的model和原来的model结构完全一致，故，我们可以使用原来的render方法</span><br></pre></td></tr></table></figure><p>这样，当定义好一个渲染逻辑后，只要model的结构不变，我们就可以不用改变原来的render方法，从而保持渲染逻辑的简单。</p><p>以上，是对声明式框架的理解，以下做一些额外的思考。</p><p>若论性能而言，传统开发更优，但是声明式开发模式更注重开发效率和代码维护性。 以此，声明式开发是未来的一种趋势。</p><p>传统方式，直接修改原来数据，然后视图同步数据的修改，而声明式开发，复制了全部的数据，修改数据后交给视图一个全新的数据镜像重新渲染。根据这点，声明式要使用更多的内存和更频繁的对象销毁回收，因此在利用计算机性能上效率低。但，从历史趋势的趋势上声明式开发是未来，一方面，计算性能在增加，另一方面，降低编程心智负担一直我们追求的目标；这个论证过程也可从编程语言的发展史得到印证。</p><p>而在框架的具体实现上，性能上也做了很多优化。Flutter，从用户描述到渲染经过了 widget &gt; element &gt; renderObject的过程，widget是我们对一个组件的最简单的描述定义，element表示了其组件的关系树，而renderObject才是真正用于渲染的视图树。其作用是，导致widget对象都很小，回收成本低，而真正的渲染树，在widget修改时，对应渲染树只是增量更新，而不是和widget一样全量更新。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>追《新世纪福音战士》后做了一个奇怪的梦”</title>
      <link href="/2021/08/02/%E8%BF%BD%E3%80%8A%E6%96%B0%E4%B8%96%E7%BA%AA%E7%A6%8F%E9%9F%B3%E6%88%98%E5%A3%AB%E3%80%8B%E5%90%8E%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E6%A2%A6%E2%80%9D/"/>
      <url>/2021/08/02/%E8%BF%BD%E3%80%8A%E6%96%B0%E4%B8%96%E7%BA%AA%E7%A6%8F%E9%9F%B3%E6%88%98%E5%A3%AB%E3%80%8B%E5%90%8E%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E6%A2%A6%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>梦醒回到现实，我庆幸我活到现在没有做过一件无法弥补的事，至少相对梦境中我的处境而言…</p><p>梦中，我抢了银行，钱到手后逃跑途中，我拿着一大跌崭新的纸币，在一片慌乱中，我想将钱塞给逃跑中的帮手们，我纠结我该一人给多少张百元纸币，一人给5张可能不够发，一人给3张可能会让他们不满意，在纠结中和慌忙逃跑中，我忘了分发了多少，有的塞了少有的多，过后我还剩下了很多。而这些帮手们也没有过于在意收到了多少，因为大家都在慌忙地逃跑，后面有枪声，也不清楚其他人收到了多少。  </p><p>我逃到教室上自己座位上，手中还有一小碟纸币，裤袋还有一大叠纸币，这都是我剩下没有发完的，我后悔了，我不该把这些钱带回来，这有可能会暴露我，我后悔没有直接将钱撒在路上让他们拿了。</p><p>我想逃跑中肯定有人被捉住了，帮手们不认识我，不会通过他们找到我，但是剩下的这些纸币却可能暴露我，因为这都是一叠纸币分发的，其中序号是相连的，只要我使用了就可能会被追踪到，这钱我不能用。我想找个地方把钱埋了，害怕新挖的土会被人看到。我想把钱烧了，却没有一个合适的地方，我怕钱烧起来会发出味道被人发现，我怕钱烧成了灰还是可以被认出是纸币，我要把它的灰搓碎认不出。</p><p>可，现在我在教室中，我在我的位置上，我同桌来了，我裤带中的人民币露出了一个角，闪着崭新人民币的光，我赶紧用上衣遮住，身体也弯腰趴到桌子上，我想把钱放到抽屉中，不能放在抽屉，纸币那么薄，从抽屉的缝掉出来我就完了，我低头看了抽屉中还好有一个书包，我想到纸币放到书包中，拉着拉链不会掉出来。好巧，同桌出去了，他到走廊吹风聊天了，我回头环视后面，我怕后面有人看到我把纸币放到抽屉中书包的过程，后面有个人似乎可以看到，但那人永远一副趴桌子的样子，我不知道他有没有在睡着，万一他刚好起来看到怎么办。纸币放在裤带中，太容易暴漏了，我要把它放到抽屉中，我用身体掩着，我要把钱放到抽屉中，我不敢回头，我怕那个同学刚好抬头看到我这么鬼祟的样子萌发好奇心看到，我不敢回头确认他有没有起来，回头可能会增加我鬼祟的模样，前面远处的同学反而好奇怀疑我在干嘛，我只能自顾尽快把纸币放进去，祈祷不会有人看到，我也不知道有没有看到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OKHttp 文档篇</title>
      <link href="/2021/07/28/OKHttp-%E6%96%87%E6%A1%A3%E7%AF%87/"/>
      <url>/2021/07/28/OKHttp-%E6%96%87%E6%A1%A3%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>初略的看了Retrofit之后，OkHttp就是必不可少的了，Retrofit依赖了OkHttp，两个库都有一个<code>Call</code>这么一个类，其意图也一样，只是所处的层次不同。Retrofit依赖OkHttp来实现真正的Http网络请求。而OkHttp相对来是更加复杂的，本文先把其文档过一遍。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><p>OkHttp是一个实现HTTP协议的客户端，其高效性源于：</p><ul><li>Http/2 若多个请求目标是一个主机，这几个请求可以共享一个Socket</li><li>若是Http/2不支持，即服务端不支持，用连接池的降低请求延迟</li><li>自带GZIP压缩数据</li><li>对于重复请求，自带一个Response缓存避免无意义请求</li></ul><p>当网络不好时，OkHttp支持自动重试。能帮助处理一些常见的问题，比如服务有多个IP地址，若第一个IP失败，会自动切换到后续的IP尝试，这对于多个数据源的服务端来说很有用。<br>支持现代 TLS 特性，（TLS 1.3, ALPN, certificate pinning）// todo 了解下</p><p>OkHttp是易用的，其request/response可以用构造者模式创建，且其对象是不可变的（immutability）。<br>支持同步异步调用。</p><blockquote><p>补充，不可变性的优势有<br>不用担心并发，既然该对象不可变，那么多个线程访问时，就不存在不同步问题。免除副作用的影响，一个对象不可变，那么其使用过程中始终是一样的，假设使用两次，第二次结果保证和第一次一样。</p></blockquote><h3 id="Get-a-URL"><a href="#Get-a-URL" class="headerlink" title="Get a URL"></a>Get a URL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">String run(String url) throws IOException &#123;</span><br><span class="line">  // 构造者模式，按照需修改部分配置</span><br><span class="line">  Request request = new Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">    // 同步调用    </span><br><span class="line">  try (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    return response.body().string();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Post-to-a-Server"><a href="#Post-to-a-Server" class="headerlink" title="Post to a Server"></a>Post to a Server</h3><p>发送http post请求时，携带实体数据body   </p><blockquote><p>http 格式包括 requestLine、header、body</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static final MediaType JSON = MediaType.get(&quot;application/json; charset=utf-8&quot;);</span><br><span class="line"></span><br><span class="line">OkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">String post(String url, String json) throws IOException &#123;</span><br><span class="line">  RequestBody body = RequestBody.create(JSON, json);</span><br><span class="line">  Request request = new Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .post(body)</span><br><span class="line">      .build();</span><br><span class="line">  try (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    return response.body().string();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><p>要求Android 5.0+，Java 8+</p><p>依赖了 OKio 和 Kotlin标准库，两者向后兼容都是令人放心的。</p><p>推荐保持该库最新版本，和浏览器一样，保持最新的http客户端可提升安全性。本库会跟上TLS的更新。</p><p>OkHttp 会使用平台自带的TLS的实现等等。</p><h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><p>Http client要做的事很清晰，接受一个request，产生一个response，使用Call来表示。</p><h3 id="Rewriting-request-重写一个请求"><a href="#Rewriting-request-重写一个请求" class="headerlink" title="Rewriting request 重写一个请求"></a>Rewriting request 重写一个请求</h3><p>用户在使用OkHttp时，是在站在比较高得层次思考需求得，我们只是简单得描述一个http请求，而okHttp会补充一些额外得细节，使得请求更加有效率。</p><p>对于 origin request，okHttp可能会添加 Content-Length, TransferEncoding, User-Agent, Host, Connection, Content-Type。若是没有注明 Accept-Encoding，会依据Response添加合适的。<br>若存在Cookie，也会添加。  </p><p>对于一些请求会使用缓存好的Response.当服务端支持了，If-Modified-Since If-None-Match头部信息，当客户端存在缓存时，会发送一个 get 请求来获知本地的缓存是否可用，客户端携带着我何时获取过这个信息，服务端判断是否需要返回更新的数据，假设没有更新，将返回一个没有body的 response，从而提高效率。</p><h3 id="Rewriting-Response-重写一个响应"><a href="#Rewriting-Response-重写一个响应" class="headerlink" title="Rewriting Response 重写一个响应"></a>Rewriting Response 重写一个响应</h3><p>若是透明压缩开启，OkHttp将会丢弃Content-Encoding 和 Content-Length，因为对用户来说，其得到的时解压后的body，而header返回的是压缩的body，故其长度是不对的。 （个人疑问？为什么不把解压后的长度值更新到header中，然后返回给用户?）</p><h3 id="Follow-up-Request-自动跟随request"><a href="#Follow-up-Request-自动跟随request" class="headerlink" title="Follow-up Request 自动跟随request"></a>Follow-up Request 自动跟随request</h3><blockquote><p>重定向，转发的区别？重定向会返回一个新的地址给客户端，让其重新请求，客户端有感知转发，则在服务器内部转发该请求，客户端无感知</p></blockquote><p>对于重定向请求，服务器返回响应码为 302 ，okHttp会帮助重新请求新的地址，返回给最终结果给用户。这样，用户对重定向也无感知了~~</p><p>对于需要验证身份的请求，（响应码为401，身份未验证），OkHttp会自动从 Authenticator(需要自己配置)，获取对应的凭证来验证身份。</p><h3 id="Retrying-Request-请求重试"><a href="#Retrying-Request-请求重试" class="headerlink" title="Retrying Request 请求重试"></a>Retrying Request 请求重试</h3><p>有时连接失败了，可能时因为连接断开了，或服务端不可达，OkHttp会自动尝试不同的路由。</p><p>由于，rewrite, redirect, follow-ups 和 retries的存在，一个请求可能会在中间过程会有很多个 request和 response,而 OkHttp 使用Call来封装这些过程，用户感觉到还是只有一个输入一个输出。</p><p>Call执行有两种方式：</p><ul><li>同步 sync: 调用线程阻塞等待知道结果可读。</li><li>异步 async: 调用线程只是将请求入队列，传入的callback会在结果可用时执行。</li></ul><p>Call 可以被任意线程取消，只要该请求完成都可以取消。<br>注意，当某一个线程被取消时，此时在写入reqeustBody或读取responseBody的代码都会抛出IO异常，设计如此。</p><h3 id="Dispatch-分发调度"><a href="#Dispatch-分发调度" class="headerlink" title="Dispatch 分发调度"></a>Dispatch 分发调度</h3><p>对于异步请求，如何管理同时并发的请求是个问题。创建过多的连接会方法资源，过少会导致请求延迟较大。</p><p>如何平衡空间与时间的问题，使用Dispatcher来设置，默认的连接池大小的，默认为5，最大值为64。  </p><blockquote><p>其原理与线程池基本是一致的。</p></blockquote><h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><p>OkHttp 提供了一个可选的缓存模块，默认关闭。 参照一些实用的设计，比如市面的浏览器。</p><h3 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private val client: OkHttpClient = OkHttpClient.Builder()</span><br><span class="line">    .cache(Cache(</span><br><span class="line">          // 缓存文件路径</span><br><span class="line">        directory = File(application.cacheDir, &quot;http_cache&quot;),</span><br><span class="line">        // $0.05 worth of phone storage in 2020</span><br><span class="line">        // 最大的缓存大小</span><br><span class="line">        maxSize = 50L * 1024L * 1024L // 50 MiB</span><br><span class="line">    ))</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure><p>理想情况下，若是缓存命中，会跳过 DNS, 连接网络，下载数据包，</p><p>未命中，比如，未请求过该数据，或该数据不可缓存，依据返回来的时间判断缓存已经过期了。</p><p>Conditional Cache Hit, (条件命中？)，需要请求网络来确定本地的缓存能够可用，通常是服务端返回一个304的状态告知缓存未修改，即依据客户端请求发来的if-modified-since。</p><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>虽然用户只提供了一个URL来发送一个请求，但是OkHttp建立一个连接却需要三个要素: URL, Address, Route</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>何为URL, Uniform Resource Locator，统一资源定位，比如一个 <a href="https://github.com/square/okhttp。" target="_blank" rel="noopener">https://github.com/square/okhttp。</a>  </p><p>是抽象的</p><ul><li>只是简单区分非加密http和加密https,却没有指定使用哪种加密算法。既没有要求如何验证对方的证书（HostNameVerify），也没说哪些证书可以信任（SSLSocketFactory）。  </li><li>没有指明哪些代理服务应该使用，如何验证代理服务器。</li></ul><p>也是具体的，一个URL指定了资源路径和查询参数，每个Web服务支持很多URL.</p><h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>地址指定了连接的是哪一个web服务，以及一些静态的配置，如端口，https的设置，偏好的协议（Http/2, SPDY）</p><blockquote><p>SPDY是一个优化的Http协议，多路复用、请求优先级、报头压缩（http报头用的明文，这里用的是二进制）。不过，http/2推出后已经不建议使用了<del>~</del></p></blockquote><p>同一个地址的URL可以共享一个tcp socket连接，低延迟，高吞吐。<br>若是服务端支持http/1.x，那么其连接池会复用。</p><blockquote><p>还是好好了解http 1.x &gt; 2.0的变化吧</p></blockquote><h3 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Android 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit</title>
      <link href="/2021/07/10/Retrofit/"/>
      <url>/2021/07/10/Retrofit/</url>
      
        <content type="html"><![CDATA[<h2 id="整体认识"><a href="#整体认识" class="headerlink" title="整体认识"></a>整体认识</h2><p>Retrofit 用接口中的方法和注解来描述一个HTTP请求，用户只用关注接口如何描述这个请求，而不用关注内部的具体实现。它将网络请求中，封装Request对象，解析Response对象等模板代码封装了起来，使得使用者<em>只要描述做什么，而无需关心怎么做</em>。</p><p>内部网络请求部分依赖了OkHttp,这样，解析方法后，就是OkHttp的工作了，创建Request，解析Response，而在这两个过程，涉及到数据（json, xml, 二进制（protobuf)）与Java对象的转换，即数据序列化/反序列，这里Retrofit没有新造轮子，而是提供一个适配器，让用户选择合适自己需求的工具，完美践行了<em>对扩展开放</em>的原则。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>关于这个设计模式，说下自己的理解。</p><p>代理，需要一个服务<code>ServiceA</code>，存在现有的类（代理目标类<code>Obj</code>）可以满足或满足部分需求，这时，假设想让<code>User</code>也拥有提供该服务的能力，我们不是直接继承<code>Obj</code>， 而时将该服务抽象为一个接口<code>ProvideServiceA</code>，表示具备可以提供这个服务A，此时，真正提供具备这个服务实现类为<code>Obj</code>，而我们的<code>User</code>也想拥有这份能力，可<code>User</code>又不但仅有这份能力，它还可能拥有A,B,C能力，故，它在是实现了 <code>ProviderServiceA</code>接口，但不是自己实现，而是直接使用<code>Obj</code>来提供该服务。</p><p>简单说，就是声明了具备某个服务的能力后，内部提供该接口的实现类的实例，在方法中转发该消息到实例来完成。</p><p>可以发现，当有一个类可以提供某个服务后，我们不是简单继承它来表示具备有该服务能力，而是添加一个接口，表示是是实现该接口的类都具备有这份能力，这样，我们会发现，我们需要额外引入一个接口类，这是不是Java不支持多继承导致的额外成本呢？</p><p>这个问题我无法判断。</p><p>在Java的概念中，接口表示一份契约，只是表示提供了某个服务，具体的实现延迟到了具体的实现类实现。  </p><p>一个复杂的类，可以实现多个接口，它表示可以提供一系列服务的类，这些服务对外形成了一个整体的概念，而在实现方法中，又可以划分为子服务，在内部使用其他自服务的实例来完成，以这个概念来看，我觉得这样的思考方法非常符合<code>分治</code>的思维，将大问题拆分为子问题，在子问题的实现上，可能又会继续拆分。大问题和子问题之间的关系，完成依照它们的接口来完成，不会跟他们的子问题实现产生联系，这样，在查看代码时，使得我们很容易在了解这一个层次上类关系，而不是陷入子问题实现的细节中。       </p><p>好吧，扯得有点远了。<br>代理模式在印象中有一个案例是，在Android插件化中，对于Android四大组件类，我们会对他们进行插桩，在Manifest清单文件中声明一个ProxyActivity，而在我们得插件类PluginActivity中，虽然我们实现了Activity得方法，但是其具体得实现是转发给ProxyActivity来是实现的，比如 <code>findViewById()</code>,<code>getAssertManager()</code>方法，因为即使我们在插件模块中创建了Activity实例，我们也不能直接使用相关的方法，因为这个Activity是没有在Android系统中注册，系统在处理Intent时是找不到该Activity。</p><p>而动态代理，区别于静态代理需要声明一个接口，在目标类和代理中都要是实现接口方法，动态代理不需要在编译时引入接口类，在调用代理类方法时，除了转发给目标类对应方法，也可以添加自己的增强代码（日志、额外操作等）。</p><h2 id="感叹细节实现"><a href="#感叹细节实现" class="headerlink" title="感叹细节实现"></a>感叹细节实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> // 描述业务上需要Http方法</span><br><span class="line">interface Service &#123;</span><br><span class="line">  @GET(&quot;/&quot;) Call&lt;ResponseBody&gt; getBody();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 用于创建一个Retrofit实例</span><br><span class="line">  Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">      .baseUrl(server.url(&quot;/&quot;))</span><br><span class="line">      .build();</span><br><span class="line">  // 为描述接口方法创建具体的代理实例</span><br><span class="line">  Service example = retrofit.create(Service.class);</span><br></pre></td></tr></table></figure><h2 id="创建一个代理实例"><a href="#创建一个代理实例" class="headerlink" title="创建一个代理实例"></a>创建一个代理实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</span><br><span class="line">  validateServiceInterface(service);</span><br><span class="line">  return (T)</span><br><span class="line">          // 返回一个代理实例，代理实现interfaces中的方法</span><br><span class="line">          // 所有方法都会通过InvocationHandler来实现</span><br><span class="line">          // 被代理的接口，仅是描述了要干什么，怎么干委托给了handler</span><br><span class="line">          // 原本接口的方法实现仅是 method.invoke(proxy, args)，或者为abstract方法无法直接调用</span><br><span class="line">          // 而在handler中我们可以在基于该方法默认实现之上，可以做AOP类似的骚操作，比如修改参数、修改返回值，插入日志、甚至替换原来的实现</span><br><span class="line">          // 而在这个库中，只是提取方法中信息（主要是注解），创建一个ServiceMethod，而在这个方法后</span><br><span class="line">      Proxy.newProxyInstance(</span><br><span class="line">          service.getClassLoader(),</span><br><span class="line">          // 被代理额目标类，所有的方法都会转发给下面的Handler处理</span><br><span class="line">          new Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">          new InvocationHandler() &#123;</span><br><span class="line">            private final Platform platform = Platform.get();</span><br><span class="line">            private final Object[] emptyArgs = new Object[0];</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)</span><br><span class="line">                throws Throwable &#123;</span><br><span class="line">              // If the method is a method from Object then defer to normal invocation.</span><br><span class="line">              // 正常调用Object的方法</span><br><span class="line">              if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                return method.invoke(this, args);</span><br><span class="line">              &#125;</span><br><span class="line">              args = args != null ? args : emptyArgs;</span><br><span class="line">              return platform.isDefaultMethod(method)</span><br><span class="line">                  // 若是Java8提供的默认方法，直接调用</span><br><span class="line">                  ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                  // 解析该方法并执行</span><br><span class="line">                  : loadServiceMethod(method).invoke(args);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下就是解析方法，执行方法了</p><h2 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h2><h3 id="使用缓存避免解析多次"><a href="#使用缓存避免解析多次" class="headerlink" title="使用缓存避免解析多次"></a>使用缓存避免解析多次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  // 解析方法费时，缓存下来</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  if (result != null) return result;</span><br><span class="line"></span><br><span class="line">  // 这里为什么需要加锁呢？</span><br><span class="line">  // 在添加方法时，避免解析多次</span><br><span class="line">  synchronized (serviceMethodCache) &#123;</span><br><span class="line">    // 假设由两个线程A,B都调用同一个方法，且该方法未解析</span><br><span class="line">    // A解析后修改map，退出</span><br><span class="line">    // B等到A释放锁后，再次检验该map，来确认是否要解析</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    if (result == null) &#123;</span><br><span class="line">      // 见下解析方法2</span><br><span class="line">      result = ServiceMethod.parseAnnotations(this, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析出信息"><a href="#解析出信息" class="headerlink" title="解析出信息"></a>解析出信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123;</span><br><span class="line">  // 只是解析注解信息出来</span><br><span class="line">  RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"></span><br><span class="line">  // 判断方法的返回值</span><br><span class="line">  Type returnType = method.getGenericReturnType();</span><br><span class="line">  if (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">    throw methodError(</span><br><span class="line">        method,</span><br><span class="line">        &quot;Method return type must not include a type variable or wildcard: %s&quot;,</span><br><span class="line">        returnType);</span><br><span class="line">  &#125;</span><br><span class="line">  // 注意定义的接口时不能返回值为空的，</span><br><span class="line">  // 那么怎么不判断Kotlin的Unit? todo</span><br><span class="line">  if (returnType == void.class) &#123;</span><br><span class="line">    throw methodError(method, &quot;Service methods cannot return void.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Http方法具体实现，见下</span><br><span class="line">  return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>HttpServiceMethod.java</p></blockquote><p>解析注解信息后，依据返回值类型，选择可用的 CallAdapter、Converter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(</span><br><span class="line">     Retrofit retrofit, Method method, RequestFactory requestFactory) &#123;</span><br><span class="line">   Annotation[] annotations = method.getAnnotations();</span><br><span class="line">   // 获取返回值类型</span><br><span class="line">   Type adapterType;</span><br><span class="line">   adapterType = method.getGenericReturnType();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   // 根据解析出来了方法返回值类型，选择合适的CallAdapter</span><br><span class="line">   // 何为CallAdapter, 将</span><br><span class="line">   CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">       createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">   // 返回确切的Response类型</span><br><span class="line">   // 比如在RxJava Complete会是Void.class, Observable&lt;User&gt;，则是User</span><br><span class="line">   Type responseType = callAdapter.responseType();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   if (responseType == Response.class) &#123;</span><br><span class="line">     throw methodError(method, &quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // OKHttp返回一个ResponseBody，选择一个Converter来转换</span><br><span class="line"></span><br><span class="line">   Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">       createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">   okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">   return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h3><p>在真正执行该方法时，跳到这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">final @Nullable ReturnT invoke(Object[] args) &#123;</span><br><span class="line">  // 创建一个OkHttpCall</span><br><span class="line">  Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">  // 准备一切后，真正开始调用方法</span><br><span class="line">  return adapt(call, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在Rxjava中的 adapt方法实现</p><p>原本一个Call的返回只是一个Response，通过适配adapt，将其转换成我们想要的东西。</p><p>在RxJava中将Response创建了一个可以观察的源，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Object adapt(Call&lt;R&gt; call) &#123;</span><br><span class="line">  </span><br><span class="line">    Observable&lt;Response&lt;R&gt;&gt; responseObservable =</span><br><span class="line">        isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call);</span><br><span class="line"></span><br><span class="line">    Observable&lt;?&gt; observable;</span><br><span class="line">    if (isResult) &#123;</span><br><span class="line">      observable = new ResultObservable&lt;&gt;(responseObservable);</span><br><span class="line">    &#125; else if (isBody) &#123;</span><br><span class="line">      observable = new BodyObservable&lt;&gt;(responseObservable);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      observable = responseObservable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不为空，还为其切换到响应的线程执行</span><br><span class="line">    if (scheduler != null) &#123;</span><br><span class="line">      observable = observable.subscribeOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isFlowable) &#123;</span><br><span class="line">      return observable.toFlowable(BackpressureStrategy.LATEST);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isSingle) &#123;</span><br><span class="line">      return observable.singleOrError();</span><br><span class="line">    &#125;</span><br><span class="line">    if (isMaybe) &#123;</span><br><span class="line">      return observable.singleElement();</span><br><span class="line">    &#125;</span><br><span class="line">    if (isCompletable) &#123;</span><br><span class="line">      return observable.ignoreElements();</span><br><span class="line">    &#125;</span><br><span class="line">    return RxJavaPlugins.onAssembly(observable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体下来，看得挺懵逼的~  </p><p>基本思路，解析方法上的信息后，尤其时返回值类型，判断其需要的CallAdapter，用于将请求返回值构建成对应的实例。默认下，返回一个定义Call,表示了一个请求，包括发送一个request和返回一个Response，当RxJava的适配器时则返回一个Observable。</p><p>另一个就是Converter，将对象转换成http协议支持的类型，比如Json，普通文本，或数据流。转换时，包括创建请求时的requestBodyConverter以及responseBodyConverter。</p><p>无论是CallAdapter，还是Converter，两者都是可以配置补充的。当解析接口方法时，检查到其类型时，在Retrofit配置的Factory支持集合中选择合适的类型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAM-conversion 是什么</title>
      <link href="/2021/07/10/SAM-conversion%20%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2021/07/10/SAM-conversion%20%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-SAM-conversion"><a href="#关于-SAM-conversion" class="headerlink" title="关于 SAM-conversion"></a>关于 SAM-conversion</h2><p>看到一些注释提到 SAM-conversion，查找之后记录下。</p><p>SAM全称是 Single Abstract Method，当 Interface 只有一个抽象方法时，它可以当作一个函数来调用。比如View点击接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单一抽象方法的接口</span></span><br><span class="line">inteface OnClickListener&#123;</span><br><span class="line">    onClick(View v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span></span>&#123;</span><br><span class="line">    <span class="comment">// 形参需要一个接口实例</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用lambda，显式的创建实例</span></span><br><span class="line">view.setOnClickListener(object:View.OnClickListener&#123;</span><br><span class="line">       <span class="function">override fun <span class="title">onClick</span><span class="params">(v: View?)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="comment">// 使用lambda，隐式创建实例，编译器帮我们转换成显式的代码</span></span><br><span class="line">view.setOnClickListener&#123;v-&gt;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当将这个接口作为一个方法参数时，需要分两步：</p><ol><li>创建一个实现类，并实现抽象方法（一般是匿名类）</li><li>创建的实现类的实例</li></ol><p>代码上，当形参类型是一个单一方法的接口时，可以用 lambda 表达式代替，但实际中，其形参还是需要一个具体的对象，所以 SAM-conversion就是，代码写了lambda，编译时帮我们转换成显式的代码，运行时创建接口的实例。</p><h2 id="SAM对比类型别名（Type-aliases）"><a href="#SAM对比类型别名（Type-aliases）" class="headerlink" title="SAM对比类型别名（Type aliases）"></a>SAM对比类型别名（Type aliases）</h2><p>与 Java 不同，Kotlin 支持函数类型，函数可以作为方法的形参。我们可以为一个函数类型定义一个别名，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为一个函数类型取一个别名</span></span><br><span class="line">typelias OnClick = (view) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作为形参</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">setOnClick</span><span class="params">(onClick: <span class="type">OnClick</span>)</span></span></span><br></pre></td></tr></table></figure><p>虽然类型别名和SAM接口非常像，尤其在使用的时候，都可以写成lambda的形式，但其区别还是有的。</p><ol><li>SAM效率效率低点，需要创建一个新的实例类，并创建实例。而类型别名不会创建新的类型</li><li>SAM也有优势，其接口类可以包含其他成员，比如其他非抽象成员，适用复杂的场景<ol><li>SAM适用和 Java无缝调用，而在 Kotlin 定义的类型别名，在Java中无妨使用</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SparseArray</title>
      <link href="/2021/07/07/SparseArray/"/>
      <url>/2021/07/07/SparseArray/</url>
      
        <content type="html"><![CDATA[<p>给自己一个自认为熟悉的感念，表达出来能得到多少分？</p><p>是的，我认为我对 <code>SparseArray</code> 熟悉，可当我要表述这个数据结构时，我该怎么表达呢？</p><h3 id="首先，描述使用范围，对比HashMap"><a href="#首先，描述使用范围，对比HashMap" class="headerlink" title="首先，描述使用范围，对比HashMap"></a>首先，描述使用范围，对比HashMap</h3><p><code>SparseArray</code> 适用于key-value结构的数据，相比于Java基础库提供的通用的 <code>HashMap</code>，<code>SparseArray</code> 限制了key只能为int类型，可以节省存储空间，在数据范围小时存取效率优于 <code>HashMap</code>。</p><p>为何省空间？</p><p>其key直接使用了基本类型int，不同于HashMap存储时经过装箱使用Integer，而且，当确定value也是一种基本类型时，可以使用对相应得SparseXXXArray，比如对于 &lt;Integer,Integer&gt;，可以使用 <code>SparseIntArray</code>，这样value也可以存储在基本类型数组，而基本类型所占内存是远小于对象的。</p><p><code>SparseArray</code>内部有两个数组，<code>mKeys</code>, <code>mValues</code>, key直接升序放置在 <code>mKeys</code>数组中，其插入过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; binarySearch -&gt; index </span><br><span class="line">    put key in mKeys[index]</span><br><span class="line">    put value in mValues[index]</span><br></pre></td></tr></table></figure><p>将key转换成index是一次二分查找得过程，其要求key在数组中有序的。</p><p>而 HashMap 其内部可以看作有一个 <code>tables</code>，元素类型是一个Entry&lt;Key,Value&gt;，其插入过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; hash -&gt; index</span><br><span class="line">     h = key.hashCode()</span><br><span class="line">     hash = h ^ ( h &gt;&gt;&gt; 16) </span><br><span class="line">     ensure hash &lt; n ,(n = table.length)</span><br><span class="line">     index = hash &amp; (n - 1)   // 依赖n为2的k次方</span><br></pre></td></tr></table></figure><p>生成hash时，将高16位与低位异或，高16位相当于取非了，从而把高位的信息分配到低位上，这样做的原因是，最后我们可以利用到的高位的信息。<br>为何？假设 n = table.length &lt;= pow(2,16)，那么在转移成index时，我们仅仅利用到了hash的低16位。</p><p>生后hash后，要确保hash值能在范围n里面，其思路是指截取n包括的低比特位，大于n的比特位都丢掉的，这样便得到所需的index。</p><p>使用index时，理想情况下，table[index]没有元素，即无hash冲突。<br>冲突时，转为链表，其实存储时，tables存储的就是链表节点，甚至为树节点。<br>存在类存在这样的继承关系，Entry &gt; Node &gt; TreeNode。    </p><p>两者都存在从 key 到 index的过程，理论上，可以看到查找时间复杂度，前者为 O(logN)，后者为 O(1)，似乎后者更胜一筹。 但应了解到，这里说的时间复杂度是简化分析后的结果，忽略了复杂度前面的常量，前者常量可能是1，后者可能是50，当数据量N比较小时，假设N=20，<code>1 * log2(20) &lt; 50 * 1</code>实际上是前者更快一点的。这一点，做题时也有所体会，有时暴力比最优解更快，原因是用例N太小了。 </p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除时用于标记某坑位，避免每次删除时都要挪动元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object DELETED = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 是否有可能清理DELETED垃圾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mGarbage = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键两个数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mKeys;</span><br><span class="line">    <span class="keyword">private</span> Object[] mValues;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSize;</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找到这个key应该放在哪？</span></span><br><span class="line">    <span class="comment">// 这个二分查找，特别之处在于当找不到时，返回该插入下标的取非（不是相反数吧，取反+1才是，不纠结）</span></span><br><span class="line">    <span class="comment">// 取非必然为负数，因为首位0改为1了,这样用负数表示不能存在该key，而且还把该插入的下标变相地保存了下来</span></span><br><span class="line">    <span class="comment">// 是我孤陋寡闻了</span></span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 存在已放置的 key 相同，直接替换（并没有HashMap的替换与否的策略）</span></span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 转为该插入下的下标</span></span><br><span class="line">        i = ~i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发现居然那个坑是无用的，直接替换，免除数组插入的困扰</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 坑位使用完了，且可能存在垃圾，尝试回收下</span></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            <span class="comment">// 思路就是移除mValues数组中DELETED无效元素，有效元素往前移</span></span><br><span class="line">            <span class="comment">// JVM老年代垃圾清除算法思路（更追求省内存，碎片整体）</span></span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将key插入到mKeys的i位置上</span></span><br><span class="line">        <span class="comment">// mSize + 1 == mKeys.length 时，扩容 currentSize &lt;= 4 ? 8 : currentSize * 2，创建新的数组复制原来的元素</span></span><br><span class="line">        <span class="comment">// 即使不需要扩容，也需要移动 i 位置之后元素后移一位</span></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询-无需整理"><a href="#查询-无需整理" class="headerlink" title="查询,无需整理"></a>查询,无需整理</h4><p>通过key来查询，不需要整理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> key, E valueIfKeyNotFound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用标记，我们确认某个key不存在，或已经被删除</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || mValues[i] == DELETED) &#123;</span><br><span class="line">        <span class="keyword">return</span> valueIfKeyNotFound;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) mValues[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询，需整理"><a href="#查询，需整理" class="headerlink" title="查询，需整理"></a>查询，需整理</h4><p>发现依赖了index的查询需要gc,当然还包括插入时也得gc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    if (mGarbage) &#123;</span><br><span class="line">        gc();</span><br><span class="line">    &#125;</span><br><span class="line">    return mSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int keyAt(int index) &#123;</span><br><span class="line">    if (mGarbage) &#123;</span><br><span class="line">        gc();</span><br><span class="line">    &#125;</span><br><span class="line">    return mKeys[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>可以欣赏的一点就是，频繁删除元素后，不会马上整理Values数组，而时延后到查询/插入时才会整理，整理就是清除无用的DELETED坑位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    delete(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeReturnOld</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            <span class="keyword">final</span> E old = (E) mValues[i];</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>另外，SparseXXXMap都要求Key必须为int，若是key不是int，可以用ArrayMap，大略看了下，相似度挺高的，大致是将key转为hash作为key来排序。</p><p>好了，发现自己表达起来确实很着急~对比大佬的<a href="https://juejin.cn/post/6844903961963528199#heading-10" target="_blank" rel="noopener">博文</a></p><p>别人家写的，虽然自己也能感受到的，但表达出来还是很困难。</p><p>引用大佬总结的三个关键字，<em>双数组，二分查找，DELETED标记</em>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于并发</title>
      <link href="/2021/06/19/%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/"/>
      <url>/2021/06/19/%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="区别与并行"><a href="#区别与并行" class="headerlink" title="区别与并行"></a>区别与并行</h3><blockquote><p>感觉了解其区分，描述起来好难</p></blockquote><h4 id="他人的回答："><a href="#他人的回答：" class="headerlink" title="他人的回答："></a>他人的回答：</h4><p> 并发（Concurrency）是说进程B的开始时间是在进程A的开始时间与结束时间之间，我们就说A和B是并发的。</p><p> 并行（Parallel Execution）是并发的真子集，指同一时间两个进程运行在不同的机器上或者同一个机器不同的核心上。</p><h4 id="自己的话"><a href="#自己的话" class="headerlink" title="自己的话"></a>自己的话</h4><p>并行是同一个时刻有多个任务被执行，至少得有两个CPU。</p><p>并发不要求同一个刻被运行，两个任务可以交替执行，或是同时运行，即并发包括了并行的情况。</p><h3 id="工作中理解到并发"><a href="#工作中理解到并发" class="headerlink" title="工作中理解到并发"></a>工作中理解到并发</h3><p>在Android中什么时候有多个任务并发运行呢？  </p><p>多个任务并发运行，即可以理解为多个线程的情况。容易想到的是JVM中存在一个用于垃圾回收守护线程和主线程，守护线程一直在监控着资源的使用情况，</p><p>进行耗时操作，比如网络请求、解析xml文件，创建一个子线程来处理。</p><p>子线程处理完后，如何将结果通知给主线程呢？</p><p>比如 Main 启动一个 A线程执行任务，那么计算完如何通知A线程呢？</p><p>想到的是创建一个Callback，创建任务传递A线程，那么在A线程计算得到结果后，调用callback？</p><p>若是在A线程中直接调用callback，那么该方法实在A线程中运行的，而我们想要该callback在Main线程中执行呢？</p><p>想到这，此刻我有点惊讶我没有认真过这个问题~ </p><p>我们假设一种简单情况，Main线程在启动A线程后，阻塞等待，等待A线程返回结果后再执行后续的处理, 那么可以使用 <code>join()</code>方法等待A线程计算完成，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个公共变量，在A线程中修改，在主线程中展示，这里使用volatile使其修改对主线程可见</span></span><br><span class="line"><span class="comment">// 使用数组达到传址的效果</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread tA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"a:"</span> + result[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        tA.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主线程等待a线程执行完</span></span><br><span class="line">        tA.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main:"</span> + result[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了 <code>join()</code> ，其实现还是用了 wait/notify机制，直接使用wait/notify带来实现上述需求</p><p>obj.wait() 将该线程进入等待状态，知道其它线程调用obj的notify或被当前线程被中断<br>其本质是将本线程加入到<code>obj</code>的对象头中的等待集合中，并且本线程不再作为该对象的owner of the object’s monitor,<br>本线程不再拥有该对象的拥有权，注意是拥有该对象的所有权才能调用该方法的  </p><p>obj.notify()，也是得到了该对象的所有权后才能调用notify(),故需要先获取锁再操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个对象作为锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread tA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"a:"</span> + result[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;   <span class="comment">// 获取到锁</span></span><br><span class="line">            <span class="comment">// 唤醒其他等待在该lock的一个线程</span></span><br><span class="line">            <span class="comment">// 注意只是唤醒,其他线程还是等到本线程释放锁才能获取继续运行</span></span><br><span class="line">            lock.notify();</span><br><span class="line">            <span class="comment">// 假设这里 sleep(3000)，线程A还是会因为持有该锁，故，主线程得等到sync结束后才能继续运行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tA.start();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"main:"</span> + result[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，主线程阻塞运行，等待子线程结束后才继续运行，而，若是想再开启子任务后，想要主线程继续运行呢？</p><p>这个样的需求，其实就是Handle处理的场景，那我们不依赖Android如何实现呢？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护一个任务队列 queue，主线程开启一个死循环，不断取出队列中的任务来执行；<br>当我们想在主线程开启一个子线程来计算时，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于JVM</title>
      <link href="/2021/06/17/%E5%85%B3%E4%BA%8EJVM/"/>
      <url>/2021/06/17/%E5%85%B3%E4%BA%8EJVM/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 自己能说多少？</p></blockquote><p>用于执行Java字节码指令的虚拟机，相对操作系统来说，它是一个进程，一般的虚拟机都是用C/C++来写的，在不同的系统中，它的实现是不同的，作为Java程序和操作系统的中间层，通过它实现了同一套Java程序可以在不同程序中运行。</p><p>尽管被称之为Java虚拟机，但是它可以运行Kotlin、Scala语言编写的程序，是因为对于JVM来说，它能运行的是Class字节码，通过不同语言的编译器，这些语言代码都会编译成Class文件。</p><h3 id="对比Dalvik虚拟机、ART"><a href="#对比Dalvik虚拟机、ART" class="headerlink" title="对比Dalvik虚拟机、ART"></a>对比Dalvik虚拟机、ART</h3><p>首先，需要了解的是，在Android系统中，并不是直接用JVM虚拟机，早期用的Dalvik虚拟机，后面用的是ART，不过，后两者都是执行是dex文件，而非JVM的Class文件。</p><p>而class到dex的转换是在apk打包过程中进行的，dex相比于class，其重要的一个区别是，使得字节码占用的存储变小了，主要原因是在dex中常量池是复用的，而在class中，每个class文件拥有一个常量池，导致很多相同常量在class文件之间不能复用，而在字节码中，常量池占比一般是最大的。</p><p>而无论是什么字节码，都会有两部分构成，数据、指令，而常量池属于数据，常量池包括类、方法、的全限名。比如<code>Lang\java\Object</code>,还包括一些字面量，初略  的看，代码中所有的字符都是存在常量池中的，比如类名、类方法，类成员，故这些信息占的存储空间是很大的。  </p><p>对于Class字节码，其构成大致包括<br>魔数，用来标志该文件是什么文件的，Class文件的魔术是对应的16进制的CAFEBABE,其实只是一个标志而已<br>支持的版本信息，表示该Class是Java什么版本编译出来的，当前JVM会检验能不能支持运行该版本的Class文件。<br>常量池<br>方法表  </p><h3 id="凭什么dex能共用常量池，而class一个文件一个常量池？"><a href="#凭什么dex能共用常量池，而class一个文件一个常量池？" class="headerlink" title="凭什么dex能共用常量池，而class一个文件一个常量池？"></a>凭什么dex能共用常量池，而class一个文件一个常量池？</h3><p>当看到经过dex化后可以减少存储空间的占有，咋一看感觉dex字节码更胜一筹，难道真的如此吗？</p><p>个人认为，诸如类似的优化，其思想都是依据使用场景变化后调整了策略，并无高低之分。</p><p>class设计成单个文件自带一个常量池，是因为出于class可以单个文件独立加载到JVM来运行的需要，场景是可以网络下载了一个class便可以直接运行。而dex将原本多个class的常量池复用，那么就不再适用于网络加载一个class就能运行场景，得加载原来多个class得信息量，也就是加载一个dex文件才能运行。    </p><p>可以说，若是都是网络加载字节码来运行，那么一个dex包大小比class大得多。</p><p>另外，既然可以打包class，Java体系中使用了jar来打包，不知道是否相关得压缩信息量得策略。</p><p>而，Android中网络加载dex来运行得案例也是有的，比如热修复技术中thinker，就是下载一个补丁dex文件。</p><h3 id="栈式虚拟机、寄存器式虚拟机对比？"><a href="#栈式虚拟机、寄存器式虚拟机对比？" class="headerlink" title="栈式虚拟机、寄存器式虚拟机对比？"></a>栈式虚拟机、寄存器式虚拟机对比？</h3><p>JVM是栈式的，而Dalvik是寄存器式。</p><p>在于指令不同，首先，指令由操作码和操作数组成，操作码表示要干什么，操作数表述对什么数值进行操作；<br>而两者的最大区别应该是操作数的寻址方式不同，栈式的指令的寻址地址永远是栈顶的数，而寄存器式指令，指令本身包括了操作数所在的位置，比如在某个寄存器，前者寻址是隐式的，而后者是显式的。  </p><p>比如一个加法指令，栈式指令的执行过程是，先后弹出栈顶两数相加，后把结果推入栈顶。<br>而寄存器式指令，则可以是由三地址组成，即 <code>iadd dest src1 src2</code>，这样，要分配三个寄存器，首先要把操作数读取到两个源寄存器中，经过CPU计算后，将结果存放在目标寄存器中。    </p><p>这样，利用的栈的数据结构，操作地址都是隐式的，可以让指令更简练，即指令集更小。  </p><p>而表达更简练的后果是，同一个操作，需要指令更多，而CPU执行指令的过程是不断地<code>取指令</code>和<code>执行指令</code>，而当时间都耗费在取指令上时，效率就降低了。</p><h3 id="关于Java字节码指令，所知多少？"><a href="#关于Java字节码指令，所知多少？" class="headerlink" title="关于Java字节码指令，所知多少？"></a>关于Java字节码指令，所知多少？</h3><p>除了上面所提及的栈式指令整体以外，从具体的一些指令举例。<br>比如一个加载指令，为什么要区分 sload, iload, dload, lload, 即区分操作数类型。<br>指令本身的信息就得包括类型，因为这告知了CPU加载一个数，该从内存起点偏移多长，比如short类型只包括两个字节，int包括4个字节等等。</p><h3 id="关于JIT、AOT"><a href="#关于JIT、AOT" class="headerlink" title="关于JIT、AOT"></a>关于JIT、AOT</h3><p>虚拟机中的指令，最终指令还是要转换成本地机器码，即CPU能够识别的指令。    </p><p>JIT是 just in time, 即执行过程中，虚拟机在运行时将字节码指令转换成本地机器指令。<br>AOT是 ahead of time,在运行之前就将字节码转换成机器码。  </p><p>两者的区别可以理解为懒汉式和饿汉式，也可以用我们考量空间和时间区别，或时间消耗的不同。JIT可以在加载部分Class文件后便执行，可以快速的看到执行效果，AOT则是选择在APK安装中，将字节码全部转换成机器码，导致安装比较久，而且安装后占用存储空间大，这在android 7.0中体现。</p><p>而在7.0之前，全部只用JIT，导致运行性能不够高，毕竟运行时还要将时间消耗在转换字节码上。  </p><p>而在8.0之后，ART,即Android Runtime，在这两者做了平衡，而是在运行过程中，才将字节码转换，并且将转换后的字节码保存下来，而且是计算了常常使用到的字节码才做转换，保存在optimized目录下。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于线程</title>
      <link href="/2021/06/11/%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/06/11/%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="关于线程，自己能说多少呢？"><a href="#关于线程，自己能说多少呢？" class="headerlink" title="关于线程，自己能说多少呢？"></a>关于线程，自己能说多少呢？</h2><h3 id="线程是什么？"><a href="#线程是什么？" class="headerlink" title="线程是什么？"></a>线程是什么？</h3><p>线程是作为CPU调度的最小单位</p><p>表现在一个线程对应了一个程序计数器，程序计算器记录着CPU执行到了哪个指令了</p><p>一个段代码块，经过编译后，对应了一串指令，CPU执行过程就是取指令和执行指令，过程中总要记录下一个该取哪个指令，这个指令的下标就是放在PC中。</p><p>对于普通的指令，执行完后PC加一，表示取下一条指令来执行<br>对于跳转指令，执行该指令的实质就是给PC赋值，这样，在取指令的时，就可以取到对应的指令，最终实现指令跳转，而对于CPU来说，永远是取的PC中的指令来执行，可以说，CPU对于是否跳转是无感知的。</p><p>一段代码块想要被执行，就必须以线程的形式交由给虚拟机，这样才有机会获得CPU执行的可能。</p><p>以CPU视角来看，只认识线程，故，只有将代码逻辑包裹在线程中才可得以执行。</p><h3 id="对比进程？"><a href="#对比进程？" class="headerlink" title="对比进程？"></a>对比进程？</h3><p>进程是包含线程的，一个进程可以包含多个线程。进程持有了一段内存空间，用来分配给线程使用，而我们指的堆，就是在进程内存空间中的，供不同线程使用。另外，系统中的一些权限也是以进程为单位分配的。</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程的状态有<br>刚创建好、可运行、阻塞、等待、超时等待、终止   </p><p>其中，可运行状态的是对于虚拟机来说的，为什么没有区分为在ready和running，对于操作系统中的线程，是区分这两个状态的，而对于JVM来说，却把这两个状态都归为runnable状态，表示虚拟机不关注线程是否正在被运行，JVM对于操作系统来说，它是将一个线程交付给操作系统运行的，把JVM中的线程映射到操作系统中的线程。</p><p>一个线程中在执行中 <code>serverSocket.accept()</code>方法，被称为阻塞运行，这时候检查该线程的状态，发现它是 <code>Runnable</code>，对于想JVM来说它就是在运行的，但在操作系统中，它就是在等待状态，它不会占据CPU。</p><p>对于Runnable，虚拟机认为这是可运行的线程，由操作系统调度运行，可能在等待某个资源，比如CPU、或IO</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LiveData</title>
      <link href="/2021/05/12/LiveData/"/>
      <url>/2021/05/12/LiveData/</url>
      
        <content type="html"><![CDATA[<h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p>LiveData作为一个可以观察的数据源，其目标也是实现一个消费者模式的模型，不过，它的特别之处在于其消费是具有生命周期的。</p><p>一个传统的消费者模式，就是有一个数据源,和一堆消费者，数据源维护了一个消费者集合，通过<code>订阅</code>将消费者添加到集合中，<code>取消订阅</code>就是将其从集合中删除，当数据变化时，通知集合中的消费者。</p><p>其作用是为了解耦了事件发生、和处理事件的逻辑，比如可以任意添加或删除对一个事件的处理。</p><p>传统的消费者模式在UI中通常存在一个问题，内存泄漏。消费者（Fragment, Activity）一般具有自己的生命周期，当其需要重建时，因为数据源持有它的引用，导致不能及时释放。故，一些数据层持有View层的模型，都需要手动释放View，即<code>取消订阅</code>。</p><p>而 LiveData 内部帮助我们解决了这个问题，通过将observer 绑定在 <code>lifecycleOwner</code>上，使得注册可以感应消费者的生命周期，当其内部生命周期到 <code>destroy</code>状态时便取消订阅。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LiveData.observe(lifecycleOwner, observer)</span><br></pre></td></tr></table></figure><p>除了感应生命周期外，LiveData 也提供了一些额外的特性：</p><p>作为数据源，也想知道自己一直分发数据是否有意义？即，都没有消费者监听数据，则无意义。有一个消费者监听，则有意义。</p><p>数据源可以被 <code>active</code> 或 <code>inActive</code>，使得在没有消费者监听时，可以及时停止分发数据。</p><p>注意，对于数据关心一个不是Fragment，而Fragment中的View，因而我们一般用viewLifecycleOwner而非Fragment本身。</p><p>因为 onStart  &gt; onResume &gt; 跳转到其他页面 &gt; onDestryView &gt; 返回重新执行 onCreateView()</p><p>跳转到其他页面，Fragment不会被销毁，只是销毁其中的View，当重新创建View后，view不能马上更新到LiveData的状态。故而，我们使用 view的生命周期，在onCreatedView后，重新将LiveData的数据重新刷新到view上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-Transition</title>
      <link href="/2021/04/26/Android-Transition/"/>
      <url>/2021/04/26/Android-Transition/</url>
      
        <content type="html"><![CDATA[<p>对Android Transition好奇，记录追踪代码</p><h2 id="Transition是什么？"><a href="#Transition是什么？" class="headerlink" title="Transition是什么？"></a>Transition是什么？</h2><img src="/images/transitions.gif" width="240" height="200"><p>如图，关注左上角的图块</p><p>可以看到，它先改变颜色，后平移到右下角，平移过程中大小也在变化，整体上看就是三个Animator的组合完成；现在我们看到使用Transition如何实现的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> transition = TransitionInflater.from(<span class="keyword">this</span>).inflateTransition(R.transition.custom_transistion)</span><br><span class="line">root.setOnClickListener &#123;</span><br><span class="line">    <span class="comment">// 每一次点击，往返切换start、end 状态</span></span><br><span class="line">    TransitionManager.beginDelayedTransition(root, transition)</span><br><span class="line">    end = !end</span><br><span class="line">    toggleView()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区分当前状态，start or end</span></span><br><span class="line"><span class="keyword">var</span> statusEnd = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toggleView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    container.children.forEach &#123;</span><br><span class="line">        it.visibility = <span class="keyword">if</span> (statusEnd) View.INVISIBLE <span class="keyword">else</span> View.VISIBLE</span><br><span class="line">    &#125;</span><br><span class="line">    view_target.layoutParams = (view_target.layoutParams <span class="keyword">as</span> FrameLayout.LayoutParams).apply &#123;</span><br><span class="line">        gravity = <span class="keyword">if</span> (statusEnd) (Gravity.BOTTOM or Gravity.RIGHT) <span class="keyword">else</span> (Gravity.TOP or Gravity.LEFT)</span><br><span class="line">        width = <span class="keyword">if</span> (statusEnd) <span class="number">300</span> <span class="keyword">else</span> <span class="number">100</span></span><br><span class="line">        height = <span class="keyword">if</span> (statusEnd) <span class="number">300</span> <span class="keyword">else</span> <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">    view_target.setBackgroundColor(<span class="keyword">if</span> (statusEnd) Color.BLUE <span class="keyword">else</span> Color.RED)</span><br><span class="line">    view_target.apply &#123;</span><br><span class="line">        alpha = <span class="keyword">if</span>(statusEnd) <span class="number">1f</span> <span class="keyword">else</span> <span class="number">0.5f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体上看，依据 <code>statusEnd</code> 定义了两个状态 start，end，而依据这个状态，确定View的 visibility，position,size,color的属性。<br>切换状态，并非生硬地切换，而是在切换过程加入针对相关属性的过度动画，我想这就是Android加入这个库的用处吧。  </p><p>一个页面的两种状态，换个角度，也可以把这两种状态是视为两个页面，切换状态就是切换页面了，这里，我们将变化的页面称之为 <code>Scene</code>, 变化的过度动画交给 <code>Transition</code> 处理。</p><h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><p>表示一个页面，会绑定到一个实际的View中。作为一个页面，会有进入和弹出两个动作，在这两个动作发生时会执行View中某些property的动画。</p><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>切换的涵盖了从一个旧的Scene到新的Scene的过程，包括 old scene exit 和 new scene enter.</p><p>维护一些动画信息，在Scene变化时执行持有的动画。主要做两件事：</p><ol><li>capture property value</li><li>play animations based on change to captured property value</li></ol><h2 id="还是跟着代码看看吧"><a href="#还是跟着代码看看吧" class="headerlink" title="还是跟着代码看看吧"></a>还是跟着代码看看吧</h2><p>先看看上面使用的使用到的 beginDelayedTransition()</p><blockquote><blockquote><p>感觉注释写得很好了</p></blockquote></blockquote><p>方法名为意思为 启动一个延迟的切换， 为什么时延迟的呢？ 这个切换并没有马上执行，因为一个新的scene还没有确定呢。而这个新的scene的创建过程也很有意思，它是依据下一帧与当前帧的“变化“确定的，而且它关注的只有参数中sceneRoot的ViewGroup节点下View的变化哦。本来下一帧要确定好准备绘制的，但是遇到存在Transition未执行，会将其执行玩才真正绘制最终的下一帧。</p><p>换个说法，current frame &gt;&gt; next frame 之间，提取出 change in sceneRoot, 为这些 change 执行参数中的transition,即执行动画。本质上，就是本来要绘制下一帧nextFrame的，发现有transition,则nextFrame要延后，在currentFrame与nextFrame之间插入一系列的frame，而这些frame由transition来确定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beginDelayedTransition</span><span class="params">(@NonNull <span class="keyword">final</span> ViewGroup sceneRoot, @Nullable Transition transition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预备的执行的Transitions集合添加该某个View作为sceneRoot,</span></span><br><span class="line">    <span class="comment">// 限制了view只能能添加一次</span></span><br><span class="line">    <span class="keyword">if</span> (!sPendingTransitions.contains(sceneRoot) &amp;&amp; ViewCompat.isLaidOut(sceneRoot)) &#123;</span><br><span class="line">        sPendingTransitions.add(sceneRoot);</span><br><span class="line">        <span class="keyword">if</span> (transition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            transition = sDefaultTransition;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Transition transitionClone = transition.clone();</span><br><span class="line">        <span class="comment">// 停止当前运行的动画，记录当前帧的属性值、给scene机会执行一个可能需要exitAction</span></span><br><span class="line">        sceneChangeSetup(sceneRoot, transitionClone);</span><br><span class="line">        <span class="comment">// 将当前sense设为空，即达到退出的效果</span></span><br><span class="line">        Scene.setCurrentScene(sceneRoot, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 当scene变化时执行Transition，看看怎么监听sense变化的</span></span><br><span class="line">        sceneChangeRunTransition(sceneRoot, transitionClone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sceneChangeRunTransition</span><span class="params">(<span class="keyword">final</span> ViewGroup sceneRoot, <span class="keyword">final</span> Transition transition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (transition != <span class="keyword">null</span> &amp;&amp; sceneRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        MultiListener listener = <span class="keyword">new</span> MultiListener(transition, sceneRoot);</span><br><span class="line">        <span class="comment">// 为View sceneRoot 添加attach、preDraw 状态的监听</span></span><br><span class="line">        sceneRoot.addOnAttachStateChangeListener(listener);</span><br><span class="line">        sceneRoot.getViewTreeObserver().addOnPreDrawListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当该View的脱离Window时先执行动画</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        removeListeners();</span><br><span class="line"></span><br><span class="line">        sPendingTransitions.remove(mSceneRoot);</span><br><span class="line">        ArrayList&lt;Transition&gt; runningTransitions = getRunningTransitions().get(mSceneRoot);</span><br><span class="line">        <span class="keyword">if</span> (runningTransitions != <span class="keyword">null</span> &amp;&amp; runningTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Transition runningTransition : runningTransitions) &#123;</span><br><span class="line">                runningTransition.resume(mSceneRoot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mTransition.clearValues(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此刻，视图树上所有的View都已经测量，放置好位置，只是没有绘制</span></span><br><span class="line">    <span class="comment">// 在这个时间点，用户可以选择是否满意当前的布局，return true绘制当前帧， return false可以取消当前帧的绘制，</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        removeListeners();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意只是在第一次nextFrame操作，后续动画播放过程中的onPreDraw就不会处理了</span></span><br><span class="line">    <span class="comment">// Don't start the transition if it's no longer pending.</span></span><br><span class="line">        <span class="keyword">if</span> (!sPendingTransitions.remove(mSceneRoot)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add to running list, handle end to remove it</span></span><br><span class="line">        <span class="keyword">final</span> ArrayMap&lt;ViewGroup, ArrayList&lt;Transition&gt;&gt; runningTransitions =</span><br><span class="line">                getRunningTransitions();</span><br><span class="line">        ArrayList&lt;Transition&gt; currentTransitions = runningTransitions.get(mSceneRoot);</span><br><span class="line">        ArrayList&lt;Transition&gt; previousRunningTransitions = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentTransitions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentTransitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            runningTransitions.put(mSceneRoot, currentTransitions);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            previousRunningTransitions = <span class="keyword">new</span> ArrayList&lt;&gt;(currentTransitions);</span><br><span class="line">        &#125;</span><br><span class="line">        currentTransitions.add(mTransition);</span><br><span class="line">        mTransition.addListener(<span class="keyword">new</span> TransitionListenerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTransitionEnd</span><span class="params">(@NonNull Transition transition)</span> </span>&#123;</span><br><span class="line">                ArrayList&lt;Transition&gt; currentTransitions = runningTransitions.get(mSceneRoot);</span><br><span class="line">                currentTransitions.remove(transition);</span><br><span class="line">                transition.removeListener(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mTransition.captureValues(mSceneRoot, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (previousRunningTransitions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Transition runningTransition : previousRunningTransitions) &#123;</span><br><span class="line">                runningTransition.resume(mSceneRoot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 播放Transition,其实是 create animators and run </span></span><br><span class="line">        mTransition.playTransition(mSceneRoot);</span><br><span class="line">                <span class="comment">// 适应 对比前后，创建很多animator</span></span><br><span class="line">            &gt;&gt;  createAnimators(sceneRoot, mStartValues, mEndValues, mStartValuesList, mEndValuesList);</span><br><span class="line">            &gt;&gt;  runAnimators();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="那启动一个Activity是如何执行Transition呢？"><a href="#那启动一个Activity是如何执行Transition呢？" class="headerlink" title="那启动一个Activity是如何执行Transition呢？"></a>那启动一个Activity是如何执行Transition呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// options 不为空，默认不传也会获取主题默认的，不过需要当前Window支持 Window.FEATURE_ACTIVITY_TRANSITIONS</span><br><span class="line">startActivityForResult(intent, -1, options);</span><br><span class="line">// 取消输入开始退出</span><br><span class="line">&gt;&gt; cancelInputsAndStartExitTransition</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">public void startExitOutTransition(Activity activity, Bundle options) &#123;</span><br><span class="line">    mEnterTransitionCoordinator = null;</span><br><span class="line">    if (!activity.getWindow().hasFeature(Window.FEATURE_ACTIVITY_TRANSITIONS) ||</span><br><span class="line">            mExitTransitionCoordinators == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityOptions activityOptions = new ActivityOptions(options);</span><br><span class="line">    if (activityOptions.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class="line">        int key = activityOptions.getExitCoordinatorKey();</span><br><span class="line">        int index = mExitTransitionCoordinators.indexOfKey(key);</span><br><span class="line">        if (index &gt;= 0) &#123;</span><br><span class="line">            mCalledExitCoordinator = mExitTransitionCoordinators.valueAt(index).get();</span><br><span class="line">            mExitTransitionCoordinators.removeAt(index);</span><br><span class="line">            if (mCalledExitCoordinator != null) &#123;</span><br><span class="line">                mExitingFrom = mCalledExitCoordinator.getAcceptedNames();</span><br><span class="line">                mExitingTo = mCalledExitCoordinator.getMappedNames();</span><br><span class="line">                mExitingToView = mCalledExitCoordinator.copyMappedViews();</span><br><span class="line">                mCalledExitCoordinator.startExit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void startExit() &#123;</span><br><span class="line">    if (!mIsExitStarted) &#123;</span><br><span class="line">        backgroundAnimatorComplete();</span><br><span class="line">        mIsExitStarted = true;</span><br><span class="line">        pauseInput();</span><br><span class="line">        ViewGroup decorView = getDecor();</span><br><span class="line">        if (decorView != null) &#123;</span><br><span class="line">           // 禁止 layout乱入，layout也会导致 draw，而我们依赖着 draw前的时间点创建animator</span><br><span class="line">            decorView.suppressLayout(true);</span><br><span class="line">        &#125;</span><br><span class="line">        // 这个将共享元素移动到OverLay层，最高层哦</span><br><span class="line">        moveSharedElementsToOverlay();</span><br><span class="line">        startTransition(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if (mActivity != null) &#123;</span><br><span class="line">                    beginTransitions();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    startExitTransition();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void startExitTransition() &#123;</span><br><span class="line">    Transition transition = getExitTransition();</span><br><span class="line">    ViewGroup decorView = getDecor();</span><br><span class="line">    if (transition != null &amp;&amp; decorView != null &amp;&amp; mTransitioningViews != null) &#123;</span><br><span class="line">        setTransitioningViewsVisiblity(View.VISIBLE, false);</span><br><span class="line">        TransitionManager.beginDelayedTransition(decorView, transition);</span><br><span class="line">        setTransitioningViewsVisiblity(View.INVISIBLE, false);</span><br><span class="line">        // 请求重绘，正好对应上了，onPreDraw</span><br><span class="line">        // 否则没机会执行transition</span><br><span class="line">        decorView.invalidate();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        transitionStarted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>协程笔记</title>
      <link href="/2021/04/15/%E5%8D%8F%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/04/15/%E5%8D%8F%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>协程在安卓中，用来处理即时任务，相对于那些延迟任务，使用Worker来处理。</p><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>协程中的Job描述一个后台进行的任务，可以手动取消，感知自己的作用域；</p><p>Jobs 工作链之间可以构成父子关系，这样，会导致，当父节点取消时，同时会递归地取消子节点。当子节点异常结束时，也会到导致父节点立刻去结束。这些，父子之间的行为可以通过<code>SupervisorJob</code>来解决</p><p>Job实例创建的常见形式如下：</p><ul><li>直接使用 launch的协程构造器，</li><li>使用CompleteJob的工厂方法，当任务结束时会回调complete()方法</li></ul><p>概念上，Job也不产生结果，只有方法调用的副作用，关注结果的Job可以用其子类 <code>Defferd</code>   </p><h3 id="Job-states"><a href="#Job-states" class="headerlink" title="Job states"></a>Job states</h3><p>Job的状态由三个变量构成，isActive, isCompleted, isCanceled, 通过不同组合，可以形成不同的状态，000表示刚创建出来100表示进入激活状态010表示完美结束了代码块001表示正在取消，cancelling011表示已取消,cancelled这里，通常创建后就会进入active状态，不过也可以创建时指定Coroutine.Lazy，延迟激活，通过start/join方法启动一个激活的协程会一直运行，下一个状态可能是代码执行完毕，complete，或执行失败，抛异常，或被取消</p><p>抛异常会导致进入cancelling状态，Job可以调用cancel方法立刻进入cancelling状态，不过若是作为父节点，也要得子节点完成。</p><p>完成一个协议，也可以调用它的complete方法，也会等到子协程完成再完成。注意到，completing状态只是内部状态，并不对外公开，再完成子协程前，在外面观察者看到，当前协程还是active状态。</p><h3 id="Cancellation-cause"><a href="#Cancellation-cause" class="headerlink" title="Cancellation cause"></a>Cancellation cause</h3><p>协程可以当出现异常时进入canceled状态。当子节点出现异常取消时，也会导致父节点取消。实现方式上，是通过抛异常来让让协程进入到cancelled状态的。正常取消和异常取消区别于抛出的异常类型，正常取消抛出 <code>CancellationException</code>,其他类型异常则视为属于异常退出了。有趣的是，这个异常是Java基础库一致的。</p><h3 id="线程安全保证"><a href="#线程安全保证" class="headerlink" title="线程安全保证"></a>线程安全保证</h3><h3 id="实现类都是不稳定"><a href="#实现类都是不稳定" class="headerlink" title="实现类都是不稳定"></a>实现类都是不稳定</h3><p>指的是 JopSupport吧，</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kotin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题中对一些算法思想的理解</title>
      <link href="/2021/03/31/%E5%88%B7%E9%A2%98%E4%B8%AD%E5%AF%B9%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2021/03/31/%E5%88%B7%E9%A2%98%E4%B8%AD%E5%AF%B9%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>刷题过程中，对一些大家熟知的概念有了自己的体会，这是一个满足的体验啊。比如，理解一些思路为何能上升为”思想”，如分治思想。</p><p>以排序的快排、归并为例，最开始我们了解它们一般都是先接触它们的思路，   </p><h3 id="快排的思路"><a href="#快排的思路" class="headerlink" title="快排的思路"></a>快排的思路</h3><p>在一个序列中选择一个数为中轴 <code>pivot</code>，将小于等于中轴数的放到左边，大于它的放在右边；<br>不断对左边和右边的子序列作以上操作。</p><h3 id="归并思路"><a href="#归并思路" class="headerlink" title="归并思路"></a>归并思路</h3><p>排序一个序列，先不断的划分为两部分别排序，再将左右两边的有序序列合并；不断对左右两边分别以上操作。</p><p>从归并再反思快排，我们发现，归并比快排要”懒”一些啊~    </p><p>快排一次划分将序列分成了三部分，且将三者排好序，而归并一次划分仅将序列分为两部分，两者没有急着排序，而是优哉游哉将排序放到不可划分之后。  </p><p>快排像一个勤奋或急功近利的年轻人，每次操作，便急着将中轴数放到最终的位置，付出的”比较汗水”很多，每个数会比较n-1次；  </p><p>归并像一个深谋远虑的老者，不急不躁，将比较的操作放到”合并”流程中，使得每次”比较”的结果都能给后面的”比较”助力，为什么这么说呢？<br>比如合并 [1,3,5] 与[2,4,6]，左边的1与右边2比较后，发现1比2小，且右边是递增的有序序列，故1也一定比2之后的数据小，也就是无需再与2之后的数比较，那么至少省了2次比较呀。  </p><p>而且啊，基于快排”排序不稳定”，归并”排序稳定”，它们年轻人、老者的形象似乎更加立体了。  </p><p>在不同的场景下，它们各有千秋，在现实的世界中，无疑还是年轻人干活的场景更多一点呀。  </p><p>在啰嗦完它们不同点之后，我们来找它们的共同点，为何他俩能在众多排序算法中更加惹人注目呢？ 我想，它俩相比与一些暴力蛮干的排序相比，它俩都散发着”分治”智慧。遇到”排列好一堆数”的复杂问题，能寻见其间的共通，将复杂问题化为共通部分的叠加子问题，求解简单的子问题，便能可求得原问题之解。</p><p>具体上，再看上面提及的两个排序思路，都是”分治思想”应用，仅是划分角度的不同。<br>快排，将问题化为，排序一个数和两个子序列简单子问题，排序一个数与两个序列可省力多了，毕竟只要花O(n)；<br>归并，似乎”分为治之”更为明显，遇到问题，若非问题规模为1，即1个数无需排序，否则统统将问题规模减半，令人惊艳的在于，合并的过程中，子问题的答案能够为父问题求解提供帮助，从而在整体求解上起飞。  </p><p>分而治之，基于问题本就由一个个子问题构成的客观事实，拆解问题便是我们认识世界的过程，可以说，分而治之是我们与生俱来解决问题思路。</p><p>另外，若能将问题拆分后，若子问题之间不依赖，并发执行，也是可以提高效率吧。</p><p>前天遇到了一道题，<a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">颠倒二进制</a>, 引出上文~</p>]]></content>
      
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fragment Transactions &amp; Activity State Loss (译)</title>
      <link href="/2021/03/05/Fragment-Transactions-Activity-State-Loss-%E8%AF%91/"/>
      <url>/2021/03/05/Fragment-Transactions-Activity-State-Loss-%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html" target="_blank" rel="noopener">原文</a></p></blockquote><h1 id="Fragment-Transactions-和-Activity-状态丢失"><a href="#Fragment-Transactions-和-Activity-状态丢失" class="headerlink" title="Fragment Transactions 和 Activity 状态丢失"></a>Fragment Transactions 和 Activity 状态丢失</h1><p>自Android3.0后，以下报错信息在StackOverflow困扰众人许久了</p><blockquote><p>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceStateat android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341)at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352)at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)</p></blockquote><p>本文将要解释该异常为什么会出现，以及何时会出现，随便给出几个建议来处理该问题。</p><h2 id="该异常为什么会发生？"><a href="#该异常为什么会发生？" class="headerlink" title="该异常为什么会发生？"></a>该异常为什么会发生？</h2><p>该异常抛出的原因是，在Activity状态已经保存后仍试图提交一个FragmentTransaction，其导致了一个现象被称之为状态丢失。在探究其中的各种细节之前，我们先来看看<code>onSaveInstanceState()</code>方法调用时发生了什么。正如在我的上一篇文章<a href="https://www.androiddesignpatterns.com/2013/08/binders-death-recipients.html" target="_blank" rel="noopener">Binders &amp; Death Recipients</a> 所说,在Android的运行环境中，App对自己的命运掌控甚少。Android系统在内存不足的情况下可以在杀死任意进程，导致后台Activity在未收到任何通知下被杀掉。为了避免用户察觉的到这种不稳定的问题（切换到后台的App，被杀或不被杀，当切回到前台时表现会不一样；不被杀，数据正常，被杀掉了，数据跟关闭前的不一样），在Activity可能被销毁的情况下，系统给给了它一个机会，能使用<code>onSaveInstanceState()</code>方法先来保存好当前的状态。当App由后台切换到前台时，恢复之前保存的状态，这样，无论App是否被杀与否，用户体验都是一样的。</p><p>当系统回调<code>onSaveInstanceState()</code>方法时，它将一个<code>Bundle</code>对象传给Activity用于保存Dialog,Fragment,Views的状态，在该方法返回后，系统序列化该Bundle数据（通过parcel序列化）通过Binder传给系统服务进程（System Server process）,使其能安全保存着。之后当系统重建创建Activity时，又将该Bundle传回给应用使其恢复原来的状态。</p><p>那为什么该异常会抛出呢？该问题源自于该Bundle数据代表Activity在调用<code>onSaveInstance()</code>这一时刻的快照，这意味着在<code>onSaveInstance()</code>之后调用<code>FragemntTransaction#commit()</code>，这个transaction将不会被保存。而从用户的角度上看，会导致UI的数据混乱。为了保证用户体验，Android只好抛异常来避免状态丢失了（默认数据正确性优先）。</p><h2 id="何时该异常会抛出？"><a href="#何时该异常会抛出？" class="headerlink" title="何时该异常会抛出？"></a>何时该异常会抛出？</h2><p>假如你之前遇到该异常，你可能会注意到该异常抛出的时间点在不同Android版本上会有所不同。比如，你可能注意到在老设备上更容易抛出该异常，或是当使用支持库（android.support.Fragment）而非官方库(android.app.Fragment)时你的应用可能更容易崩溃。这些细小的不一致行为导致很多人认为支持库是存在bug而不能被信任，而这些观点，通常是错误的。</p><p>这些不一致行为，原因是在在Android3.0之后，Activity的生命周期方法发生了一些重大改变。3.0之前，Activity是在paused之后就可以被系统认为是”可杀的”，意味着在<code>onPause()</code>方法之前会保证调用<code>onSaveInstance()</code>。而在3.0之后，Activity是要在<code>onStop()</code>后才会被认为是可杀的，也就是会在<code>stoped</code>之前保证保存状态。</p><p>由于Activity生命周期的变化，支持库需要兼容不同的平台版本。比如，该异常会在<code>onSaveInstanceState()</code>方法后执行<code>commit()</code>便会抛出，以此提示开发者状态丢失了。而<code>onSaveInstanceState()</code>调用时机在3.0之前更早一些，也就导致低版本更容易状态丢失。为了能够在支持不同版本，Android团队做了妥协：允许在低版本上Android中，在<code>onPause()</code>和<code>onStop()</code>之间提交commit会导致异常。支持库在不同版本表现如下表格：</p><table><thead><tr><th></th><th align="center">3.0前</th><th align="center">3.0后</th></tr></thead><tbody><tr><td>在 onPause()前 commit()</td><td align="center">OK</td><td align="center">OK</td></tr><tr><td>在 onPause() 和 onStop() 之间commit()</td><td align="center">状态丢失</td><td align="center">OK</td></tr><tr><td>在 onStop() 之后commit()</td><td align="center">Exception</td><td align="center">Exception</td></tr></tbody></table><h2 id="如何避免该异常"><a href="#如何避免该异常" class="headerlink" title="如何避免该异常"></a>如何避免该异常</h2><p>一旦理解状态丢失是如何发生之后，避免该异常就容易多了。若是你在阅读本文之前就理解了，也希望你可以通过本文知道支持库是如何工作的以及为什么App中避免状态丢失如此重要。若是你在搜索一个快速的解决方案而看到本文，这里有几个建议希望能够对你处理FragmentTransaction有帮助。</p><h3 id="在Activity生命周期提交事务（commit-transaction）时需要谨慎"><a href="#在Activity生命周期提交事务（commit-transaction）时需要谨慎" class="headerlink" title="在Activity生命周期提交事务（commit transaction）时需要谨慎"></a>在Activity生命周期提交事务（commit transaction）时需要谨慎</h3><p>大部分应用只会在onCreate()方法中或是响应用户操作时才会提交事务，这不会出现什么问题。然而，在其它的生命周期方法中提交事务时，事情就会变得复杂了，比如<code>onActivityResult()</code>,<code>onStart()</code>,<code>onResume()</code>. 比如，你不应该在<code>onResume()</code>方法中提交事务，因为有可能此时Activity的状态没有恢复原来保存的状态（restored）,详见<a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onResume()" target="_blank" rel="noopener">文档</a>,</p><blockquote><p>文档内容（译者加）：</p><ul><li>Activity#onResume()<br>分发 onResume() 方法给Fragment。注意，为了更好的兼容低版本平台，该activity中attached Fragment并没有进入resumed。这意味着Activity原来保存的状态（若是以前保存有）没有恢复（原来的状态还是在bundle中，而非在当前state中），当前是不允许提交事务修改状态的，你应该在<code>onResumeFragments()</code>方法中提交事务修改。</li></ul></blockquote><p>如果你需要在onCreate()之外的生命周期中提交事务，应该在<code>FragmentActivity#onResumeFragemnts()</code>或<code>Activity#onPostResume()</code>。这两个方法保证原来的状态已经正确的恢复，因此可以避免状态丢失的可能性。（若是想要在<code>Activity#onActivityResult()</code>方法中提交事务，可以参看我的StackOverFlow中的<a href="https://stackoverflow.com/questions/16265733/failure-delivering-result-onactivityforresult" target="_blank" rel="noopener">回答</a> ）</p><h3 id="避免在异步的回调方法中提交事务"><a href="#避免在异步的回调方法中提交事务" class="headerlink" title="避免在异步的回调方法中提交事务"></a>避免在异步的回调方法中提交事务</h3><p>常见的异步回调方法，比如 <code>AsyncTask#onPoastExecute()</code>和<code>LoadManager.LoaderCallback#onLoadFinished()</code>，当在这些方法提交事务时，我们并不知道当前Activity所处的状态。如下展示异常出现的过程。</p><ol><li>Activity中开始执行一个<code>AsyncTask</code></li><li>用户点击Home键，导致Activity的<code>onSaveStateInstance()</code>和<code>onStop()</code>执行</li><li><code>AsyncTask</code>任务完成执行<code>onPostExecutes()</code>,并不意识到Activity已经 stopped</li><li>在<code>onPostExecutes()</code>中提交事务，导致异常抛出</li></ol><p>通常来说，最好不在异步回调中提交事务。谷歌工程师认同这一原则，在Android开发团队的一篇<a href="https://groups.google.com/d/msg/android-developers/dXZZjhRjkMk/QybqCW5ukDwJ" target="_blank" rel="noopener">文章</a> 中，认为在异步回调中执行提交事务会使得界面突然切换，这会造成糟糕的用户体验。若是你的App一定要在异步回调中提交事务，并没有容易的方法来保证提交事务在保存状态前执行，你可能需要使用<code>commitAllowStateLoss()</code>，但这需要自己处理状态能会丢失的情况。(StackOverFlow有两篇帖子可以参考，<a href="https://stackoverflow.com/questions/8040280/how-to-handle-handler-messages-when-activity-fragment-is-paused" target="_blank" rel="noopener">帖子1</a><a href="https://stackoverflow.com/questions/7992496/how-to-handle-asynctask-onpostexecute-when-paused-to-avoid-illegalstateexception" target="_blank" rel="noopener">帖子2</a>）</p><h3 id="使用commitAllowStateLoss-应当作为最后选项"><a href="#使用commitAllowStateLoss-应当作为最后选项" class="headerlink" title="使用commitAllowStateLoss 应当作为最后选项"></a>使用commitAllowStateLoss 应当作为最后选项</h3><p><code>commit()</code>和<code>commitAllowStateLoss()</code>两者唯一区别在于后者在状态状态可能丢失时，不会抛异常。通常你也不该使用该方法，因为这意味这要承受状态丢失的可能。最好的解决方案当然是保证commit在保存状态前执行，这保证了良好的用户体验。除非状态丢失无法避免，否则<code>commitAllowStateLoss</code>不该使用。</p><p>希望这些建议能够解决你遇到的问题。若是你仍遇到问题，在StackOverFlow提交问题并在下面评论区留下链接，我会帮忙看看滴。</p><p>总之，感谢你的阅读。若是有问题欢迎评论，别忘了点赞分享~</p><blockquote><p>上次更新于2014-1-8<br>译者翻译于2021-3-5，哭了~，陈年好文啊</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素的思路-俄罗斯套娃</title>
      <link href="/2021/03/05/%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%80%9D%E8%B7%AF-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/"/>
      <url>/2021/03/05/%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%80%9D%E8%B7%AF-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/</url>
      
        <content type="html"><![CDATA[<h2 id="题意提取"><a href="#题意提取" class="headerlink" title="题意提取"></a>题意提取</h2><p>信封有两属性，宽（w），高（h）;<br>信封a套入信封b的要求:w[a] &lt; w[b] &amp;&amp; h[a] &lt; h[b]</p><p>求，在一堆信封中，最多能有多少个个信封可以套在一起？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="基于生活经验的朴素思路："><a href="#基于生活经验的朴素思路：" class="headerlink" title="基于生活经验的朴素思路："></a>基于生活经验的朴素思路：</h3><p>既然想要套更多的信封，那么先找最小的信封出来，准没错，找出宽高最小的信封a。</p><p>然后，再选一个 “最贴近a，又比a大” 的信封。重复该步骤，积累的信封个数就是题目所求了。</p><p>写代码时，排序，按宽优先升序排序,这样，a的下一个信封，就是“最贴近a，又比a大”的信封。</p><p>结果发现，像这样（排序后）的用例是没问题的。</p><blockquote><p>[1,1], [2,3], [3,4]</p></blockquote><p>但是，如下的用例就出现问题了 </p><blockquote><p>[1,7], [2,3], [3,4]</p></blockquote><p>按照写法，我们会直接选择，[1,7]，之后的信封都不能继续套入，故结果为1，而更优的选择为选后两个信封，结果为2。</p><p>问题出在哪里了呢？</p><p>我们平白无故的添加一个比较条件，按<code>宽</code>优先排序，比如 [1,7] &lt; [2,3]，我<code>宽</code>小于你，可我<code>高</code>大于你，凭啥我就低你一等呢？</p><p>原来，信封[1,7]，[2,3] 之间并没有所谓的大小关系，故我们朴素思路问题出现在了这里。</p><blockquote><p>感慨，生活中很多时候，自己遇到比较复杂的问题时，会想当然的添加某些条件，使其合理化。比如，为啥自己工作那么久还在小公司颠簸，安慰自己说，进大厂的人毕竟是少数，自己是野鸡大学的嘛。而这问题出现在哪呢？</p></blockquote><p>回归本题，我们添加这个“按宽优先升序”条件后，虽然不能直接用朴素的思路来解决，但似乎有点用到，如，比信封i大的信封一定在其后面了，故基于此继续思考。</p><p>面对排序好的信封 envelopes，如何选择第一封信封呢？如</p><blockquote><p>[1,7], [2,3], [3,4] </p></blockquote><p>我们选择了[2,3]作为第一个信封，因为选择它之后，我们可以再套一个[3,4]，而其它两个信封着都没有这样的“额外好处”，或者说其他两信封给的“额外好处”为0，可以说，我们是根据它们给的“好处值”的大小来做出选择的，我们定义每个信封的好处值<code>goods[i]</code>为，选择它之后最终可以有多少个信封。如以上用例的好处值分别为：</p><blockquote><p>1, 2, 1</p></blockquote><p>那么我们问题所求 ans = maxOf(goods[0], goods[1]… goods[n-1])</p><p>我们试图分别求每个goods[i]值，让人难以理解的一点是，求goods[i]似乎是跟求原问题是类似的…</p><p>发现求goods[i] 依赖后面信封的好处值和大小，而求最后一个信封的好处值是最容易的，必须等于1.</p><p>goods[n-1] = 1 </p><p>goods[k] = 在后面的信封中，选择比envelopes[k]大的集合中选择好处值最大的 good+1</p><blockquote><p>啊，发现描述起来好难~</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = envelopes.length;</span><br><span class="line">        <span class="comment">// 将信封按宽优先升序排序</span></span><br><span class="line">        Arrays.sort(envelopes, (o1, o2) -&gt; o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? Integer.compare(o1[<span class="number">1</span>], o2[<span class="number">1</span>]) : Integer.compare(o1[<span class="number">0</span>], o2[<span class="number">0</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] goods = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        goods[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> good = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[j][<span class="number">0</span>] &gt; envelopes[i][<span class="number">0</span>]) &#123;   <span class="comment">// 比较宽</span></span><br><span class="line">                    <span class="keyword">if</span> (envelopes[j][<span class="number">1</span>] &gt; envelopes[i][<span class="number">1</span>]) &#123;    <span class="comment">// 比较高</span></span><br><span class="line">                        good = Math.max(good, goods[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;   <span class="comment">// 寻找比信封i大的信封，信封j不可能时，前面的信封宽更小，</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            goods[i] = good + <span class="number">1</span>;</span><br><span class="line">            res = Math.max(res, good);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Single Activity design (译)</title>
      <link href="/2021/02/26/Android-Single-Activity-design-%E8%AF%91/"/>
      <url>/2021/02/26/Android-Single-Activity-design-%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="(https://proandroiddev.com/part-3-single-activity-architecture-514791724172)">原文</a></p></blockquote><h1 id="Android-单一Activity设计思路"><a href="#Android-单一Activity设计思路" class="headerlink" title="Android: 单一Activity设计思路"></a>Android: 单一Activity设计思路</h1><p>在19年Google I/O Talk上，单一Activity设计原则伴随着 Jetpack Navigation 被提及，现在Google更推荐<code>单一Activity</code>设计作为首选架构。</p><blockquote><p>我们又有造新名词了吗？”SAAs(Single Activity Applications)” 关于”单一Activity”，这个设计思路，即使Android开发圈子也并不是新鲜事物。</p></blockquote><p>单一Activity设计，可以类比web开发中<code>单页面应用</code>,<code>单页面应用</code>设计思路在现代web开发框架中非常流行。</p><p>本文我们将讨论以下几点：</p><ul><li><code>单一Activity</code>设计解决了什么问题？</li><li>何时该采用<code>单一Activity</code>设计?</li><li>对于现有的项目我们能做什么？</li></ul><p>在讨论这几点之前，先简单介绍下Activity和Fragment  </p><h2 id="Activity是什么？"><a href="#Activity是什么？" class="headerlink" title="Activity是什么？"></a>Activity是什么？</h2><p>Activity作为Android应用的入口，显然在任何一个应用中至少需要一个Activity。</p><blockquote><p>Activity作为四大组件之一，聚焦于一点，描述用户能做什么。几乎所有的Activity都与用户交互，故<code>Activity</code>类负责创建<code>Widnow</code>展示内容给用户，通过<code>setContentView(View)</code>方法我们可以放置所要展示的内容。尽管<code>Activity</code>通常用来展示全屏页面，但是也是可以用于其他方式…</p><p>摘自官方文档 <a href="https://developer.android.com/reference/android/app/Activity" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/Activity</a></p></blockquote><h2 id="使用Activity有什么问题？"><a href="#使用Activity有什么问题？" class="headerlink" title="使用Activity有什么问题？"></a>使用Activity有什么问题？</h2><p>嗯…并没有出现多大的问题，以致你一定要使用单一Activity设计。  </p><p>而且，Android设计的理念，一个页面对应了一个Activity。至少，在引入Fragment之前是这样的，这种理念从Android诞生之后就一直被这么采用。</p><h2 id="Fragment是什么？"><a href="#Fragment是什么？" class="headerlink" title="Fragment是什么？"></a>Fragment是什么？</h2><blockquote><p>Fragment能替代Activity，因为Activity能做的，Fragment也能做。</p></blockquote><p>引入Fragment主要的目的，是让我们描述UI的代码可以复用，支持动态灵活的UI设计，因为Activity之间不能嵌套。（LocalActivityManager已经永远地被遗弃了）。</p><p>Fragment的APIs推出后已经改进很多了。最初，Fragment只是拥有与Activity相似的生命周期，如今，Fragment已经支持自己<code>后退栈</code>，并使用FragmentManager来管理。</p><p>在以下场景中，Fragment显得非常强大:</p><ul><li>支持多屏适配</li><li>使用ViewPager，这要求一定要使用Fragment</li><li>创建一个包含UI库，暴露一个Fragment而不是一个Activity意义就大很多了</li></ul><h2 id="Fragment存在什么问题"><a href="#Fragment存在什么问题" class="headerlink" title="Fragment存在什么问题?"></a>Fragment存在什么问题?</h2><p>Fragment曾存在很多问题，但随着Jetpack架构架构组件的引入，特别是<code>ViewModel</code>和<code>LiveData</code>的引入，很多问题都得到了解决。</p><p>实际上，抛开view-base框架，我们也毫无选择而必须使用Fragment。</p><blockquote><p>在本文，我不会去讨论其他避免使用Fragment的方法，比如：<a href="https://github.com/bluelinelabs/Conductor" target="_blank" rel="noopener">Conductor</a></p></blockquote><p>Fragment有一个优势：它现在不是Android框架的一部分，而是存在于Jetpack中。这样，很容易利于Android团队修复问题和添加新特性。</p><p>因此，对于我们自己的app，若是想要展示UI，我们必须声明一个Activity作为入口，但对于实现其他页面，我们可以存在很多方案。</p><h2 id="方案1：每一个页面作为独立的Activity"><a href="#方案1：每一个页面作为独立的Activity" class="headerlink" title="方案1：每一个页面作为独立的Activity"></a>方案1：每一个页面作为独立的Activity</h2><p>就如同Fragment未曾出现过一样。</p><p>比如，我们设计一个”购物”流程。我们可能会需要三个页面，购物清单清点页面，购物车详情页面，支付页面。这样就会有三个Activity需要被创建：</p><ol><li>OrderListReviewActivity</li><li>ShippingDetailActivity</li><li>PaymentActivity</li></ol><h2 id="方案2：每一个流程（模块）独立为一个Activity"><a href="#方案2：每一个流程（模块）独立为一个Activity" class="headerlink" title="方案2：每一个流程（模块）独立为一个Activity"></a>方案2：每一个流程（模块）独立为一个Activity</h2><p>App中每个模块独立为一个Activity，模块中的子页面使用Fragment来实现。</p><p>如此，将会有下列需实现：</p><ol><li>CheckoutActivity</li><li>OrderListReviewFragment</li><li>ShippingDetailFragment</li><li>PaymentFragment</li></ol><h2 id="方案3：单一Activity"><a href="#方案3：单一Activity" class="headerlink" title="方案3：单一Activity"></a>方案3：单一Activity</h2><p>将只有一个Activity作为应用入口，所有的页面使用Fragment实现，这个Activity作为宿主负责存放和管理Fragment。</p><p>给个例子，当前流程跨平台框架都在使用该方案，比如 Xamarin, Ionic, Flutter, Reactive Native, 它们表现都很好。</p><p>通常，我看到的情况是，开始会选择方案1，只用Activity，慢慢地Fragment被引入，绝大数是因为：</p><ol><li>需要支持手机和平板</li><li>需要复用UI</li><li>需要使用ViewPager，这个强制使用Fragment</li><li>使用了一些第三方库，其使用了Fragment作为暴露UI的方式，如:Google Maps</li></ol><p>理论上，我们可能处于方案1和方案2之间，而方案2切换到单一Activity设计差别不大。</p><h2 id="单一Activity设计解决了什么问题？"><a href="#单一Activity设计解决了什么问题？" class="headerlink" title="单一Activity设计解决了什么问题？"></a>单一Activity设计解决了什么问题？</h2><h3 id="1-不同版本Activity表现不一致"><a href="#1-不同版本Activity表现不一致" class="headerlink" title="1. 不同版本Activity表现不一致"></a>1. 不同版本Activity表现不一致</h3><p>Activity作为Android框架一部分，其行为和支持特性绑定了Android版本。添加的新特性和修复的bug并不能保证在低版本系统中可用。或许，你可能选择兼容库如 ActivityCompat,ActivityOptionCompat等来解决那些边角问题，但这很痛苦。</p><p>多个Activity不仅增加了开发时间，也增加了测试时间。表现不一致的问题，也同样存在于不同设备和不同版本。</p><p>###2. 在Activity功能共享数据</p><p>在Activity之间，想要共享数据，只能将该数据放在Application级别作用域中。然而，在该作用域中，其他的Android组件也能获取到了，如Service，BroadcastReceiver,ContentProvider.</p><p>理想中，应该存在一个独立的作用域，用于存放几个页面共享的的数据，最好是在Activity级别的。</p><p>###3. 糟糕的用户体验</p><p>当切换Activity时，整个窗口都会被替换。因而，Toolbar/ActionBar也将会替换。我个人认为，Toolbar不应该被替换，而是应该更新相关的内容即可。如同桌面应用一样，Toolbar永远不变，变的仅有下面的内容。</p><p>而且，由于不同版本的Activity表示不一致，其场景切换动画也会在不同设备不同版本表现不一致。</p><p>###4. 开发体验</p><p>当使用多个Activity时: </p><ul><li><p>每添加一个页面都要同步添加该Activity到Manifest文件中，仔细想想是不是有点奇怪。</p></li><li><p>某个控制功能需要在多个页面都需要实现时，将会耗费额外的精力。比如NavigationDrawer，底部栏，通用的菜单栏。</p></li><li><p>检测应用是否正在运行将变得困难，会发现在同一个时间，会有多个Activity在栈中。</p></li></ul><p>单一Activity设计看来是一个很好的架构设计。但，直到现在，这样的架构缺少相关的框架，实现是困难的。目前存在一些支持单一Activity的框架比如Conductor和Scoop,但它们不支持Fragment。</p><p>随着Navigation组件的引入，现在已经很容易实现单一Activity的架构了。</p><h2 id="什么时候该采用单一Activity设计"><a href="#什么时候该采用单一Activity设计" class="headerlink" title="什么时候该采用单一Activity设计"></a>什么时候该采用单一Activity设计</h2><p>采用单一Activity设计遇到的问题，Navigation组件已经为我们解决大部分了，所以，若是你现在开始新的项目，你应该毫无疑问的采用该设计。</p><p>Navigation组件提供了容易理解的API，类storyboard（IOS开发）的编辑器和详尽的文档和入门教程。</p><p>Navigation支持以下：</p><ol><li>处理<a href="https://developer.android.com/training/app-links/deep-linking" target="_blank" rel="noopener">deep link</a></li><li>简单可靠的转场动画</li><li>更易用处理Toolbar</li><li>支持动态特性模块</li></ol><h2 id="对于现有的项目我们能做什么？"><a href="#对于现有的项目我们能做什么？" class="headerlink" title="对于现有的项目我们能做什么？"></a>对于现有的项目我们能做什么？</h2><p>理论上，对于那些已经混合了Activity和Fragment的现有项目，逐渐迭代到单一Activity设计是有意义的。开始，可以选择一个小模块进行单一Activity多Fragment切换。  </p><p>若是有人拥有迭代现有项目到单一Activity设计的经验，我原意与之一起讨论其中的细节。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单一Activity设计不是新鲜的概念了</li><li>诸如Conductor和Scoop基于View-based实现单一Activity的框架不支持Fragment</li><li>在Navigation推出之前，使用Fragment实现单一Activity设计不划算</li><li>Navigation组件可实现基于Fragment的单一Activity</li><li>对于新项目，应该毫无疑问使用单一Activity设计了</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>失效的技巧</title>
      <link href="/2021/02/20/%E5%A4%B1%E6%95%88%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
      <url>/2021/02/20/%E5%A4%B1%E6%95%88%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>开工了，2021年~</p><p>过年在V站看到一个帖子<a href="https://www.v2ex.com/t/753483" target="_blank" rel="noopener">有些技巧以前很重要，现在越来越没用了</a> ，感慨很多。以前学的很多技巧，用来解决某个问题，而当问题不在之后，这个技巧也就失效了。</p><p>对于失效的技巧，发现大家的反应会分为两种</p><ul><li>感性派（源于技巧的关键字，开始怀念过去）  </li><li>理性派（反思为什么会这样子，如何避免花过多精力于技巧）  </li></ul><h2 id="我想我是感性派"><a href="#我想我是感性派" class="headerlink" title="我想我是感性派"></a>我想我是感性派</h2><p>其中有个人提及的</p><blockquote><p>斯凯 MTK 应用。通过<em>#220807#、</em>#777755999#打开国产山寨手机的 mrp 应用列表入口，可能需要安装 applist.mrp yyrj.mrp dsm_gm.mrp 三个文件，然后把其他 mrp 格式的应用放到对应位置就可以打开了。当年 mrp 软件和游戏还是有很多精品的，可惜现在 mrp 这个关键词都搜不到了。</p></blockquote><p>提及“MTK”、”MRP“、那都是满满的青春回忆~   *#220807# 应用入口命令，再熟悉不过了，看到一个新的山寨机，便会不由自主的按下试试支不支持安装应用。<br>对了，还有一个文件夹名称，“mythroad”，支持安装应用的手机，会在SD卡根目录下生成该文件夹。当时英文不好，只是记着这7个单词，现在回头看，发现这个可以是 “myth road” 神话之路，突然能感受取这个名字的用意了。</p><p>其实，我咋看以为是 “my throat(d)” 我的喉咙，啊，感觉到不对劲，查了下，才发人家的原意，现在的英文也还不行，不过，这提示我们命名要用驼峰或下划线啊~</p><h2 id="假装是理性派"><a href="#假装是理性派" class="headerlink" title="假装是理性派"></a>假装是理性派</h2><p>为什么技巧会失效？</p><p>技巧是是针对某个问题的巧妙方法，是解决问题的方式，问题消失了，我们技巧也就没用了。比如，我怀念的山寨机应用神话之路，当今已经没有山寨机，这种技巧也就没有用武之地了。  </p><p>如何避免技巧会失效？</p><p>避免技巧失效，依据失效的原因，就是要避免问题会消失。而问题会消失吗？有点的会，有的不会，有些技巧会一生有用，比如，沟通时需照顾对方感受时采取换位思考，有的技巧注定会失效，比如记住那个*#220807#应用入口命令。我们凭什么认为换位思考的技巧一生有效？深究起来似乎也站不住脚，假如人与人不需要沟通了呢？去掉假如，我与之沟通的不是人，而是一台机器呢？啊，别抬杠自己了。与人交流这个需求，在我的认知里面永远会存在。</p><p>技巧失效的场景，想到了职业问题，为什么医生会越老越吃香，而程序员老了就没人要了。是不是存在一个原因是，两者工作的对象，人的变化相对机器要少很多，故而，医生掌握的技巧对有效性更久一些。</p><p>我们试图寻求在不变的问题，从而将技巧的有效性延长。我们所遇的问题中，很多问题是相通的，不同的问题是存在相同部分，我们解决的问题选择分治法，将问题拆分，逐一解决，解决子问题时使用掌握的技巧。这样，可以说，技巧是存在延续性的。根据这点，我们能所做的是，平时遇到问题后，三思而行，将问题拆分逐一解决，积累解决通用问题的工具包。</p><p>感觉这种策略是普遍的，大家也都是这么做的。突然想到了数学的一些名词，定义，性质，推论，我们有限的小脑子要掌握哪些东西呢？定义永远是优先掌握的吧，性质用来让我们如何更加立体理解定义，推论用来解决我们的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换了新工作的一些感受</title>
      <link href="/2020/11/05/%E6%8D%A2%E4%BA%86%E6%96%B0%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E5%8F%97/"/>
      <url>/2020/11/05/%E6%8D%A2%E4%BA%86%E6%96%B0%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E5%8F%97/</url>
      
        <content type="html"><![CDATA[<h2 id="移植车载项目的感想"><a href="#移植车载项目的感想" class="headerlink" title="移植车载项目的感想"></a>移植车载项目的感想</h2><p>入职了新公司，接到的第一个任务是移植一个App，名为CAN，好了好多天理解这个项目后，对这个项目的设计很是佩服啊。</p><h3 id="CAN是什么应用？"><a href="#CAN是什么应用？" class="headerlink" title="CAN是什么应用？"></a>CAN是什么应用？</h3><p>CAN作为车载系统的一个应用，给人的印象就是展示<strong>车况</strong>信息的App，展示的信息包括耗油量，车门开关，空调等等，也包括对这些部件的控制。<br>这是我们用户的角度来看到CAN，其实CAN的英文全称是 Controller Area Network ，这是我没想到的啊。百度百科上关于它的解释也挺抽象的，就是说在车载这么小的环境里面，这么多车载的部件是怎么通信的？嗯，为了解决通信问题，诞生了CAN，优点是各个部件都是通过CAN-Bus来发送信息，接收消息，从而避免了物理上要缠绕多个线的问题。</p><p>我的理解他类似系统总线的作用，通过它，各个部件不再直接交互，而是通过总线了间接交互，从而实现排线简单。</p><h3 id="CAN为何惊艳了我？"><a href="#CAN为何惊艳了我？" class="headerlink" title="CAN为何惊艳了我？"></a>CAN为何惊艳了我？</h3><p>我认为一个直接的原因是，之前所做的项目都相对简单了。为何简单？</p><p>做的是常规的互联网项目，所要解决的问题都是一些很通用的问题，在网上会有大家共识的方案。<br>如，如何实现页面加载图片。会涉及到缓存管理，加载图片与宿主生命周期的关联，图片的裁剪取样，其中的每一个方面都会是相对复杂的问题，可对于加载图片的需求，我等搬砖的，解决问题是目的，故我们使用了现在的图片加载库。好了，目的达成，我们是否还要去关注其细节吗？   </p><p>我现在的理解是，不用。  </p><p>这似乎跟我们平常提倡的主流思想的相悖，诸如，学习使用某个框架时，我们不仅仅是要了解其用法，更要知其原理。  </p><p>这句话误导我多年了，我学习某个新的框架时，总是试图直接通过探究其中的原理来理解掌握它。这么做的结果，常常是我对这个框架的解读半途而废。从原理来理解掌握一个框架，从而让我在使用它时能够游刃有余，这个学习方法看似十分正确的捷径，却因其陡峭，让我无数次半途而废。故，我认为这个学习方法是不合适平常学习某个框架的。</p><p>掌握一个框架，比较平滑且现实的曲线是，这个框架没能满足需求，需要对其改动才能解决问题，我们尝试去改动它，基于改动目的，我们才会去理解其原理，理解不了原理，我们没法达到改动框架解决问题的目的呀，在一次次改动中，我们才能理解其中部分的原理，最终较完整的掌握一个框架。</p><p>掌握框架悉知其原理，使用框架游刃有余。我们知道，前者是因，后者是果，也知道，前者是手段，后者是目的。我们都很明白自己要的目的，但每个人的目的实际上不同的。我等搬砖，加载好图片了事，没有更多奇怪的要求，达到了目的，便不再去深入了解其原理了嘛。而只有怀有更高要求的，（比如其框架不能满足要求的），才会自然的去学习原理。</p><p>于框架的本意而言，框架本就是解决了普遍的问题，自然地，普遍的使用者也只会熟悉其用法，而只有少部分人才会真正掌握它。当然了，其实还有一部分人（感觉是绝大部分人），没有迫切的需求，只有一些好奇心，试图直接去剖析其原理总是是失败的，而若为了面试竞争，这个目的很诱人，但实际上，这个目的和手段关系并不是那么直接。（立志高远，能把两者绑定密切点，毕竟竞争激励的地方才会有要求）</p><p>总结下，明确自己的目的，选择自己的手段。  </p><pre><code>让自己舒服 &lt;- (钱 + 健康 + 情感) &lt;- (提高能力 + 锻炼 + 电话多点)</code></pre><p>假设让自己舒服是我们的终极目标，我们的手段就是钱，健康，情感，而为了能够使用上这些手段，我们就要将它们视为一个个小目标，从而思考相应的手段，随之分别是 提高能力，锻炼，电话多点。此时，怎么发现，这些都违背了我们的终极目标？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter之Builder</title>
      <link href="/2020/08/26/Flutter%E4%B9%8BBuilder/"/>
      <url>/2020/08/26/Flutter%E4%B9%8BBuilder/</url>
      
        <content type="html"><![CDATA[<p>例子</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _AppState createState() =&gt; _AppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">App</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Builder(</span><br><span class="line">          builder: (context) =&gt; RaisedButton(</span><br><span class="line">            child: Text(<span class="string">"click me"</span>),</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              Scaffold.of(context).showSnackBar(SnackBar( <span class="comment">//2</span></span><br><span class="line">                content: Text(<span class="string">"hello"</span>),</span><br><span class="line">              ));</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Scaffold中展示了一个SnackBar，我们使用Scaffold.of(context)获取ScaffoldState对象，失败了。 </p><p>咋一看，我们是在Scaffold节点的下面获取的，按理是可以的。</p><p>但，却发现context确实从AppState传进来的，而在在该层中context从节点树网上寻找，是找不到我们要的ScaffoldState的。</p><p>故，报错了。</p><p>flutter给了建议。</p><ol><li>使用 Builder，最简易的方法，将Button包裹一个Builder,该方法传入的context便能获取了。</li><li>将RaisedButton写成一个独立的Widget，这么，我们在对应的Build方法中获取的context便能获取到Scaffold了。</li><li>使用一个GlobalKey，将key绑定到Scaffold,那么之后调用 state.currentState便能获取到Scaffold了。</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>每一个Widget都有自己的Context，对应Element树中位置。但是，问题是Widget没有直接获取Context的方法。为什么呢？因为仅在自己build方法调用时，相应的context才确定，相比于在Widget中加入一个Context成员提供一个随时可能为空的Context，还不如在在build方法中提供一个可靠的Context.</p>]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StatelessWidget_vs_StatefulWidget</title>
      <link href="/2020/07/27/StatelessWidget-vs-StatefulWidget/"/>
      <url>/2020/07/27/StatelessWidget-vs-StatefulWidget/</url>
      
        <content type="html"><![CDATA[<p>这两个类在framework.dart中，可见其重要性。其实自己看过了多次，不过现在还是想用文字记录着再看一次，因为它们太重要了。</p><h2 id="两者还有一个父类，Widget"><a href="#两者还有一个父类，Widget" class="headerlink" title="两者还有一个父类，Widget"></a>两者还有一个父类，Widget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// Element的配置信息</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Key key;</span><br><span class="line">  <span class="comment">// Widget的存在的目的就是创建出Element，作为元素再Element树中</span></span><br><span class="line">  <span class="comment">// 其创建过程我们称之为inflate，注意可以加载多次，对应多个Element</span></span><br><span class="line">  <span class="built_in">Element</span> createElement();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当 oldWidget 创建的Element加载在树中后</span></span><br><span class="line">  <span class="comment">// 当我们再次调用build方法时，对于原先的Element是怎么处理呢？</span></span><br><span class="line">  <span class="comment">// 我们是否能够更新原先老的Element？</span></span><br><span class="line">  <span class="comment">// 这个问题很重要，决定了Element能否被复用，而不是重新创建的新的Element来替换掉原先的Element。</span></span><br><span class="line">  <span class="comment">// 这个问题的换个说法，就是原先的Element能否被更新？ </span></span><br><span class="line">  <span class="comment">// 答案是，需要runtime和key都相同。</span></span><br><span class="line">  <span class="comment">// 注意，当key都为空时，也认为key相同，当然这个很符合逻辑。</span></span><br><span class="line">  <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget)&#123;</span><br><span class="line">    <span class="comment">// runtimeType &amp;&amp; key equal</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// 强调了UI仅依赖配置信息，和当前环境BuildContext</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 性能考虑</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// build()方法的执行时机有三种</span></span><br><span class="line"><span class="comment">/// 1. 第一次插入到 Element 树中</span></span><br><span class="line"><span class="comment">/// 2, 父级的Widget改变，递归到导致该方法执行</span></span><br><span class="line"><span class="comment">/// 3, 依赖信息改变，其依赖的信息形式是InheritedWidget</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// 尽管build方法的执行，并不会每次都会重新新的Element，但还是避免频繁调用build方法的。措施如下下</span></span><br><span class="line"><span class="comment">/// 减少节点层级，使得节点递归创建。如Align替代 Row，Column 的混用</span></span><br><span class="line"><span class="comment">/// 使用const修饰构造器，可以避免每次setState而重建</span></span><br><span class="line"><span class="comment">/// 考虑使用statefulWidget来利用相关的缓存技术</span></span><br><span class="line"><span class="comment">/// 在使用InheritedWidget时，将依赖更加精细化</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  StatelessElement createElement() =&gt; StatelessElement(<span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>状态信息可以异步读取<br>状态信息可以在Widget的生命周期内修改</p><p>注意到，StatefulWidget本身是不可变，只有State是可变的，其属性State是final field，创建后后指向。</p><p>每次 inflate Widget 便会调用createSate()。从树中移除后，重新插入也会导致创建createState</p><p>当使用GlobalKey时，移动Element的位置，可以复用原来的State，这样我们可以移动一个子树，注意移除还插入的动作需要在动画的同一帧完成。</p><p>性能考虑：</p><p>将State尽可能放到叶子，下放<br>要是子树不会改变，缓存子树<br>避免修改子树的深度和类型，转而使用属性来控制相应的状态。这个可以用 canUpdate() 来理解，改变状态来可以避免原先Element被替换。若是子树深度非要改变，子树使用GlobalKey。使用KeyedSubtree要是不方便指定Widget来使用GlobalKey。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>Widget创建的State绑定到 BuildContext 被认为是 mounted状态，其关联关系绑定后不可变了。</p><p>绑定后，可以根据Context来 initSate()</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulWidget</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  StatefulWidget createElement() =&gt; StatefulElement(<span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">  State createState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> _StateLifeCycle&#123;</span><br><span class="line">  <span class="comment">// initState()未执行</span></span><br><span class="line">  created,</span><br><span class="line">  <span class="comment">// 需要执行didChangeDependencies（）</span></span><br><span class="line">  initialized,</span><br><span class="line">  <span class="comment">// 可以执行build，且dispose未执行</span></span><br><span class="line">  ready,</span><br><span class="line">  <span class="comment">// dispose()已执行，不能再重新build</span></span><br><span class="line">  defunct</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  T _widget;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// widget z</span></span><br><span class="line">  BuildContext <span class="keyword">get</span> context =&gt; _element;</span><br><span class="line">  StatefulElement _element;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> mounted =&gt; element != <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当Widget插入到树中时调用</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> initState()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当配置发生变化调用</span></span><br><span class="line">  <span class="comment">// 当父级Widget重建需要更新该Widget，（runtimeType和Key相同），导致的结果是</span></span><br><span class="line">  <span class="comment">// 更新该State，基于原先的oldWidget创建新的Widget</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  在这个方法后，回到调用build方法的，所以无需再手动setState</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(covariant T oldWidget)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通知框架，该State中的属性改变了，需要更新</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">/// Future&lt;void&gt; _incrementCounter() async &#123;</span></span><br><span class="line">  <span class="comment">///   setState(() &#123;</span></span><br><span class="line">        <span class="comment">// 影响Widget的放在里面</span></span><br><span class="line">  <span class="comment">///     _counter++;</span></span><br><span class="line">  <span class="comment">///   &#125;);</span></span><br><span class="line">        <span class="comment">// 其他不直接影响的放外面</span></span><br><span class="line">  <span class="comment">///   Directory directory = await getApplicationDocumentsDirectory();</span></span><br><span class="line">  <span class="comment">///   final String dirName = directory.path;</span></span><br><span class="line">  <span class="comment">///   await File('$dir/counter.txt').writeAsString('$_counter');</span></span><br><span class="line">  <span class="comment">/// &#125;</span></span><br><span class="line">  <span class="keyword">void</span> setState(VoidCallback fn)&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">dynamic</span> result = fn() <span class="keyword">as</span> <span class="keyword">dynamic</span>;</span><br><span class="line">    _element.markNeedBuild();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当State在被移除树时</span></span><br><span class="line">  <span class="comment">// 当State更新，从一个位置移动另一个位置时，在该方法调用后，会保证调用build方法的</span></span><br><span class="line">  <span class="comment">// 注意哦</span></span><br><span class="line">  <span class="comment">// 由于移除和插入是两个步骤，且插入的动作需要保证在动画的新一帧绘制前完成，故需要该方法执行要快,故释放资源的操作该</span></span><br><span class="line">  <span class="comment">// 放在 dispose（）中</span></span><br><span class="line">  <span class="keyword">void</span> deactivate()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 该方法可能在下列情况下执行</span></span><br><span class="line">  <span class="comment">// after initState</span></span><br><span class="line">  <span class="comment">// after didUpdateWidget</span></span><br><span class="line">  <span class="comment">// after receive a call to setState</span></span><br><span class="line">  <span class="comment">// a dependency of State change</span></span><br><span class="line">  <span class="comment">// after call deactivate and reinsert State into other location</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123; &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个设计问题？为什么-Build（）放在State，而不是放在StatefulWidget"><a href="#一个设计问题？为什么-Build（）放在State，而不是放在StatefulWidget" class="headerlink" title="一个设计问题？为什么 Build（）放在State，而不是放在StatefulWidget"></a>一个设计问题？为什么 Build（）放在State，而不是放在StatefulWidget</h3><p>没有在StatefulWidget中这么写，给StatefulWidget更多的灵活性，如何理解呢？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context, State state) &#123;&#125;</span><br></pre></td></tr></table></figure><p>AnimateWidget是很多动画的表示，假设在StatefulWidget中防止Build方法，则导致Widget依赖很多动画的实现State</p><p>概念上，StatelessWidget是StatefulWidget的子类，若是将StatefulWidget多了个方法，那么将不可能了</p><h3 id="State中的注册和注销"><a href="#State中的注册和注销" class="headerlink" title="State中的注册和注销"></a>State中的注册和注销</h3><p>假设我们构造的目标对象，依赖了某些对象，我们该在什么时机注册和注销这些依赖呢</p><p>initState() 中订阅</p><p>didUpdateWidget() 中，若是需要，unSubscribe原先的源并更换新的源</p><p>dispose() 注销所有的源</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flutter-ListView</title>
      <link href="/2020/07/27/flutter-ListView/"/>
      <url>/2020/07/27/flutter-ListView/</url>
      
        <content type="html"><![CDATA[<p>大略浏览了 tabs 的内容后，其中的TabBar和TabBarView分别对应了安卓原生的Tab和ViewPager，很多逻辑都是一样的呀。<br>其中TabBarView是PageView来实现的，看了大概之后，发觉其实它更像原生ViewPager2，而ViewPager2内部是用RecyclerView实现的，故此我觉得应该还是先去了解Flutter中的RecyclerView，这样就找到了ListView。初略来看，ListView的文档资料的确更多一些啊。</p><p>ListView作为可以放置很多ItemView的的Widget，包括了 </p><ul><li>设置滚动方向</li><li>设置其是否能滚动，physics</li><li>超出屏幕的item如何回收，如何回收，cacheExtent来设置缓存程度，(重点)</li><li>动态创建Item，还是一次性创建好？</li></ul><p>itemExtent数据范围，列表的数据集大小</p><p>通常写死ListView的大小，是可以提升性能的</p><p>构建ListView有4中方法</p><ol><li>直接传入所有itemView，这样会导致所有的view都会一次性创建</li><li>使用ListView.builder,使用一个IndexedWidgetBuilder，仅在需要可见时才会创建相应的itemView</li><li>使用ListView.separated，使用了两个IndexedWidgetBuilder，相比于上一个，多个一个分隔符</li><li>使用ListView.custom，使用 SliverChildDelegate，提供更自由的拓展。</li></ol><h2 id="Child-Elements-的生命周期"><a href="#Child-Elements-的生命周期" class="headerlink" title="Child Elements 的生命周期"></a>Child Elements 的生命周期</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>当布局List，可见的Elements，States，render objects 将会创建，或复用若是默认构造器，基于已经有的Widget来创建若是builder，则基于已经存在的elements等来复用</p><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>当一个子View滚出屏幕又滚回来，同一个位置的child会使用新的elements，states,render objects</p><h2 id="关于-ListView-和-CustomView"><a href="#关于-ListView-和-CustomView" class="headerlink" title="关于 ListView 和 CustomView"></a>关于 ListView 和 CustomView</h2><p>ListView 基本是一个CustomView，在其slivers属性中，赋值一个 SliverList，这样，有很多属性都是用与CustomView的，而CustomView.slivers属性赋值可能会是SliverList或是SliverFixedExtentList，这样便对应了ListView是否指定了itemExtent, 即是否指定了列表的大小</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Text(<span class="string">"Hello"</span>);</span><br><span class="line">  ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">///对应的</span></span><br><span class="line"></span><br><span class="line">CustomView(</span><br><span class="line">  slivers:&lt;Widget&gt;[</span><br><span class="line">    SliverPadding(</span><br><span class="line">        paddding:...</span><br><span class="line">        sliver:SliverList(</span><br><span class="line">          delegate: SliverChildListDelegate(</span><br><span class="line">            &lt;Widget&gt;[</span><br><span class="line">              Text(<span class="string">"Hello"</span>)</span><br><span class="line">            ]</span><br><span class="line">          )     </span><br><span class="line">        )</span><br><span class="line">     ) </span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>看完对应的CustomView之后，似乎想到了RecyclerView的嵌套问题</p><p>对于空数据的View，Flutter的设计理念？ 来个条件判断即可</p><h2 id="关于-ListView的层级关系"><a href="#关于-ListView的层级关系" class="headerlink" title="关于 ListView的层级关系"></a>关于 ListView的层级关系</h2><p>跟android中的一样，ListView还有一个二维的GridView，但他们都继承于BoxScrollView</p><p>而，BoxedScrollView基本就是两个方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Widget&gt; buildSlivers(BuildContext context)&#123;</span><br><span class="line">  buildChildLayout()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Widget buildChildLayout(BuildContext context);</span><br></pre></td></tr></table></figure><p>没什么好看的，继续看ScrollView</p><h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><p>包含有3部分</p><ul><li>一个 Scrollable Widget，监听用户手势，处理滚动</li><li>一个 ViewPort ，内容大小比它自身占有的大小大(我这个描述有点秀啊，原文：A widget that is bigger on the insider)</li><li>一个或多个 Slivers</li></ul><p>关于这个者三部分，我们觉得重点是ViewPort。</p><h3 id="ViewPort"><a href="#ViewPort" class="headerlink" title="ViewPort"></a>ViewPort</h3>]]></content>
      
      
      
        <tags>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter_tabs</title>
      <link href="/2020/07/23/flutter-tabs/"/>
      <url>/2020/07/23/flutter-tabs/</url>
      
        <content type="html"><![CDATA[<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TabPageState createState() =&gt; _TabPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TabPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TabPage</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tabs = &lt;Tab&gt;[</span><br><span class="line">    Tab(</span><br><span class="line">      text: <span class="string">"动态"</span>,</span><br><span class="line">    ),</span><br><span class="line">    Tab(</span><br><span class="line">      text: <span class="string">"热门"</span>,</span><br><span class="line">    )</span><br><span class="line">  ];</span><br><span class="line">  TabController _tabController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _tabController = TabController(length: tabs.length, vsync: <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _tabController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">          bottom: TabBar(</span><br><span class="line">            tabs: tabs,</span><br><span class="line">            controller: _tabController,</span><br><span class="line">          ),</span><br><span class="line">      ),</span><br><span class="line">      body: TabBarView(children: tabs.map((e) =&gt;</span><br><span class="line">          Center(</span><br><span class="line">            child: Text(</span><br><span class="line">              <span class="string">"Hey,I am content of <span class="subst">$e</span>"</span>, style: TextStyle(fontSize: <span class="number">18</span>),),</span><br><span class="line">          )).toList()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line"> </span><br><span class="line">  runApp(TabPage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scaffold-的创建需要传入带有-MediaQuery-数据的-Context"><a href="#Scaffold-的创建需要传入带有-MediaQuery-数据的-Context" class="headerlink" title="Scaffold 的创建需要传入带有 MediaQuery 数据的 Context"></a>Scaffold 的创建需要传入带有 MediaQuery 数据的 Context</h2><p>报错如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I/flutter ( 2928): The following assertion was thrown building TabPage(state: _TabPageState#f2fb0(ticker inactive)):</span><br><span class="line">I/flutter ( 2928): MediaQuery.of() called with a context that does not contain a MediaQuery.</span><br><span class="line">I/flutter ( 2928): No MediaQuery ancestor could be found starting from the context that was passed to MediaQuery.of().</span><br><span class="line">I/flutter ( 2928): This can happen because you do not have a WidgetsApp or MaterialApp widget (those widgets introduce</span><br><span class="line">I/flutter ( 2928): a MediaQuery), or it can happen if the context you use comes from a widget above those widgets.</span><br><span class="line">I/flutter ( 2928): The context used was:</span><br><span class="line">I/flutter ( 2928):   Scaffold</span><br></pre></td></tr></table></figure><p>Scaffold作为一个脚手架，创建时不能直接作为根视图，还是需要外包 MaterialApp 等，其创建后，可以为子Widget提供一些数据，比如当前屏幕的大小，像素密度等。</p><p>我们看看 WidgetsApp 如何为下层提供MediaQuery相关数据的？</p><p>我们看到其内部使用一个MediaQueryFromWindow包裹，即从Window中获取屏幕的信息，其获取方法使用使用 WidgetsBindingObserver 的方式，而在MediaQuery中，使用静态方法，将data绑定到Context，后续子Widget想要获取该信息就可以直接通过下面获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var data = MediaQuery.of(context)</span><br></pre></td></tr></table></figure><p>另外，由于MediaQuery是继承 InheritedWidget的，当子Widget实现了didChangeDependencies方法后，当屏幕信息改变，根视图WidgetsApp会通过观察者WidgetsBindingObserver观察到，重新设置当前的MediaQueryData，之后子Widget也能收到屏幕变化，从而重建。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Builds [MediaQuery] from `window` by listening to [WidgetsBinding].</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// It is performed in a standalone widget to rebuild **only** [MediaQuery] and</span></span><br><span class="line"><span class="comment">/// its dependents when `window` changes, instead of rebuilding the entire widget tree.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MediaQueryFromWindow</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MediaQueryFromWindowsState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_MediaQueryFromWindow</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="comment">// 通过Bindg实例的window，连通我们的屏幕，获取相关的信息</span></span><br><span class="line">      MediaQueryData data = MediaQueryData.fromWindow(WidgetsBinding.instance.<span class="built_in">window</span>);</span><br><span class="line">      <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">        data = data.copyWith(platformBrightness: debugBrightnessOverride);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> MediaQuery(</span><br><span class="line">        data: data,</span><br><span class="line">        child: widget.child,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The data from the closest instance of this class that encloses the given</span></span><br><span class="line"> <span class="comment">/// context.</span></span><br><span class="line"> <span class="comment">///</span></span><br><span class="line"> <span class="comment">/// You can use this function to query the size an orientation of the screen.</span></span><br><span class="line"> <span class="comment">/// When that information changes, your widget will be scheduled to be</span></span><br><span class="line"> <span class="comment">/// rebuilt, keeping your widget up-to-date.</span></span><br><span class="line"> <span class="comment">///</span></span><br><span class="line"> <span class="comment">/// Typical usage is as follows:</span></span><br><span class="line"> <span class="comment">///</span></span><br><span class="line"> <span class="comment">/// ```dart</span></span><br><span class="line"> <span class="comment">/// MediaQueryData media = MediaQuery.of(context);</span></span><br><span class="line"> <span class="comment">///</span></span><br></pre></td></tr></table></figure><p>  ///  /// If there is no [MediaQuery] in scope, then this will throw an exception.  /// To return null if there is no [MediaQuery], then pass <code>nullOk: true</code>.  ///  /// If you use this from a widget (e.g. in its build function), consider  /// calling [debugCheckHasMediaQuery].  static MediaQueryData of(BuildContext context, { bool nullOk = false }) {    assert(context != null);    assert(nullOk != null);    final MediaQuery query = context.dependOnInheritedWidgetOfExactType<mediaquery>();    if (query != null)      return query.data;    if (nullOk)      return null;    throw FlutterError.fromParts(<diagnosticsnode>[      ErrorSummary(‘MediaQuery.of() called with a context that does not contain a MediaQuery.’),      ErrorDescription(        ‘No MediaQuery ancestor could be found starting from the context that was passed ‘        ‘to MediaQuery.of(). This can happen because you do not have a WidgetsApp or ‘        ‘MaterialApp widget (those widgets introduce a MediaQuery), or it can happen ‘        ‘if the context you use comes from a widget above those widgets.’      ),      context.describeElement(‘The context used was’)    ]);  }</diagnosticsnode></mediaquery></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### WidgetsApp 与 MaterialApp 的区别</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">看看前者WidgetsApp的定义,打包了一个应用普遍需要的Widget</span><br><span class="line">&gt;/// A convenience widget that wraps a number of widgets that are commonly  </span><br><span class="line"> /// required for an application.</span><br><span class="line"></span><br><span class="line">而 MaterialApp 可以说是在前者的基础上实现了Material风格，与之对应的风格还有苹果风格 CupertinoApp</span><br><span class="line"></span><br><span class="line">&gt; /// A convenience widget that wraps a number of widgets that are commonly</span><br><span class="line">  /// required for material design applications. It builds upon a [WidgetsApp] by</span><br><span class="line">  /// adding material-design specific functionality, such as [AnimatedTheme] and</span><br><span class="line">  /// [GridPaper].</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 好了，我们还是回到 TabController 吧</span><br><span class="line"></span><br><span class="line">看看定义，就是协同 `Tabbar` 和 `TabBarView` 选中关系的，两者都有自己的index，当其中一个index发生改变时，另一个index也要跟着</span><br><span class="line">变化哈。</span><br><span class="line"></span><br><span class="line">TabController作为两者其中的沟通的桥梁</span><br><span class="line"></span><br><span class="line">其中有个比较关键的点，其中的Animation中的值, 值的范围为[0-tabs.length],是double类型，代表着TabBar 和 TabBarView的滚动偏移量</span><br><span class="line">scrollOffset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line">/// </span><br><span class="line">/// Coordinates tab selection between a [TabBar] and a [TabBarView].</span><br><span class="line">///</span><br><span class="line">/// The [index] property is the index of the selected tab and the [animation]</span><br><span class="line">/// represents the current scroll positions of the tab bar and the tab bar view.</span><br><span class="line">/// The selected tab&apos;s index can be changed with [animateTo].</span><br><span class="line">///</span><br><span class="line">/// A stateful widget that builds a [TabBar] or a [TabBarView] can create</span><br><span class="line">/// a [TabController] and share it directly.</span><br><span class="line">///</span><br><span class="line">/// When the [TabBar] and [TabBarView] don&apos;t have a convenient stateful</span><br><span class="line">/// ancestor, a [TabController] can be shared by providing a</span><br><span class="line">/// [DefaultTabController] inherited widget.</span><br><span class="line">///</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">  /// An animation whose value represents the current position of the [TabBar]&apos;s</span><br><span class="line">  /// selected tab indicator as well as the scrollOffsets of the [TabBar]</span><br><span class="line">  /// and [TabBarView].</span><br><span class="line">  ///</span><br><span class="line">  /// The animation&apos;s value ranges from 0.0 to [length] - 1.0. After the</span><br><span class="line">  /// selected tab is changed, the animation&apos;s value equals [index]. The</span><br><span class="line">  /// animation&apos;s value can be [offset] by +/- 1.0 to reflect [TabBarView]</span><br><span class="line">  /// drag scrolling.</span><br><span class="line">  ///</span><br><span class="line">  /// If this [TabController] was disposed, then return null.</span><br><span class="line">  Animation&lt;double&gt; get animation =&gt; _animationController?.view;</span><br><span class="line">  AnimationController _animationController;</span><br><span class="line"></span><br><span class="line">  /// 易见的思维，维护两个值</span><br><span class="line">  int _previousIndex;</span><br><span class="line">  int _index;</span><br><span class="line">  </span><br><span class="line">  /// 可以看到改变index时，会执行相应的动画哈</span><br><span class="line">  void _changeIndex(int value, &#123; Duration duration, Curve curve &#125;) &#123;</span><br><span class="line">    if (value == _index || length &lt; 2)</span><br><span class="line">      return;</span><br><span class="line">    _previousIndex = index;</span><br><span class="line">    _index = value;</span><br><span class="line">    if (duration != null) &#123;</span><br><span class="line">      _indexIsChangingCount += 1;</span><br><span class="line">      notifyListeners(); // Because the value of indexIsChanging may have changed.</span><br><span class="line">      // 使用AnimationController来执行动画</span><br><span class="line">      _animationController</span><br><span class="line">        .animateTo(_index.toDouble(), duration: duration, curve: curve)</span><br><span class="line">        .whenCompleteOrCancel(() &#123;</span><br><span class="line">          _indexIsChangingCount -= 1;</span><br><span class="line">          notifyListeners();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      _indexIsChangingCount += 1;</span><br><span class="line">      _animationController.value = _index.toDouble();</span><br><span class="line">      _indexIsChangingCount -= 1;</span><br><span class="line">      notifyListeners();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在TabBar中我们就可以看大调用controller方法的例子</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/// 这里我们及监听frame的变化哦，这样，几乎实时更TabPagView保持同步偏移</span></span><br><span class="line"><span class="keyword">void</span> _handleTabControllerAnimationTick() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(mounted);</span><br><span class="line">  <span class="keyword">if</span> (!_controller.indexIsChanging &amp;&amp; widget.isScrollable) &#123;</span><br><span class="line">    <span class="comment">// Sync the TabBar's scroll position with the TabBarView's PageView.</span></span><br><span class="line">    _currentIndex = _controller.index;</span><br><span class="line">    _scrollToControllerValue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _handleTabControllerTick() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_controller.index != _currentIndex) &#123;</span><br><span class="line">    _currentIndex = _controller.index;</span><br><span class="line">    <span class="keyword">if</span> (widget.isScrollable)</span><br><span class="line">      _scrollToCurrentIndex();</span><br><span class="line">  &#125;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    <span class="comment">// Rebuild the tabs after a (potentially animated) index change</span></span><br><span class="line">    <span class="comment">// has completed.</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 最典型的例子，点击tab，导致controller对应的tabPageView也会滚动到对应页面</span></span><br><span class="line"><span class="keyword">void</span> _handleTap(<span class="built_in">int</span> index) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; widget.tabs.length);</span><br><span class="line">  _controller.animateTo(index);</span><br><span class="line">  <span class="keyword">if</span> (widget.onTap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    widget.onTap(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="看看-TabBarState的实现"><a href="#看看-TabBarState的实现" class="headerlink" title="看看 _TabBarState的实现"></a>看看 _TabBarState的实现</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TabBarState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TabBar</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Tabs 一般可以左右滑动，用于控制当前TabBar的整体偏移量</span></span><br><span class="line">  ScrollController _scrollController;</span><br><span class="line">  <span class="comment">// 与TabBarView交换数据的</span></span><br><span class="line">  TabController _controller;</span><br><span class="line">  <span class="comment">// 指示器，这个时候很有搞头，可以做一些炫酷（花哨）的效果 todo 了解在画布上自己画东西</span></span><br><span class="line">  _IndicatorPainter _indicatorPainter;</span><br><span class="line">  <span class="built_in">int</span> _currentIndex;</span><br><span class="line">  <span class="comment">// 基本指示器的宽度是如何确定的呢</span></span><br><span class="line">  <span class="built_in">double</span> _tabStripWidth;</span><br><span class="line">  <span class="comment">// GlobalKey最大的作用，就是可以reparent，可以在Element树中更换位置， todo 了解这些Key的作用</span></span><br><span class="line">  <span class="built_in">List</span>&lt;GlobalKey&gt; _tabKeys;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 似乎也挺简单的，所有天的tab添加点击事件</span></span><br><span class="line">    <span class="comment">// Add the tap handler to each tab. If the tab bar is not scrollable,</span></span><br><span class="line">    <span class="comment">// then give all of the tabs equal flexibility so that they each occupy</span></span><br><span class="line">    <span class="comment">// the same share of the tab bar's overall width.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> tabCount = widget.tabs.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; tabCount; index += <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 包裹InkWell 墨水池，挺形象的，水波效果</span></span><br><span class="line">      wrappedTabs[index] = InkWell(</span><br><span class="line">        mouseCursor: widget.mouseCursor ?? SystemMouseCursors.click,</span><br><span class="line">        onTap: () &#123; _handleTap(index); &#125;,</span><br><span class="line">        child: Padding(</span><br><span class="line">          padding: EdgeInsets.only(bottom: widget.indicatorWeight),</span><br><span class="line">          child: Stack(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              wrappedTabs[index],</span><br><span class="line">              <span class="comment">// 这个为视觉不好的人，辅助功能呀</span></span><br><span class="line">              Semantics(</span><br><span class="line">                selected: index == _currentIndex,</span><br><span class="line">                label: localizations.tabLabel(tabIndex: index + <span class="number">1</span>, tabCount: tabCount),</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    <span class="comment">// 若是不可滚动，这是使用Expanded包裹，所有的tab能平分水平距离</span></span><br><span class="line">      <span class="keyword">if</span> (!widget.isScrollable)</span><br><span class="line">        wrappedTabs[index] = Expanded(child: wrappedTabs[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Widget tabBar = CustomPaint(</span><br><span class="line">      painter: _indicatorPainter,</span><br><span class="line">      child: _TabStyle(</span><br><span class="line">        animation: kAlwaysDismissedAnimation,</span><br><span class="line">        selected: <span class="keyword">false</span>,</span><br><span class="line">        labelColor: widget.labelColor,</span><br><span class="line">        unselectedLabelColor: widget.unselectedLabelColor,</span><br><span class="line">        labelStyle: widget.labelStyle,</span><br><span class="line">        unselectedLabelStyle: widget.unselectedLabelStyle,</span><br><span class="line">        child: _TabLabelBar(</span><br><span class="line">          <span class="comment">// 重新布局时，保存当前tab的Offset，内部TabLabelBar的实现</span></span><br><span class="line">          onPerformLayout: _saveTabOffsets,</span><br><span class="line">          children: wrappedTabs,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget.isScrollable) &#123;</span><br><span class="line">      _scrollController ??= _TabBarScrollController(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">// 为Android的ScrollView的取了一个更精确的名字</span></span><br><span class="line">      tabBar = SingleChildScrollView(</span><br><span class="line">        dragStartBehavior: widget.dragStartBehavior,</span><br><span class="line">        scrollDirection: Axis.horizontal,</span><br><span class="line">        controller: _scrollController,</span><br><span class="line">        physics: widget.physics,</span><br><span class="line">        child: tabBar,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tabBar;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TabBarViewState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TabBarView</span>&gt; </span>&#123;</span><br><span class="line">  TabController _controller;</span><br><span class="line">  PageController _pageController;</span><br><span class="line">  <span class="comment">// 这里我们看到children不是直接用了，而是附加上一Key，这个Key是根绝Index来生成了</span></span><br><span class="line">  <span class="comment">//_childrenWithKey = KeyedSubtree.ensureUniqueKeysForList(widget.children);</span></span><br><span class="line">  <span class="comment">// 为什么呢？</span></span><br><span class="line">  <span class="comment">// Creates a KeyedSubtree for child with a key that's based on the child's existing key or childIndex.</span></span><br><span class="line">  <span class="comment">// Key和对应的index是确定的，似乎就是保存当前视图的状态了</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; _children;</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; _childrenWithKey;</span><br><span class="line">  <span class="built_in">int</span> _currentIndex;</span><br><span class="line">  <span class="built_in">int</span> _warpUnderwayCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 这里使用NotificationListener,就是要要监听冒泡上来的事件，传入的泛型就是它想关注的通知</span></span><br><span class="line">    <span class="keyword">return</span> NotificationListener&lt;ScrollNotification&gt;(</span><br><span class="line">      onNotification: _handleScrollNotification,</span><br><span class="line">      child: PageView(</span><br><span class="line">        dragStartBehavior: widget.dragStartBehavior,</span><br><span class="line">        controller: _pageController,</span><br><span class="line">        physics: widget.physics == <span class="keyword">null</span></span><br><span class="line">          ? _kTabBarViewPhysics.applyTo(<span class="keyword">const</span> ClampingScrollPhysics())</span><br><span class="line">          : _kTabBarViewPhysics.applyTo(widget.physics),</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        children: _childrenWithKey,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左右抖动的动画</title>
      <link href="/2020/07/18/2020-07-18%E5%B7%A6%E5%8F%B3%E6%8A%96%E5%8A%A8%E7%9A%84%E5%8A%A8%E7%94%BB/"/>
      <url>/2020/07/18/2020-07-18%E5%B7%A6%E5%8F%B3%E6%8A%96%E5%8A%A8%E7%9A%84%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="目标效果"><a href="#目标效果" class="headerlink" title="目标效果"></a>目标效果</h3><img src="/images/anim_target.gif" width="240" height="200"><p>触发后，金币左右抖动多次，向上移动并消失，文字向下移动显示   </p><p>实现方式似乎很简单，依次实现上述三个动画即可</p><p>而本文主要展示我在第一个动画的探索过程</p><h3 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h3><p>我们需要保持动画结束时的状态，故采用属性动画。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>,  -<span class="number">100f</span>,  <span class="number">100f</span>).apply &#123;</span><br><span class="line">    duration = <span class="number">1000</span></span><br><span class="line">    repeatCount = <span class="number">2</span></span><br><span class="line">    repeatMode = ValueAnimator.REVERSE</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><img src="/images/anim_version_0.gif" width="240" height="200"><p>存在问题，动画播放开始时，金币直接跳到左边，而非缓慢移动到左边，导致动画开始时和结束时很突兀。</p><h3 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h3><p>针对发现的原因，我们把中点到左边的过程也纳入动画中，<br>改变如下</p><p>原本： left -&gt; right<br>现在： mid -&gt; left -&gt; mid -&gt; right -&gt; mid   </p><p>同时，重复模式也要改成<code>RESTART</code>, 原因，动画重复时，当前定义的路径是不能翻转的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>,  <span class="number">0f</span>, -<span class="number">100f</span>, <span class="number">0f</span>, <span class="number">100f</span>, <span class="number">0f</span>).apply &#123;</span><br><span class="line">    duration = <span class="number">1000</span></span><br><span class="line">    repeatCount = <span class="number">2</span></span><br><span class="line">    repeatMode = ValueAnimator.RESTART</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><img src="/images/anim_version_1.gif" width="240" height="200"><p>存在问题，重复播放到中点时，金币摆动的速度会变得很慢，后才逐渐加快</p><h3 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h3><p>一直误以为插值器是匀速线性，即<code>LinearInterpolator</code>，导致的这个错误认知的原因应该来源于这个方法。<br>当设的值为空时，便设为<code>LinearInterpolator</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> void setInterpolator(TimeInterpolator value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        mInterpolator = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInterpolator = new LinearInterpolator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而实际上默认的插值器是非线性的,即<code>AccelerateDecelerateInterpolator</code>，先加速后减速。仔细想想使用这个插值器更加合理，更加接近自然效果。生活中，当我们用力推动一个小球一段时间，加速到减速的过程更加符合实际。</p><p>而这里，我们尝试将插值器改为线性的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>,  <span class="number">0f</span>, -<span class="number">100f</span>, <span class="number">0f</span>, <span class="number">100f</span>, <span class="number">0f</span>).apply &#123;</span><br><span class="line">    duration = <span class="number">1000</span></span><br><span class="line">    repeatCount = <span class="number">2</span></span><br><span class="line">    interpolator=LinearInterpolator()</span><br><span class="line">    repeatMode = ValueAnimator.RESTART</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><img src="/images/anim_version_2.gif" width="240" height="200"><p>存在问题，摆动的整个过程很僵硬，不符合自然效果。</p><h3 id="版本4"><a href="#版本4" class="headerlink" title="版本4"></a>版本4</h3><p>为了让金币摆动自然，我的方案是将金币摆动的过程分为三个动画实现，每个动画使用默认的插值器。</p><p>动画1：mid -&gt; left<br>动画2：left -&gt; right<br>动画3：right -&gt; mid   </p><p>注意duration时间的分配</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AnimatorSet().apply &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> xDuration = <span class="number">1000L</span></span><br><span class="line">    <span class="keyword">val</span> xOffset = <span class="number">100f</span></span><br><span class="line"></span><br><span class="line">    playSequentially(</span><br><span class="line">        ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>, -xOffset)</span><br><span class="line">            .setDuration((xDuration / <span class="number">2</span>)),</span><br><span class="line">        ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>, -xOffset, xOffset).apply &#123;</span><br><span class="line">            duration = xDuration</span><br><span class="line">            repeatMode = ValueAnimator.REVERSE</span><br><span class="line">            repeatCount = <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>, <span class="number">0f</span>).setDuration((xDuration / <span class="number">2</span>))</span><br><span class="line">    )</span><br><span class="line">&#125;.start</span><br></pre></td></tr></table></figure><img src="/images/anim_version_3.gif" width="240" height="200"><p>效果已经符合我的需求，不知道有没有更好的实现方式？</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有限状态机</title>
      <link href="/2020/06/30/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
      <url>/2020/06/30/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>有限状态机，刷题了解到这个概念时，惊叹了我。故此想要记录一下。  </p><p>原题<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a><br>题目描述</p><blockquote><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</p></blockquote><p>看到这样的题目，给人感觉就是好像思路了解了，但会有好多情况要判断啊。 </p><p>我能尝试写出的代码是这样子的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(s:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 是否是第一个字符</span></span><br><span class="line">    <span class="keyword">var</span> first = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 第一个字符时什么了，根据该类型继续判断后面的的输入是否正确</span></span><br><span class="line">    <span class="comment">// 1 正负号 2 小数点 3 数字 </span></span><br><span class="line">    <span class="keyword">var</span> firstCharType = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ch <span class="keyword">in</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first)&#123;  <span class="comment">//若是第一个字符</span></span><br><span class="line">            first = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">when</span>(ch)&#123;   <span class="comment">//记录第一个字符类型，为后续判断做为条件</span></span><br><span class="line">                <span class="string">'+'</span> or <span class="string">'-'</span> -&gt;&#123;  </span><br><span class="line">                    firstCharType = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span> -&gt;&#123;</span><br><span class="line">                    firstCharType = <span class="number">3</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="string">'.'</span> -&gt;&#123;</span><br><span class="line">                    firstCharType = <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt;&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>    <span class="comment">//第一个字符就可以确定不是数子</span></span><br><span class="line">                &#125;       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">when</span>(firstCharType)&#123;    <span class="comment">// 依据前面的状态，判断后续能有什么输入</span></span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码，写出来是不放心的，总感觉自己会遗漏某个分支情况。而且写出来后，代码肯定很长很繁琐。</p><p>而大佬使用有限状态机的代码是这样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        states = [</span><br><span class="line">            &#123; <span class="string">' '</span>: <span class="number">0</span>, <span class="string">'s'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">4</span> &#125;, <span class="comment"># 0. start with 'blank'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">4</span> &#125; ,                <span class="comment"># 1. 'sign' before 'e'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">3</span>, <span class="string">'e'</span>: <span class="number">5</span>, <span class="string">' '</span>: <span class="number">8</span> &#125;, <span class="comment"># 2. 'digit' before 'dot'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">3</span>, <span class="string">'e'</span>: <span class="number">5</span>, <span class="string">' '</span>: <span class="number">8</span> &#125;,         <span class="comment"># 3. 'digit' after 'dot'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">3</span> &#125;,                         <span class="comment"># 4. 'digit' after 'dot' (‘blank’ before 'dot')</span></span><br><span class="line">            &#123; <span class="string">'s'</span>: <span class="number">6</span>, <span class="string">'d'</span>: <span class="number">7</span> &#125;,                 <span class="comment"># 5. 'e'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">7</span> &#125;,                         <span class="comment"># 6. 'sign' after 'e'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">7</span>, <span class="string">' '</span>: <span class="number">8</span> &#125;,                 <span class="comment"># 7. 'digit' after 'e'</span></span><br><span class="line">            &#123; <span class="string">' '</span>: <span class="number">8</span> &#125;                          <span class="comment"># 8. end with 'blank'</span></span><br><span class="line">        ]</span><br><span class="line">        p = <span class="number">0</span>                           <span class="comment"># start with state 0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'0'</span> &lt;= c &lt;= <span class="string">'9'</span>: t = <span class="string">'d'</span> <span class="comment"># digit</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">"+-"</span>: t = <span class="string">'s'</span>     <span class="comment"># sign</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">".eE "</span>: t = c     <span class="comment"># dot, e, blank</span></span><br><span class="line">            <span class="keyword">else</span>: t = <span class="string">'?'</span>               <span class="comment"># unknown</span></span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> states[p]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p = states[p][t]</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>这样的代码看得真的舒服，加上配的状态转移图，逻辑也是清晰很多。<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/" target="_blank" rel="noopener">大佬的题解</a></p><p>个人的蹩脚的理解   </p><p>在一个系统中，当前的状态称为<code>现态</code>，外界输入称为<code>动作</code>, 随着输入后当前状态改变的结果称为<code>次态</code>,次态生成之后便成为新的现态，周而复始。 而<code>次态</code>的生成，不仅依赖输入，也依赖<code>现态</code>。这样会有这么一个逻辑，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = f(state, action)</span><br></pre></td></tr></table></figure><p>而这个函数<code>f</code> 是什么呢？我们可以体会到，它像数学中的条件函数，可以枚举出所有的条件，以及可接受的所有action,结果也就随之确定。</p><p>在这道题中,比如当前状态是，前面是空格（初始状态），下一个字符只能是数字，正负号等等，而不能接受<code>e</code>等输入。在这道题目中，我们可以体会到状态区分不是很清晰的，当前状态时之前所有输入的叠加。 </p><p>代码上，我们用states集合定义所有状态，而其中状态能够接受什么action和转移后的次态，分别用Key-Value表示。</p><p>联想日常开发中的相似的东西，当前页面的加载数据的状态。</p><p>Init –(request fetch data)–&gt; Loading –(load failed)–&gt; Failed –(retry)–&gt; Loading –(load success)–&gt; Success </p><p>这么一个流程，初始页面，请求数据，加载中，加载失败，重试，加载成功。</p><p>我们似乎可以意识到，想要达到<code>加载成功</code>状态，那么之前的状态是确定的，不存在从<code>初始状态</code>直接跳转到<code>加载成功</code>，期间必须经历状态<code>加载中</code>。 在页面的加载中，似乎可以列举出所有的状态，甚至所有的函数<code>f</code>,状态转移的关系。</p><p>页面加载中，状态较少，输入也少，因而不引入有限状态的概念我们也能理清他们的转移关系。不过，感觉这个概念确实是个好工具，针对多个状态的场景就很有必要了。但愿以后在业务复杂的场景能够引入这个概念来解决问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide源码略看</title>
      <link href="/2020/06/29/Glide%E6%BA%90%E7%A0%81%E7%95%A5%E7%9C%8B/"/>
      <url>/2020/06/29/Glide%E6%BA%90%E7%A0%81%E7%95%A5%E7%9C%8B/</url>
      
        <content type="html"><![CDATA[<p>##碎碎念</p><p>介绍Glide的文章看了挺多，偶尔也会点击查看部分的Glide的源码，可感觉对Glide的还是不太懂。个人觉得，每个人的水平不同，对知识点的掌握的面不同，可能他人的已掌握的知识点于自己而言是盲点，，写源码分析的人一般将自己觉得值得写的东西记录下来，故通过看他人的二手资料来了解一个库，可能会出现这么个情况，感觉自己自己看懂了，但却没有学到什么东西。看文章时是假设他人掌握的知识来得出结论的，可自己实际上没有学到那些前置知识。故，我还是想尝试自己看看。</p><p>##开始</p><p>看不懂现在的库，切换早些年的版本，比较容易查看整体轮廓。</p><h2 id="版本时间2012-12-21"><a href="#版本时间2012-12-21" class="headerlink" title="版本时间2012/12/21"></a>版本时间2012/12/21</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.两个缓存</span></span><br><span class="line">    <span class="comment">//加载图片，二级缓存，优先从内存获取，其次从磁盘，最后才会请求网络。</span></span><br><span class="line">    <span class="keyword">private</span> PhotoDiskCache diskCache;</span><br><span class="line">    <span class="keyword">private</span> LruPhotoCache memoryCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.图片大小转换器</span></span><br><span class="line">    <span class="comment">//解决源图片，与我们显示的图片大小不一致的问题</span></span><br><span class="line">    <span class="keyword">private</span> PhotoStreamResizer resizer;</span><br><span class="line">    <span class="comment">//3.任务调度</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Future&gt; taskManager = <span class="keyword">new</span> HashMap&lt;Object, Future&gt;();</span><br><span class="line">    <span class="keyword">private</span> Handler backgroundHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二个缓存"><a href="#二个缓存" class="headerlink" title="二个缓存"></a>二个缓存</h3><p>加载图片的流程，感觉是最常问也最重要的知识点了。加载图片，存在二个缓存，内存缓存和磁盘缓存，空间换时间的经典例子了。其中，缓存的实现使用是LRU算法，内部实现可以使用<code>LinkedHashMap</code>，只要将构造方法中<code>accessOrder</code>设为true既可。</p><h3 id="图片大小转换器"><a href="#图片大小转换器" class="headerlink" title="图片大小转换器"></a>图片大小转换器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 有图片地址，有想要图片的大小，故我们需要将原图缩放成指定的大小</span></span><br><span class="line">    <span class="comment">// 转换时耗时的，故这里使用Future来</span></span><br><span class="line">    <span class="comment">// Future个人理解就是可以获得返回结果的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;Bitmap&gt; <span class="title">loadApproximate</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> <span class="keyword">int</span> width, <span class="keyword">final</span> <span class="keyword">int</span> height, ResizeCallback callback)</span></span>&#123;</span><br><span class="line">        Callable&lt;Bitmap&gt; task = <span class="keyword">new</span> Callable&lt;Bitmap&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Utils.streamIn(path, width, height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> startTask(task, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###关于线程切换，这里使用了<code>Handler</code>的例子。<br>比如我们执行转换图片的任务，需要到子线程处理，转换完成后，需要将结果给UI线程来处理接口。<br>如何将一部分实现交给调用者，这里使用了<code>Callback</code>。如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamResizeFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 处理的结果结果需要交给UI线程处理，故需要主线程的handler</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mainHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResizeCallback callback;</span><br><span class="line">    <span class="keyword">private</span> Bitmap result;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.done();</span><br><span class="line">        <span class="keyword">if</span> (!isCancelled())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = get();</span><br><span class="line">                <span class="comment">// 将部分逻辑在UI线程执行</span></span><br><span class="line">                mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callback.onResizeComplete(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callback.onResizeFailed(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片大小转换的具体实现"><a href="#图片大小转换的具体实现" class="headerlink" title="图片大小转换的具体实现"></a>图片大小转换的具体实现</h3><p>感觉缩放图片的大小具体实现挺有意思（见识短，大惊小怪）   </p><p>将变换的逻辑在矩阵上操作，比如放大，设置轴点，再将该变换应用于图片流上，最后便得到我们想要的图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Bitmap&gt; <span class="title">resizeCenterCrop</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> <span class="keyword">int</span> width, <span class="keyword">final</span> <span class="keyword">int</span> height, ResizeCallback callback)</span></span>&#123;</span><br><span class="line">    Callable&lt;Bitmap&gt; task = <span class="keyword">new</span> Callable&lt;Bitmap&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Bitmap result = <span class="keyword">null</span>, streamed = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取到图片流，</span></span><br><span class="line">            streamed = Utils.streamIn(path, width, height);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (streamed.getWidth() == width &amp;&amp; streamed.getHeight() == height) &#123;</span><br><span class="line">                <span class="keyword">return</span> streamed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//from ImageView/Bitmap.createScaledBitmap</span></span><br><span class="line">            <span class="comment">//https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java</span></span><br><span class="line">            <span class="comment">//https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> scale;</span><br><span class="line">            <span class="keyword">float</span> dx = <span class="number">0</span>, dy = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 创建矩阵，将图片流画在矩阵中</span></span><br><span class="line">            Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">            <span class="keyword">if</span> (streamed.getWidth() * height &gt; width * streamed.getHeight()) &#123;</span><br><span class="line">                scale = (<span class="keyword">float</span>) height / (<span class="keyword">float</span>) streamed.getHeight();</span><br><span class="line">                dx = (width - streamed.getWidth() * scale) * <span class="number">0.5f</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                scale = (<span class="keyword">float</span>) width / (<span class="keyword">float</span>) streamed.getWidth();</span><br><span class="line">                dy = (height - streamed.getHeight() * scale) * <span class="number">0.5f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            m.setScale(scale, scale);</span><br><span class="line">            m.postTranslate((<span class="keyword">int</span>) dx + <span class="number">0.5f</span>, (<span class="keyword">int</span>) dy + <span class="number">0.5f</span>);</span><br><span class="line">            Bitmap bitmap = Bitmap.createBitmap(width, height, streamed.getConfig());</span><br><span class="line">            Canvas canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">            Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">            <span class="comment">//only if scaling up</span></span><br><span class="line">            paint.setFilterBitmap(<span class="keyword">false</span>);</span><br><span class="line">            paint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">            canvas.drawBitmap(streamed, m, paint);</span><br><span class="line">            result = bitmap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> startTask(task, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="似乎是一个常见的面试问题的源头"><a href="#似乎是一个常见的面试问题的源头" class="headerlink" title="似乎是一个常见的面试问题的源头"></a>似乎是一个常见的面试问题的源头</h3><p>如何加载一个很大的图片？假设一张原图片像素有10000<em>10000,而我们只需要10</em>10的像素的图片，那么我们不该将整个图片读取下来再缩放成我们想要的大小，而且假设有一个巨大大图片，读取整个图片内存直接爆了。我们是能否将部分图片读取显示呢？</p><p>大佬也遇到了这个问题，也给(google)出了答案。<br>其中，思路是这样的，</p><ol><li>读取图片文件前半部分的字节（16字节足以），获取到该图片的信息，如图片大小</li><li>根据原图大小和想要的大小，算出采样的比例，再次读取是传入采样比例,这样子，读取的图片就只有目标图片所占的内存。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first</span></span><br><span class="line"><span class="comment">//streams in to near, but not exactly at the desired width and height.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">streamIn</span><span class="params">(String path, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Bitmap result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个Opitions来记录图片大小</span></span><br><span class="line">        <span class="keyword">final</span> BitmapFactory.Options decodeBitmapOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        <span class="comment">// For further memory savings, you may want to consider using this option</span></span><br><span class="line">        InputStream first = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(path), <span class="number">16384</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find the dimensions of the actual image</span></span><br><span class="line">        <span class="comment">//获取到原图的实际大小</span></span><br><span class="line">        <span class="keyword">final</span> BitmapFactory.Options decodeBoundsOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        <span class="comment">// 如其所说，仅解码该图片大小</span></span><br><span class="line">        decodeBoundsOptions.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeStream(first, <span class="keyword">null</span>, decodeBoundsOptions); <span class="comment">//doesn't load, just sets the decodeBounds</span></span><br><span class="line">        first.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> originalWidth = decodeBoundsOptions.outWidth;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> originalHeight = decodeBoundsOptions.outHeight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings</span></span><br><span class="line">        <span class="keyword">int</span> sampleSize = Math.min(originalHeight / height, originalWidth / width);</span><br><span class="line">        InputStream second = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(path), <span class="number">16384</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//算出采样比例，并传入作为参数传入下一次解码方法中</span></span><br><span class="line">        decodeBitmapOptions.inSampleSize = sampleSize;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; <span class="number">11</span>) &#123;</span><br><span class="line">            decodeBitmapOptions.inMutable = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(<span class="string">"PSR: Loading image with sample size: "</span> + sampleSize);</span><br><span class="line">        result = BitmapFactory.decodeStream(second, <span class="keyword">null</span>, decodeBitmapOptions);</span><br><span class="line">        <span class="keyword">if</span>(orientation != <span class="number">0</span>) &#123;</span><br><span class="line">            result = Photo.rotateImage(result, orientation);</span><br><span class="line">        &#125;</span><br><span class="line">        second.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        Log.d(<span class="string">"PSR: error decoding image: "</span> + e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError e)&#123;</span><br><span class="line">        Log.d(<span class="string">"PSR: not enough memory to resize image at "</span> + path);</span><br><span class="line">        Log.d(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要明白以上问题的答案，感觉应该查看这个文件。暂且了解以下两个属性吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Options</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 解码器仅查询原图大小，而不会分配内存来保存这些图片的像素</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * If set to true, the decoder will return null (no bitmap), but</span></span><br><span class="line"><span class="comment">                 * the &lt;code&gt;out...&lt;/code&gt; fields will still be set, allowing the caller to</span></span><br><span class="line"><span class="comment">                 * query the bitmap without having to allocate the memory for its pixels.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">boolean</span> inJustDecodeBounds;</span><br><span class="line">       </span><br><span class="line">                <span class="comment">// 采样图片的比例，比如传入4，加载图片有16M, 则加载的图片大小只有1M</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * If set to a value &gt; 1, requests the decoder to subsample the original</span></span><br><span class="line"><span class="comment">                 * image, returning a smaller image to save memory. The sample size is</span></span><br><span class="line"><span class="comment">                 * the number of pixels in either dimension that correspond to a single</span></span><br><span class="line"><span class="comment">                 * pixel in the decoded bitmap. For example, inSampleSize == 4 returns</span></span><br><span class="line"><span class="comment">                 * an image that is 1/4 the width/height of the original, and 1/16 the</span></span><br><span class="line"><span class="comment">                 * number of pixels. Any value &lt;= 1 is treated the same as 1. Note: the</span></span><br><span class="line"><span class="comment">                 * decoder uses a final value based on powers of 2, any other value will</span></span><br><span class="line"><span class="comment">                 * be rounded down to the nearest power of 2.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">int</span> inSampleSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于图片的处理，有挺多盲区的。平常对图片精细的操作很少，诸如上述问题，日常开发App也很少遇到，但是其原理确实应当了解。</p><h2 id="一些零碎的版本追踪"><a href="#一些零碎的版本追踪" class="headerlink" title="一些零碎的版本追踪"></a>一些零碎的版本追踪</h2><p>看到作者作者一步步添加了好多小东西，</p><p>添加Presenter来将Bitmap放置到ImageView</p><p>ImageLoader可以从加载Path和Assets资源文件，抽象成公共的接口</p><p>加载图片的key，缓存使用到，key的生成从加载的大小，加入显示类型，比如center_crop,fit_center</p><p>使用Weak reference避免内存泄漏</p><h2 id="引入android项目后的第一个版本-2013-1-10"><a href="#引入android项目后的第一个版本-2013-1-10" class="headerlink" title="引入android项目后的第一个版本 2013-1-10"></a>引入android项目后的第一个版本 2013-1-10</h2><p>项目使用Flickr网站的图片作为Demo   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity中的一个ListView中的Adapter实现</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View view, ViewGroup container)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ImagePresenter&lt;Photo&gt; presenter;</span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.d(<span class="string">"MyActivity: inflate"</span>);</span><br><span class="line">                ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">final</span> Animation fadeIn = AnimationUtils.loadAnimation(MyActivity.<span class="keyword">this</span>, R.anim.fade_in);</span><br><span class="line">                <span class="comment">// Presenter作为连接ImageView和ImageLoader的桥梁</span></span><br><span class="line">                <span class="comment">// 传入泛型参数包含图片源的基本信息，可以是图片的URL地址或是磁盘地址,这里的Photo包含有了</span></span><br><span class="line">                presenter = <span class="keyword">new</span> ImagePresenter.Builder&lt;Photo&gt;()</span><br><span class="line">                        .setImageView(imageView)</span><br><span class="line">                         <span class="comment">//这里传入一个缓存地址，会优先从磁盘获取的</span></span><br><span class="line">                        .setPathLoader(<span class="keyword">new</span> FlickPathLoader(flickerApi, cacheDir))</span><br><span class="line">                        <span class="comment">// 设置我们的加载ImageLoader哈</span></span><br><span class="line">                        .setImageLoader(<span class="keyword">new</span> CenterCrop&lt;Photo&gt;(imageManager))</span><br><span class="line">                        <span class="comment">// 获取到图片加载到ImageView</span></span><br><span class="line">                        .setImageSetCallback(<span class="keyword">new</span> ImageSetCallback() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageSet</span><span class="params">(ImageView view, <span class="keyword">boolean</span> fromCache)</span> </span>&#123;</span><br><span class="line">                                view.clearAnimation();</span><br><span class="line">                                <span class="keyword">if</span> (!fromCache)</span><br><span class="line">                                    view.startAnimation(fadeIn);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .build();</span><br><span class="line">                imageView.setTag(presenter);</span><br><span class="line">                view = imageView;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                presenter = (ImagePresenter&lt;Photo&gt;) view.getTag();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            presenter.setModel(photos.get(position));</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="看看如何优先从磁盘加载的呢"><a href="#看看如何优先从磁盘加载的呢" class="headerlink" title="看看如何优先从磁盘加载的呢"></a>看看如何优先从磁盘加载的呢</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadPhoto</span><span class="params">(Photo photo, File cacheDir, <span class="keyword">final</span> PhotoCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据photo的信息和缓存地址，定位到对应的文件是否存在哈</span></span><br><span class="line">    File out = <span class="keyword">new</span> File(cacheDir.getPath() + File.separator + photo.id + photo.secret);</span><br><span class="line">    <span class="keyword">if</span> (out.exists()) &#123;</span><br><span class="line">        cb.onDownloadComplete(out.getPath());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.d(<span class="string">"API: missing photo, downloading"</span>);</span><br><span class="line">        <span class="comment">// 开始从网络获取了</span></span><br><span class="line">        downloader.download(getPhotoUrl(photo), out, <span class="keyword">new</span> Downloader.DiskCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDownloadReady</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">                cb.onDownloadComplete(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，我们在看看Downloader是如何加载网络的资源，即download方法,我们找到了Downloader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下载器作为单例存在，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Downloader DOWNLOADER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mainHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其中维护了一个固定6个线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Downloader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HandlerThread workerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"downloader_thread"</span>);</span><br><span class="line">        workerThread.start();</span><br><span class="line">        executor = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        mainHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String url, File out, DiskCallback cb)</span> </span>&#123;</span><br><span class="line">        post(<span class="keyword">new</span> DiskDownloadWorker(url, out, cb));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务放入线程池中启动</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        executor.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个下载任务如何执行的呢</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskDownloadWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"Downloader: run"</span>);</span><br><span class="line">            HttpURLConnection urlConnection = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//朴素的URLConnection打开流</span></span><br><span class="line">                <span class="keyword">final</span> URL targetUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">                urlConnection = (HttpURLConnection) targetUrl.openConnection();</span><br><span class="line">                InputStream in = <span class="keyword">new</span> BufferedInputStream(urlConnection.getInputStream());</span><br><span class="line">                OutputStream out = <span class="keyword">new</span> FileOutputStream(output);</span><br><span class="line">                <span class="comment">//将输入流写入文件</span></span><br><span class="line">                writeToOutput(in, out);</span><br><span class="line">                out.close();</span><br><span class="line">                in.close();</span><br><span class="line">                <span class="comment">//这里，使用mainHandler来切换当前线程到UI线程中执行</span></span><br><span class="line">                mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cb.onDownloadReady(output.getPath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (urlConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    urlConnection.disconnect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToOutput</span><span class="params">(InputStream in, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">while</span> (((bytesRead = in.read(buffer)) != -<span class="number">1</span>)) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Downloader实现了如何从一个URL转变成一个文件，其中，<br>本身作为单例存在，因为我们对于不同的下载，我们是可以复用同一个线程池的。<br>而使用线程池应付多个图片的请求。<br>另外使用了handler在下载完成后切换到UI线程中执行会回调，回调就是执行展示的操作  </p><p>回到Activiy，我们不能忘了我们的主角<code>ImageLoader</code>啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在onCreate方法中创建ImageLoader</span></span><br><span class="line">ImageManager.Options options = <span class="keyword">new</span> ImageManager.Options();</span><br><span class="line">    options.maxMemorySize = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    options.maxPerSize = <span class="number">40</span>;</span><br><span class="line">    imageManager = <span class="keyword">new</span> ImageManager(<span class="keyword">this</span>, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">//并且监听了Activity的生命周期方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    imageManager.resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    imageManager.pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中ImageLoader主要逻辑在第一版本已经说得差不多了，代码逻辑与最差版本相差不是很大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler mainHandler;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LruPhotoCache memoryCache;    <span class="comment">// 内存最近使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ImageResizer resizer;     <span class="comment">//图片大小转换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;        <span class="comment">//线程池调度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Integer&gt; bitmapReferenceCounter = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SizedBitmapCache bitmapCache;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PhotoDiskCache diskCache;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isBitmapRecyclingEnabled;</span><br></pre></td></tr></table></figure><h2 id="Glide名字出生了-2013-7-17"><a href="#Glide名字出生了-2013-7-17" class="headerlink" title="Glide名字出生了 2013-7-17"></a>Glide名字出生了 2013-7-17</h2><p>伴随着项目包名换成<code>glide</code>，不久之后，引入了Glide这个类，普通用户只需要懂得这个类就ok了，想了解原理的人也可以从这个类开始探索~     看看作者的介绍吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Static helper methods/classes to present a simple unified interface for using glide. Allows 90%</span></span><br><span class="line"><span class="comment"> * of the functionality of the library. The trade off is some extra unused object allocation, and a few unavailable</span></span><br><span class="line"><span class="comment"> * methods. For many users this should be enough to make effective use of the library. For others it can serve as a</span></span><br><span class="line"><span class="comment"> * starting point and example. This class is not thread safe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Glide</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接给创建一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Glide GLIDE = <span class="keyword">new</span> Glide();</span><br><span class="line">    <span class="comment">//定义了两个model，可以加载成图片流的源，File or URL</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class, ModelStreamLoader&gt; classToModelStream = <span class="keyword">new</span> HashMap&lt;Class, ModelStreamLoader&gt;() &#123;&#123;</span><br><span class="line">            put(File.class, <span class="keyword">new</span> FileStreamLoader());</span><br><span class="line">            put(URL.class, <span class="keyword">new</span> UrlStreamLoader());</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    <span class="comment">//之前的大名隐匿于此了</span></span><br><span class="line">    <span class="keyword">private</span> ImageManager imageManager;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Manages building, tagging, retrieving and/or replacing an ImagePresenter for the given ImageView and model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; The type of model that will be loaded into the view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//如何将图片源，加载到的目标ImageView的统一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> T model;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ImageView imageView;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ImagePresenter&lt;T&gt; presenter;</span><br><span class="line">        <span class="keyword">private</span> ImagePresenter.Builder&lt;T&gt; builder;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(T model, ImageView imageView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">            <span class="keyword">this</span>.imageView = imageView;</span><br><span class="line">            <span class="keyword">this</span>.context = imageView.getContext();</span><br><span class="line"></span><br><span class="line">            presenter = (ImagePresenter&lt;T&gt;) imageView.getTag(R.id.image_presenter_id);</span><br><span class="line">            builder = <span class="keyword">new</span> ImagePresenter.Builder&lt;T&gt;()</span><br><span class="line">                    .setImageView(imageView)</span><br><span class="line">                    .setImageLoader(<span class="keyword">new</span> Approximate(getImageManager()));</span><br><span class="line"></span><br><span class="line">            ModelStreamLoader&lt;T&gt; loader = classToModelStream.get(model.getClass());</span><br><span class="line">            <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                builder.setModelStreamLoader(loader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>期间作者改了好多次类名哦，并加了很多注释<br>对于线程安全方面，一些关键方法加了syschronized关键字，或是改用了concurrent包中的集合<br>在加载图片的公开方法上，出现了大致的轮廓，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Glide.load(current)</span><br><span class="line">                    .into(viewHolder.imageView)</span><br><span class="line">                    .with(<span class="keyword">new</span> DirectFlickrStreamLoader(api))</span><br><span class="line">                    .centerCrop()</span><br><span class="line">                    .animate(R.anim.fade_in)</span><br><span class="line">                    .begin();</span><br></pre></td></tr></table></figure><p>使用Vollery in UrlLoader<br>添加一些测试为了方便，图片源添加一个<code>StringLoader</code>，其内部是转换成UrlLoader</p><p>对于UrlLoader，因为最终都是要打开流的，故存在了StreamLoader接口<br>其功能就是打开流，并定义了Callback,用于打开成功或失败的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StreamLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StreamReadyCallback</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStreamReady</span><span class="params">(InputStream is)</span></span>;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span></span>;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadStream</span><span class="params">(StreamReadyCallback cb)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么图片流的来源可分为两类，本地的和远程的<br>本地的指Android定义流，如Assert读取的文件，提供的协议头 content：file:远程的包括http和https</p><h2 id="允许加载任意的Transformation和加载image通任意的目标"><a href="#允许加载任意的Transformation和加载image通任意的目标" class="headerlink" title="允许加载任意的Transformation和加载image通任意的目标"></a>允许加载任意的Transformation和加载image通任意的目标</h2><p>这个两个功能确实为该框架添加了很多色彩啊  </p><p>设置转场动画，比如加载图片时，需要设置fadeIn加载的动画，看起来确实很舒服,以及暴露了可以加载自定义动画</p><p>新添加了<code>Target</code>的概念，这个概念我第一次遇到确实蒙的</p><p>Target是定义了可以防止图片的目标，需要处理</p><pre><code>//图片准备好了时该怎么展示啊public void onImageReady(Bitmap bitmap);//占位图片啊，要注意这里的占位图是包括加载前和加载失败的，在不同状态时，Glide会设置不同的图片public void setPlaceholder(Drawable placeholder);//获取到该目标能显示多大的图片，如ImageView的wrap_content时，是需要异步的等待结果的public void getSize(SizeReadyCallback cb);//可选性的提供转场动画public void startAnimation(Animation animation);//获取和设置Presenterpublic void setImagePresenter(ImagePresenter imagePresenter);public ImagePresenter getImagePresenter();</code></pre><p>总的看，就是一个能放置图片的玩意，应该具备有什么能力(方法)</p><p>看完这个<code>Target</code>，再看<code>Presenter</code>吧</p><p>Presenter跟Android中的MVP中P概念是一致的，<br>持有View，负责捉取图片，和加载正确大的图片，即使View回收时类型参数中的T就是Model，定义了图片的来源，这里看看设置Model的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets a model to load an image from. Each subsequent call will override all previous calls and will prevent any</span></span><br><span class="line"><span class="comment"> * bitmaps that are loaded from previous calls from being displayed even if the load completes successfully. Any</span></span><br><span class="line"><span class="comment"> * image being displayed at the time of this call will be replaced either by the placeholder or by the new image</span></span><br><span class="line"><span class="comment"> * if the load completes synchronously (ie it was in an in memory cache)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *     Note - A load will not begin before the ImagePresenter has determined the width and height of the wrapped</span></span><br><span class="line"><span class="comment"> * view, which can't happen until that view has been made visible and undergone layout out for the first time. Until</span></span><br><span class="line"><span class="comment"> * then the current load is stored. Subsequent calls will replace the stored load</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model The model containing the information required to load a path and/or bitmap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModel</span><span class="params">(<span class="keyword">final</span> T model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">        clear();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!model.equals(currentModel)) &#123;</span><br><span class="line">        loadedFromCache = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> loadCount = ++currentCount;</span><br><span class="line">        currentModel = model;</span><br><span class="line">        isImageSet = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//需要target定好自己的大小后，才会真正加载图片</span></span><br><span class="line">        target.getSize(<span class="keyword">new</span> Target.SizeReadyCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">                fetchImage(model, width, height, loadCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        loadedFromCache = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isImageSet) &#123;</span><br><span class="line">            resetPlaceHolder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fetchImage</span><span class="params">(<span class="keyword">final</span> T model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">final</span> <span class="keyword">int</span> loadCount)</span> </span>&#123;</span><br><span class="line">    imageLoader.clear();</span><br><span class="line">    <span class="keyword">final</span> String id = modelLoader.getId(model);</span><br><span class="line">    <span class="keyword">final</span> StreamLoader sl = modelLoader.getStreamLoader(model, width, height);</span><br><span class="line">    <span class="keyword">final</span> Transformation t = transformationLoader.getTransformation(model);</span><br><span class="line">    <span class="comment">//使用ImageLoader来加载图片</span></span><br><span class="line">    imageToken = imageLoader.fetchImage(id, sl, t, width, height, <span class="keyword">new</span> ImageLoader.ImageReadyCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onImageReady</span><span class="params">(Bitmap image)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (loadCount != currentCount || !canSetImage() || image == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (imageReadyCallback != <span class="keyword">null</span>)</span><br><span class="line">                imageReadyCallback.onImageReady(target, loadedFromCache);</span><br><span class="line">            target.onImageReady(image);</span><br><span class="line">            isImageSet = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> relevant = loadCount == currentCount;</span><br><span class="line">            <span class="keyword">if</span> (exceptionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                exceptionHandler.onException(e, model, relevant);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若是设置错误的占位图，则会显示啊</span></span><br><span class="line">            <span class="keyword">if</span> (relevant &amp;&amp; canSetPlaceholder()) &#123;</span><br><span class="line">                target.setPlaceholder(errorDrawable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="暂且看到版本2013-8-31"><a href="#暂且看到版本2013-8-31" class="headerlink" title="暂且看到版本2013-8-31"></a>暂且看到版本2013-8-31</h2><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>好累哦，感觉继续看下去自己脑子要糊了~~</p><p>2013年，有些遥远了啊，想想当时自己还没上大学呢。</p><p>考古的感觉是如何的呢？  </p><p>看着大佬的一步步的从简单的版本一步步到2013-8这个版本，也快一年的工作量，消化不过来了。最初的版本的有个操作，读取文件流仅却不加载到内存的操作，为了获取到图片源的大小，故，可以根据需要展示的图片大小，通过设置采样，不必加载整个文件，就可以加载出我们所需的图片。</p><p>这个操作在android官方文档似乎就有看到呢，且在国内的知名Android博主的文章也提及。而当自己在源码中看到这个真实的代码时，自己确实有些许激动的。</p><p>另个一个感触是，看到开始的这些版本，感觉作者的代码，自己也是大致能完全理解的哈，Glide一步步成为知名框架，是有迹可循的。开始的代码，作者写的也很朴素，之后代码逐渐重构清晰。结合自己看的EventBus源码，感觉大佬的炼成之路真的需要坚持啊。</p><p>另外，教训，感觉之后的源码需要切入某个方面来看，否则好难坚持。</p><p>比如作者添加错误的占位图这个功能时，根据作者写的commit，看的时候，思路就会清晰点。(小提示，以后自己提的commit也要用心点)</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用注解为部分接口添加加密逻辑</title>
      <link href="/2020/06/13/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E4%B8%BA%E9%83%A8%E5%88%86%E6%8E%A5%E5%8F%A3%E6%B7%BB%E5%8A%A0%E5%8A%A0%E5%AF%86%E9%80%BB%E8%BE%91/"/>
      <url>/2020/06/13/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E4%B8%BA%E9%83%A8%E5%88%86%E6%8E%A5%E5%8F%A3%E6%B7%BB%E5%8A%A0%E5%8A%A0%E5%AF%86%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.v2ex.com/t/681294#r_9111029" target="_blank" rel="noopener">使用了 HTTPS 的网络请求， 其中 JSON 数据有必要做额外的加密吗?</a><br>个人疑惑，故在v2ex提了这个问题，大家讨论挺热闹的。</p><p>另外，根据一个网友的评论，收获一篇好文.<a href="https://www.cnblogs.com/yaowen/p/10448603.html" target="_blank" rel="noopener">HTTPS实战之单向验证和双向验证</a></p></blockquote><p>##问题描述及解决</p><p>需要对部分接口中的JSON数据加密，由于仅是部分接口需要处理，故想到用注解来标记需要加密的接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器返回的基础类</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span>&lt;<span class="type">Data</span>&gt;</span>(</span><br><span class="line">    <span class="keyword">val</span> code: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> msg: String?,</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: Data? <span class="comment">// </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>Data</code>是个泛型，不同接口对应着不同类型，在没有加密逻辑时，该JSON数据中<code>data</code>就是相应的JSON对象。</p><p>添加加密逻辑后，<code>data</code>成了加密过后的密文，类型是<code>String</code>, 故想要反序列出我们想要的<code>Data</code>对象，我们需要多一个<strong>额外操作</strong>，先将该密文解密成相应的json，后续使用<code>Gson</code>反序列既可。</p><p>具体步骤<br>1，标记需要加密的接口  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@POST</span>(<span class="string">"public/login"</span>)</span><br><span class="line"><span class="meta">@EncryptStatic</span>  <span class="comment">//使用该注解来标记该接口加密</span></span><br><span class="line"><span class="function">fun <span class="title">test_login</span><span class="params">(@Body requestBody: RequestBody)</span>:Observable&lt;BaseModel&lt;LoginResult&gt;&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个Converter，用于将JSON数据转换成我们想要的对象</span></span></span><br></pre></td></tr></table></figure><p>2，获取接口方法中的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">                                                        Retrofit retrofit) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">    <span class="keyword">int</span> encrypt = <span class="number">0</span>;    <span class="comment">// 用该变量标记加密类型，0，则无加密，1则需机密</span></span><br><span class="line">    <span class="keyword">if</span> (annotations.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            <span class="comment">//查找注解集合中是否存在加密注解</span></span><br><span class="line">            <span class="keyword">if</span> (annotation.annotationType() == EncryptStatic.class) &#123;</span><br><span class="line">                encrypt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation.annotationType() == EncryptDynamic.class) &#123;</span><br><span class="line">                encrypt=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomizeGsonResponseBodyConverter&lt;&gt;(gson, adapter,encrypt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，为对应的注解添加我们的<strong>额外操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//把responsebody转为string</span></span><br><span class="line">    String response = value.string();</span><br><span class="line">    BaseModel baseResponse = gson.fromJson(response, BaseModel.class);</span><br><span class="line">    <span class="keyword">if</span> (encryptType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 将密文解密成对应的Json字符串</span></span><br><span class="line">        String dataStr = EncryptExtKt.aesDecrypt(Objects.requireNonNull(baseResponse.getData().toString()), <span class="string">"&#125;);</span></span><br><span class="line"><span class="string">        // 以下3行实际是拼凑json字符串</span></span><br><span class="line"><span class="string">        T data=gson.fromJson(dataStr, new TypeToken&lt;T&gt;()&#123;&#125;.getType());</span></span><br><span class="line"><span class="string">        baseResponse = new BaseModel(baseResponse.getCode(), baseResponse.getMsg(), data);</span></span><br><span class="line"><span class="string">        response = gson.toJson(baseResponse, BaseModel.class);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    try &#123;</span></span><br><span class="line"><span class="string">        // 将json数据反序列化了哈</span></span><br><span class="line"><span class="string">        return adapter.fromJson(response);</span></span><br><span class="line"><span class="string">    &#125; finally &#123;</span></span><br><span class="line"><span class="string">        value.close();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>##总结</p><p>大概就是这个流程，在json和对象转换之间插入加解密，第一份工作的项目写过这个逻辑，现在不过是加了一个注解。另外，回头看了第一个项目时，发觉自己代码规范居然变糟糕了~</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三个经典排序算法</title>
      <link href="/2020/06/13/%20%E4%B8%89%E4%B8%AA%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/06/13/%20%E4%B8%89%E4%B8%AA%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>面试常聊的几个排序算法，总结整理一下，</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>目前感觉，最有趣也最有挑战的排序<br>思路：  </p><p>将数组视为完全二叉树，其父子关系使用下标确定，<br>root -&gt; left<br>arr[left] = arr[root * 2 +1] (下标从0开始哈)<br>构建大根堆, 所有的二叉树都满足<br>根节点 &gt; ( 左节点 | 右节点 )</p><p>将一个数组构建成一个大根堆，具体操作（堆化操作）<br>假设左右子树都是大根堆，<br>则选择左右节点较大的，与根节点比较：<br>若是小于根节点，符合要求，返回<br>若是大于根节点，则交换根节点和该节点<br>    交换后，该子树需要继续 堆化操作，直至到以下所有子树都符合要求</p><p>堆化操作的<strong>前提</strong>是需要其子树都符合堆的要求，<br>故，将一个源数组堆化，需要从底部的树开始，从下往上，从右往左，依次讲个所有的子树堆化，最后整个二叉树也就堆化了  </p><p>堆化后，假设是大根堆，我们求其正序   </p><p>第一个元素是最大元素，我们选择好该最大元素，与最后一个元素交换，接着，继续堆化nums[0,n-2],num[n]已经排好序了<br>重复以上</p><p>可以看到, 堆排序是选择排序的优化哈</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参考 https://www.cnblogs.com/chengxiao/p/6129630.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 堆排序，首先要求时完全二叉树，使用数组的存储结构，叶子节点只会在倒数第二层出现</span></span><br><span class="line"><span class="comment"> * 大根堆，节点值均小于根节点</span></span><br><span class="line"><span class="comment"> * 使用数组存储结构时，根节点与子节点关系可以通过下标换算的，arr[left] = arr[root*2+1] , arr[right] = arr[root*2+2]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">object</span> HeapSort &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">heapSort</span><span class="params">(arr: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//        val arr = intArrayOf(4, 6, 8, 5, 9)</span></span><br><span class="line">        arr.println()</span><br><span class="line">        <span class="keyword">val</span> len = arr.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> len / <span class="number">2</span> - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            adjustHeap(arr, i, len)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> len - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            arr.swap(<span class="number">0</span>, k)</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, k)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.println()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以firstRoot开始，使得该节点为最大值</span></span><br><span class="line">    <span class="comment">//注意该调整有个前提，其左右子树已经是个大根堆了</span></span><br><span class="line">    <span class="comment">//故，初始化一个大根堆，则需要最后一个非叶子节点开始，从下往上，从左往右迭代调整</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">adjustHeap</span><span class="params">(arr: <span class="type">IntArray</span>, firstRoot: <span class="type">Int</span>, len: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> root = firstRoot</span><br><span class="line">        <span class="keyword">val</span> max = arr[firstRoot]    <span class="comment">//其实我们就是要找最大的元素</span></span><br><span class="line">        <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            k = root * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (k &lt; len) &#123;</span><br><span class="line">                <span class="comment">//要找到左右节点中较大的哦</span></span><br><span class="line">                <span class="keyword">if</span> (k + <span class="number">1</span> &lt; len &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                    k++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (arr[k] &gt; max) &#123;    <span class="comment">//若是存在叶子节点比root大的情况</span></span><br><span class="line">                    arr[root] = arr[k]</span><br><span class="line">                    root = k    <span class="comment">//root指向该叶子节点，继续循环以该root为节点的树</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (k &lt; len)</span><br><span class="line">        arr[root] = max</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>思路：<br>选择一个中轴，将一个数组分为两部分，使得左边比中轴小，右边比中轴大<br>实际操作中，将第左边界的第一个值设为中轴，迭代访问后面的元素，若是发现比中轴小，则将该元素插入到中轴左侧</p><p>针对左右两部分，递归使用以上操作，递归终止在，对应操作的数组只有一个元素时。  </p><p>时间复杂度，递归深度是log<sub>2</sub>n故，时间复杂度是 nlog<sub>2</sub>n  空间复杂度，递归使用了栈空间，故 log<sub>2</sub>n</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">quickSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        helper(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">helper</span><span class="params">(nums: <span class="type">IntArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> pivot = left</span><br><span class="line">        <span class="keyword">var</span> start = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> end = right</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            println(<span class="string">"pivot:<span class="subst">$&#123;nums[pivot]&#125;</span>,check <span class="subst">$&#123;nums[start]&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt; nums[pivot]) &#123;</span><br><span class="line">                <span class="comment">//把当前数插入到左端</span></span><br><span class="line">                moveToHead(nums, left, start)</span><br><span class="line">                <span class="comment">//轴也会右移</span></span><br><span class="line">                pivot++</span><br><span class="line">            &#125;</span><br><span class="line">            start++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每一遍结束，pivot都能划分[left,right]</span></span><br><span class="line">        nums.println()</span><br><span class="line"></span><br><span class="line">        helper(nums, left, pivot - <span class="number">1</span>)</span><br><span class="line">        helper(nums, pivot + <span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数组翻转一位</span></span><br><span class="line">    <span class="comment">//这里效率很低啊</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToHead</span><span class="params">(nums: <span class="type">IntArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> temp = nums[right]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> right downTo left + <span class="number">1</span>) &#123;</span><br><span class="line">            nums[i] = nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>append: 避免移动元素的快排，</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end;</span><br><span class="line">    <span class="comment">// 将中轴取出来，将其保存至变量pivot,随之arr[i]这个坑空出来了</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右往左寻找第一个比中轴小的数，找到其</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        <span class="comment">// 同样，从左边开始，寻找第一个比中轴大的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        System.out.println(<span class="string">"i "</span> + i + <span class="string">", j "</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时i == j</span></span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    quickSort(arr, start, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>思路：  </p><p>1，拆分<br>针对数组，以下标中点将数组划分为左右两部分<br>针对左右两部分，重复以上操作，直至该数组只有一个元素，(递归出口，一个元素是有序的)</p><p>2，合并<br>将拆分的两个部分，两者都是有序数组，合并成一个有序数组<br>重复以上</p><p>关于合并两个有序数组的优化取巧，若是第一个数组中最大的元素比第二数组中最小的元素还小，可直接拼接  </p><p>LeetCode中相关的题目，求数组中的逆序对</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> MergeSort &#123;</span><br><span class="line">    <span class="comment">//另外，可以利用归并排序的稳定性，</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> copy = nums.copyOf()</span><br><span class="line">        helper(nums, copy, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">helper</span><span class="params">(nums: <span class="type">IntArray</span>, copy: <span class="type">IntArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">        helper(nums, copy, left, mid)</span><br><span class="line">        helper(nums, copy, mid + <span class="number">1</span>, right)</span><br><span class="line">        mergeArr(nums, copy, left, mid, right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序的数组，为了避免每次都要创建一个字数组来保存，</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeArr</span><span class="params">(nums: <span class="type">IntArray</span>, copy: <span class="type">IntArray</span>, left: <span class="type">Int</span>, mid: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        nums.println()</span><br><span class="line">        println(<span class="string">"mid:<span class="subst">$&#123;nums[mid]&#125;</span>, left:<span class="subst">$&#123;nums[left]&#125;</span>, right:<span class="subst">$&#123;nums[right]&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依赖上一次合并状态</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> left..right) &#123;</span><br><span class="line">            copy[i] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> i = left</span><br><span class="line">        <span class="keyword">var</span> j = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> k = left</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy[i] &lt;= copy[j]) &#123;</span><br><span class="line">                nums[k++] = copy[i++]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k++] = copy[j++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            nums[k++] = copy[i++]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            nums[k++] = copy[j++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p><a href="https://github.com/wjploop/LeetCode" target="_blank" rel="noopener">github代码</a></p></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近半年做了什么呢</title>
      <link href="/2020/06/05/%E6%9C%80%E8%BF%91%E5%8D%8A%E5%B9%B4%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2/"/>
      <url>/2020/06/05/%E6%9C%80%E8%BF%91%E5%8D%8A%E5%B9%B4%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2/</url>
      
        <content type="html"><![CDATA[<p>回顾自己过去半年，很揪心，折腾了挺多东西，但实际上似乎什么事都没干成。下面罗列下自己做了什么。   </p><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>看到日渐火热的新东西，很开心地去折腾了。期间主要看了三个项目：<br><a href="https://github.com/flutter/gallery" target="_blank" rel="noopener">官方Gallery</a><br><a href="https://github.com/boyan01/flutter-tetris" target="_blank" rel="noopener">俄罗斯方块游戏(代码风格特别好)</a><br><a href="https://github.com/asjqkkkk/flutter-todos" target="_blank" rel="noopener">每日清单Todo</a><br>个人感觉，flutter构建页面的思维是比原生Android舒服很多的，其中令我感触最深的有两个例子：</p><h3 id="动画的实现"><a href="#动画的实现" class="headerlink" title="动画的实现."></a>动画的实现.</h3><p>Tween思想实现一个动画，假设我们需要一个移动动画，我们只需要定义一个起点，终点，以及一个时间插值器，如此，便可完成了。<br>相比于原生，动画实现的编码思维用的面向过程，但在flutter中，我们是面向概念的，或者说面向对象的。<br>这种思维方式的转变，我们可以站在更高层次来思考。</p><h3 id="页面路由的使用"><a href="#页面路由的使用" class="headerlink" title="页面路由的使用"></a>页面路由的使用</h3><p>在前端中，页面路由是很常见的开发工作了，flutter引用了web端的路由方式。使用之后，难免有些许嫌弃原生的实现方式了。Android中，我们想要监听系统的一些事件，通常是在相应的生命周期方法中，加入自己相应的处理逻辑。相应的，我们在跳转页面返回时，也沿用了这个方式，在<code>onActivityResult</code>中处理页面返回值。  </p><p>这里，我认为最大的问题是，启动页面和处理页面返回值的逻辑分开了，本该连贯的思路分裂开，对于代码的书写和后期查看维护，添加了难度。   </p><p>我想这个问题是原生普遍存在的，故出现RxActivity，RxPermission，RxPickImage这样的库，它们存在都是为了使一个套处理逻辑尽可能的内聚。个人认为这些思想是进步的，终将会该替代原先的思维。Flutter作为新生事物，在框架层面引入这些思想，使用上确实令人舒服。</p><hr><h2 id="刷题LeetCode"><a href="#刷题LeetCode" class="headerlink" title="刷题LeetCode"></a>刷题LeetCode</h2><p>近一个月来坚持着每日一题的任务，目前刷了133道，前期很多题目根本没有思路，直接看题解了，现在也就会一些简单的套路题吧。</p><p>有什么体会呢？ 了解一些常见的概念，动态规划，双指针，滑动窗口，二叉树操作等等，对于边界处理也有点经验，感觉学到的东西蛮多的，有种当年高中数学题的感觉，评论区也挺有趣的，膜拜各路大佬。</p><p>记得毕业时（两年过去了）有个大佬跟我说了一道题，<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs" target="_blank" rel="noopener">使用最小花费爬楼梯</a> ,当时，第一次听说LeetCode刷题，听着迷迷糊糊的。后来，去面试一家小公司，恰好问了这道题，自己也没有做出来，现在想，要是当时准备准备就好了。    </p><p>这道题是这样子的。  问：每个台阶有一个数值，代表着站在上面消耗的体力，以数组costs表示，人每次可以选择跳跃1个或2个台阶，问越过所有的台阶最小的代价是多少？  </p><p>要想跳到第n阶，即站在第n个台阶，之前必须经过第n-1或n-2台阶，定义f(i)为跳到第i阶的最小代价，而f(i) = min( f(i-1), f(i-2) ) 故问题求的问题就是求f(n)，使用递归</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> costs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> min(costs[<span class="number">0</span>],costs[<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min(f(i-<span class="number">2</span>)+costs[i], f(i-<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最朴实的方法，方法调用栈的高度会达到O(n)，而且我们求f(n)时，递归求f(n-2)和f(n-1)，而f(n-1)又会求f(n-2)，这样，我们会发现f(n-2)调用两次，而f(n-3) 调用了3次，以此类推，后面都会进行重复的不必要计算。</p><p>故，我们可以引用备忘录或缓存的避免重复计算这个问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(i,map)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> costs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> min(costs[<span class="number">0</span>],costs[<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//若是已经求过f(i),则直接从缓存取出</span></span><br><span class="line">  <span class="keyword">if</span>(mpa.contains(i))&#123;</span><br><span class="line">  <span class="keyword">return</span> map[i]</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">val</span> res = min(f(i-<span class="number">2</span>)+costs[i], f(i-<span class="number">1</span>))</span><br><span class="line">  <span class="comment">//将结果放入缓存</span></span><br><span class="line">  res[i] = res;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步的，目前我们解决问题的思路是，以求f(n)，作为我们的最终问题，然后将当前问题划分两个小问题f(n-2),f(n-1)，之后一步步将问题分解成我们能够求的问题，即递归的边界f(0)和f(1) 。可以说，这是递归的思路，相应的，还有迭代的思路。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun f(i)&#123;</span><br><span class="line">val dp = IntArray(n+1)//定义dp[i]</span><br><span class="line">dp[0] = costs[0];</span><br><span class="line">dp[1] = min(costs[0],costs[1]);</span><br><span class="line"></span><br><span class="line">for(i in 2..n+1)&#123;</span><br><span class="line">d[i] = min( f(n-2)+costs[i], dp[i-1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 结果</span><br><span class="line">return dp[n+1]</span><br></pre></td></tr></table></figure><p>迭代，也是经典动态规划过程，每个子问题求解都要依赖上一个状态的结果，依次迭代，最终得出我们目标问题的答案。这里还有比较玄乎的称呼(对于我来说，有待理解体会)，自下而上思路，而递归就是自上而下。</p><h2 id="Android原生"><a href="#Android原生" class="headerlink" title="Android原生"></a>Android原生</h2><h3 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h3><p>迫于好奇心，初略了解了下这个框架。  </p><p>原理，通过替换系统内app_process文件，使得Zygote进程启动时加载XposedBridge的jar包，而之后所有的进程都是从Zygote进程孵化出来的，之后所有App的方法调用都可以添加监听，插入自己所需的逻辑。</p><p>原理还是一知半解，想起来了以前看过的AOP面向切面，找到一个固定的方法，通过反射在方法调用前处理入参，加入或改变方法内的逻辑，改变方法返回值等等，也叫做hook某个方法。在实际写自己的模块时，找到hook点是挺关键的。</p><p>后来为什么不更新了呢？  </p><p>在Xposed仅支持7.0之前的版本，作者在xda论坛上声称，由于7.0之后采用aot技术，ahead of runtime，在程序执行前就将字节码转换为与平台有关的二进制代码，故我们不能在java运行时获取到相应的hook点。后来也有一些库将aot直接禁用来达到继续hook的目的，但这也使得程序性能降低。</p><h3 id="Android嵌套滑动机制"><a href="#Android嵌套滑动机制" class="headerlink" title="Android嵌套滑动机制"></a>Android嵌套滑动机制</h3><p>Android在5.0引入了嵌套滑动，来实现在嵌套滑动中处理。  </p><p>在事件分发中，在一套流程中(down开始，up结束)，选择消费的View只能有一个，不能存在子View消费一半的滑动距离后，然后又转移给父级View消费。而这个机制就是为解决这类问题的，应用这个机制可以将<code>TabLayout</code>作为一个粘性头部。</p><p>其大概用法跟很多XXHelper思路一样，询问你要不要处理，处理逻辑，处理完后要不要继续传给后者。</p><p>另外CoordinatorLayout中的Behavior也是结合该机制一起使用的。</p><h2 id="夭折的小项目"><a href="#夭折的小项目" class="headerlink" title="夭折的小项目"></a>夭折的小项目</h2><p>有想法做一个自己的项目，情侣卡片。  </p><p>初衷是服务情侣之间的比较浪漫承诺，比如答应一段大餐，7天不准吵架，允许打1小时游戏，等等。</p><p>个人觉得挺好玩的，也看到知乎有个一些情侣确实用纸片卡片这么玩。  </p><p>然后我就动手了</p><ul><li><input checked disabled type="checkbox"> 实现了卡片滑动效果</li><li><input checked disabled type="checkbox"> 编辑卡片包括设置卡片颜色，或选择背景图片，输入文字</li><li><input checked disabled type="checkbox"> 全局使用自定义的卡通文字</li><li><input checked disabled type="checkbox"> 使用<code>Room</code>来保存数据</li><li><input disabled type="checkbox"> 将卡片发送给对方</li><li><input disabled type="checkbox"> UI设计（太丑了）</li></ul><p>如何将卡片发送给对方呢？  </p><p>第一个想法是使用局域网内互传，但想到很多异地恋的，否决。  </p><p>故想到用google的Firebase套件，因为自己学Flutter时敲过一个投票项目，换成Kotlin原生时，发现有挺多问题，卡着这个地方了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记项目中接触Https的经历</title>
      <link href="/2020/05/25/%E8%AE%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%8E%A5%E8%A7%A6Https%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
      <url>/2020/05/25/%E8%AE%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%8E%A5%E8%A7%A6Https%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>服务端接入了一个加速服务，导致Android端请求不了服务器，抛出了该异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor <span class="keyword">for</span> certification path not found.</span><br></pre></td></tr></table></figure><p>初看，SSL握手失败，原因：在该信任的证书源中未找到该证书。拿着异常信息搜索，查到该<a href https: blog.csdn.net moonloong article details 79760428"">博客</a> ， 如博客所说。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>由于服务器使用的使用的证书不是正规CA签发的，而是二级代理商签发的证书，导致验证通过。</p><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ol><li>后台更换正规的证书，或客户端存放一个相应的证书源,具体操作参考<a href="https://www.jianshu.com/p/a2b01828f0e5" target="_blank" rel="noopener">BKS的制作</a></li><li>忽略https的证书校验，信任所有的证书</li></ol><p>当时为了方便快，直接选中了第二种方案，忽略了潜在的风险，短暂解决了问题。</p><p>风险：<br>信任所有证书，将导致任何人都可以做中间人攻击。参考<a href="https://stackoverflow.com/questions/6825226/trust-anchor-not-found-for-android-ssl-connection" target="_blank" rel="noopener">StackOverflow</a></p><p>而今，这个事情并未结束，并不是因为遭遇中间人攻击，而是，发现尽管服务器使用了http 2.0 版本，却发现客户端与服务器的tcp连接个数很多，tcp连接并没有能复用支持多个http请求。没能复用，故客户端与服务器之间存在保持多个连接，对服务器造成了压力。</p><blockquote><p>http1.0 本身tcp与http是一对一的关系<br>http1.1 支持connection: keep-alive ，可以复用tcp连接支持多个http请求，但在同一时刻只能处理一个请求，即两个http请求，需要等待第一个请求完成后才能下一个请求，尽管还有pipelining属性支持支持流水线，可是在浏览器中默认是关闭的。http2.0支持多路复用，单个tcp必然可以支持多个http请求的</p></blockquote><p>而我们发现，服务器使用了支持了HTTP2.0，为什么tcp没有能支持多个http请求呢？IOS存在2个tcp连接，而android却有6，7个连接。</p><p>对此，我怀疑，</p><ol><li><p>因为在C/S双方使用中，http实际使用的版本由两者支持的最低版本决定，是不是因为安卓端使用的是2.0以下的版本，故导致不能复用连接的，但捉包后却发现android的连接也是http2，判断失误了。</p></li><li><p>项目中存在了两个OkHttpClient实例，还有一个Glide默认的HttpUrlConnection… 瞎猜，尝试将这三者统一使用一个OkHttpClient之后，发现还是没有解决问题</p></li></ol><p>后来，第三方加速服务那边说，捉包查看tcp连接时，存在RST包，怀疑是SSL的问题，我回想到原来处理证书的问题，将忽略验证的方式改成了方案一App提供一个内置的证书，解决问题。</p><h3 id="Https-回顾总结"><a href="#Https-回顾总结" class="headerlink" title="Https 回顾总结"></a>Https 回顾总结</h3><p>依赖非对称加密<br>公钥私钥，一者加密的内容需要另一方解密，服务器保存私钥，客户端保存公钥<br>这样，这样客户端发送的信息只有服务才能解密查看</p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>正常是C向服务器请求pub_S，然后C使用这个公钥pub_S与服务器通信<br>可以若是存在一个中间人M在C和S之间,<br>当请求通信时，中间人自己生成了一对密钥，pub_M,pri_M,这样，客户端使用了pub_m来加密，而中间人转发请求时用了pub_m加密，这样，通信内容全被中间知道了。</p><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>服务器的合法性需要证书机构来确定，服务器提供公钥以及一些信息向CA申请证书，<br>C请求S后，S会返回其证书，C根据CA验证服务器的合法性  </p><p><a href="https://juejin.im/post/5c66cc1e6fb9a049c84ffd12" target="_blank" rel="noopener">参考</a></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>客户端发送一个包，SYN标志位为1，初始化一个序列号seq<br>服务端针回复一个包，SYN,ACK标志位为1，确认序号ack为收到序号加一，同时也初始化一个序列号seq<br>客户端回复一包，ACK为收到序列号加一<br>由此，三次握手完成<br>简单说，客户端你发送一个syn包，服务器回复一下SYN+ACK包客户端再回复一个ACK包</p><h4 id="为什么是三次而不是两次？"><a href="#为什么是三次而不是两次？" class="headerlink" title="为什么是三次而不是两次？"></a>为什么是三次而不是两次？</h4><p>若是第二次握手之后，服务器就开辟资源，可能会浪费资源客户端发送第一个包后，会根据估计的往返时间来等待SYN-ACK包，若是时间超出了预期，客户端就会自己没有发送个第一个包，收到了服务器的包，也不会建立连接，而服务器若是在第一个包后就建立了连接，就会导致仅有自己建立了连接</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>双方都处于连接建立状态,established,<br>假设客户端想要关闭连接，发送一个FIN标志位为1，和一个序列号假设为100，进入fin-wait-1状态，此时不会主动再发新的数据包，但保持接受包的能力<br>服务端回复一个确认号也为100的包，表示收到对方要关闭连接请求，进入close-wait状态，通知上层不能发新的包了，但会将队列发送的包发完<br>服务端发完队列中包后，发一个FIN标志位1的包，通知客户端这是我最后一个发的包，进入last-ack状态，只需要确认关闭通知发给了客户端<br>客户端收到后FIN包后，确认接受完对方所有的包了，表示也关闭接收包的能力，发一个包让知道服务端知道客户端也正常关闭了</p><p>第一次挥手，发送一个fin包服务端收到后,会回一个ack包，然后继续发送完自己的数据包，等数据包发送完毕后，发一个fin包给客户端表示自己也可以关闭了客户端收到fin包后，会回复一个ack包给服务端，并进入一个等待时间，时间到会关闭连接，服务器收到这个确认包后也会直接关闭连接</p><p>为什么有4次挥手？<br>因为被动关闭连接的一方收到关闭请求后，还需要发送完数据包，才能发fin包，就是说，被动关闭的一方，需要将ack包和fin分开发送，当然没有数据包时，也可以简化为3三次<a href="https://blog.csdn.net/a_tu_/article/details/80389878" target="_blank" rel="noopener">参考</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666539134&idx=1&sn=5166f0aac718685382c0aa1cb5dbca45&scene=5&srcid=0527iHXDsFlkjBlkxHbM2S3E#rd" target="_blank" rel="noopener">好文</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus整体思路和优化</title>
      <link href="/2019/12/10/EventBus%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%E5%92%8C%E4%BC%98%E5%8C%96/"/>
      <url>/2019/12/10/EventBus%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%E5%92%8C%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><h3 id="一个最简化的订阅，注册，发布事件"><a href="#一个最简化的订阅，注册，发布事件" class="headerlink" title="一个最简化的订阅，注册，发布事件"></a>一个最简化的订阅，注册，发布事件</h3><p> 发了一个<code>事件</code>，如何回调相关注册的方法呢？</p><p> 最重要的Map，<code>subscriptionsByEventType</code>，一个<code>事件</code>对应多个<code>订阅</code>，<code>订阅</code>包含了<code>订阅者</code>和<code>订阅方法</code>。</p><p> 一个<code>订阅</code>包含两个信息，谁去做（订阅者），做什么（交给用户实现的部分），怎么做（线程如何调度，threadMode）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//根据事件找到订阅</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object subscriber;<span class="comment">// who</span></span><br><span class="line">    <span class="keyword">final</span> SubscriberMethod subscriberMethod;<span class="comment">// what and how</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Method method;<span class="comment">// do what </span></span><br><span class="line">    <span class="keyword">final</span> ThreadMode threadMode;<span class="comment">// how to do </span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于注销订阅"><a href="#关于注销订阅" class="headerlink" title="关于注销订阅"></a>关于注销订阅</h3><p> 订阅建立后，<code>订阅者</code>接受相关的<code>事件</code>的订阅就会被触发，做该做的事了，可若是订阅者不想订阅了，不想继续受到该之前订阅的事件了。（或者，生命周期结束了，若不注销订阅，EventBus实例会保留对该订阅者的引用，所以要注销该订阅者的所有订阅）</p><p> 是的，一个订阅者可以拥有多个订阅，所以，为了注销该订阅者，还得引入</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 一个订阅者对应订阅了什么事件类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 注册时，添加该订阅者，以及该订阅者订阅了什么关系（方便注销时，改动subscriptionsByEventType）</span></span><br><span class="line">   List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">  subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 注销时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">        <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">                unsubscribeByEventType(subscriber, eventType); <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">            typesBySubscriber.remove(subscriber);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 注销时，内部调用，迫使subscriptionsByEventType移除该订阅者中的订阅</span></span><br><span class="line">    <span class="comment">/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">        List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Subscription subscription = subscriptions.get(i);</span><br><span class="line">                <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                    subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                    subscriptions.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="编译时注解处理器生成索引"><a href="#编译时注解处理器生成索引" class="headerlink" title="编译时注解处理器生成索引"></a>编译时注解处理器生成索引</h3><p> 通过生成索引，EventBus可加快注册的速度，这在Android中是一个很好的优化，毕竟在onCreate方法中耗时太久会导致卡顿。</p><h4 id="索引内部使用流程"><a href="#索引内部使用流程" class="headerlink" title="索引内部使用流程"></a>索引内部使用流程</h4><p> 注册时，需要生成<code>subscriptionsByEventType</code>，对应一个订阅者，即找到一个  </p><p> List<subscribermethod> subscriberMethods ， </subscribermethod></p><p> 而寻找时</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> 可以看到有一个变量，<code>ignoreGeneratedIndex</code> 是否忽视生成索引，默认情况为false，即会尝试从索引查找的。</p><p> （在这里，若是没有配置生成索引，其实在配置时设置忽略索引，避免多走一些不必要的路）  </p><p> 而进入findUsingInfo()</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);<span class="comment">//尝试获取索引生成信息</span></span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;<span class="comment">//若有索引，则可直接添加该方法了</span></span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则，还是得倒退到使用索引的情况。</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 而findState中的subscriberInfo是什么呢？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/** Base class for generated index classes created by annotation processing. */</span><br><span class="line">public interface SubscriberInfo &#123;</span><br><span class="line">    Class&lt;?&gt; getSubscriberClass();  //订阅者该类的Class作为Key</span><br><span class="line"></span><br><span class="line">    SubscriberMethod[] getSubscriberMethods(); //标记有@Subscriber的方法</span><br><span class="line"></span><br><span class="line">    SubscriberInfo getSuperSubscriberInfo();  //该订阅者父类的信息</span><br><span class="line"></span><br><span class="line">    boolean shouldCheckSuperclass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到，这个类定义了EventBus对于一个订阅者，它关注什么信息  </p><p> 注意，文档中说明，对于索引使用是有条件的，如下</p><blockquote><p>Index Preconditions</p><p>Note that only @Subscriber methods can be indexed for which the <strong>subscriber AND event class are public</strong>. Also, due to technical limitations of Java’s annotation processing itself, @Subscribe annotations are <strong>not recognized inside of anonymous classes</strong>.</p><p>When EventBus cannot use an index, it will automatically fallback to reflection at run time. Thus it will still work, just a bit slower.</p><ul><li>订阅者和事件的类必须是public</li><li>在匿名类中的@Subscriber标记的方法，注解处理器无法识别</li><li>故，当使用索引失败时，会倒退到使用发射</li></ul></blockquote><h3 id="忽视事继承性"><a href="#忽视事继承性" class="headerlink" title="忽视事继承性"></a>忽视事继承性</h3><p> 即事件B继承A，若是订阅了事件A，发送事件B，是可以接收到的。</p><p> eventInheritance默认是为true的，支持事件的继承性。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布一个事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);<span class="comment">//寻找所有该类型的所有父类</span></span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//d</span></span><br><span class="line">    <span class="comment">/** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">            <span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">                <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    eventTypes.add(clazz); <span class="comment">//添加本身</span></span><br><span class="line">                    addInterfaces(eventTypes, clazz.getInterfaces());<span class="comment">//添加实现的接口</span></span><br><span class="line">                    clazz = clazz.getSuperclass();<span class="comment">//继续遍历其父类</span></span><br><span class="line">                &#125;</span><br><span class="line">                eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> eventTypes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 若是在项目中不会用到事件类型的继承性，也能省不少</p><p> 比如，事件类型类为String.class，会迭代5次</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eventTypes = &#123;ArrayList@908&#125;  size = 5</span><br><span class="line"> 0 = &#123;Class@322&#125; &quot;class java.lang.String&quot;</span><br><span class="line"> 1 = &#123;Class@325&#125; &quot;interface java.io.Serializable&quot;</span><br><span class="line"> 2 = &#123;Class@324&#125; &quot;interface java.lang.Comparable&quot;</span><br><span class="line"> 3 = &#123;Class@323&#125; &quot;interface java.lang.CharSequence&quot;</span><br><span class="line"> 4 = &#123;Class@326&#125; &quot;class java.lang.Object&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRUCache</title>
      <link href="/2019/11/06/LRUCache/"/>
      <url>/2019/11/06/LRUCache/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>LRUCache   缓存的容量大小是固定的，当添加对象时，发现超出容量时，优先把那些最近没有访问的对象移除缓存。</p><p>缓存策略中，LRU是基于访问时间的，即最近被访问的对象存活可能行最大，除此之外，还有LFU（基于访问频率），优先移除访问频率最小的。 </p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>主要的实现原理就是使用了LinkedHashMap，在其构造方法中，设置元素排序按照访问顺序来排（accessOrder=true），而非默认的按插入排序。<br>当访问元素时，将该结点移动到末尾，而删除元素时，总是优先删除队首的元素，这样便能实现“保留最近使用”。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Size of this cache in units. Not necessarily the number of elements. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">//当前缓存块的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始容量 0    map可以放置结点的个数</span></span><br><span class="line">        <span class="comment">// 负载因子 0.75    决定什么时候resize</span></span><br><span class="line">        <span class="comment">// accessOrder true     设置排序根据访问时间</span></span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取一个元素"><a href="#获取一个元素" class="headerlink" title="获取一个元素"></a>获取一个元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value for &#123;<span class="doctag">@code</span> key&#125; if it exists in the cache or can be</span></span><br><span class="line"><span class="comment">     * created by &#123;<span class="doctag">@code</span> #create&#125;. If a value was returned, it is moved to the</span></span><br><span class="line"><span class="comment">     * head of the queue. This returns null if a value is not cached and cannot</span></span><br><span class="line"><span class="comment">     * be created.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(@NonNull K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V mapValue;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// linkedHashMap内部会将该节点移到末尾</span></span><br><span class="line">            mapValue = map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                hitCount++;</span><br><span class="line">                <span class="keyword">return</span> mapValue;</span><br><span class="line">            &#125;</span><br><span class="line">            missCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Attempt to create a value. This may take a long time, and the map</span></span><br><span class="line"><span class="comment">         * may be different when create() returns. If a conflicting value was</span></span><br><span class="line"><span class="comment">         * added to the map while create() was working, we leave that value in</span></span><br><span class="line"><span class="comment">         * the map and release the created value.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当想要获取的元素不存在时，可以为此创建一个</span></span><br><span class="line">        V createdValue = create(key);</span><br><span class="line">        <span class="keyword">if</span> (createdValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            createCount++;</span><br><span class="line">            mapValue = map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// There was a conflict so undo that last put</span></span><br><span class="line">                map.put(key, mapValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                size += safeSizeOf(key, createdValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entryRemoved(<span class="keyword">false</span>, key, createdValue, mapValue);</span><br><span class="line">            <span class="keyword">return</span> mapValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            trimToSize(maxSize);</span><br><span class="line">            <span class="keyword">return</span> createdValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 放入一个元素</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Caches &#123;<span class="doctag">@code</span> value&#125; for &#123;<span class="doctag">@code</span> key&#125;. The value is moved to the head of</span></span><br><span class="line"><span class="comment">     * the queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value mapped by &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(@NonNull K key, @NonNull V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V previous;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            putCount++;</span><br><span class="line">            size += safeSizeOf(key, value);</span><br><span class="line">            <span class="comment">// 不管不顾，先将该节点插入</span></span><br><span class="line">            previous = map.put(key, value);</span><br><span class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">                size -= safeSizeOf(key, previous);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//若是放置的key已经存在，该存在的节点该如何处理，将该实现跑出来</span></span><br><span class="line">            entryRemoved(<span class="keyword">false</span>, key, previous, value);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//若是放置后，大小已经超出额定大小，将老元素置换出去</span></span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        <span class="keyword">return</span> previous;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 清除超出缓存大小的区域</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Remove the eldest entries until the total of remaining entries is at or</span></span><br><span class="line"><span class="comment">     * below the requested size.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1</span></span><br><span class="line"><span class="comment">     *            to evict even 0-sized elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            K key;</span><br><span class="line">            V value;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">                            + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//什么元素该驱逐？</span></span><br><span class="line">                <span class="comment">//优先首端元素</span></span><br><span class="line">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class="line">                key = toEvict.getKey();</span><br><span class="line">                value = toEvict.getValue();</span><br><span class="line">                map.remove(key);</span><br><span class="line">                size -= safeSizeOf(key, value);</span><br><span class="line">                evictionCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android事件分发</title>
      <link href="/2019/10/20/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
      <url>/2019/10/20/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于事件分发的文章确实很多，本文仅是用于自己对该知识点的总结和查漏，针对一些疑惑自问自答</p></blockquote><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>谈及事件分发，难免涉及到三个类，三个方法：  </p><p>事件传递： Activity -&gt; ViewGroup -&gt; View  （可理解为三层）</p><p>涉及的方法：dispatchTouchEvent, onInterceptTouchEvent（仅ViewGroup中存在）, onTouchEvent  </p><p>其中，dispatchTouchEvent在本层次中最先收到事件，可以在辞呈</p><p>为了加深印象，写了一个demo，如下图：</p><img src="/images/eventdemo1.jpg" width="240" height="200"><p>在三个相关的类中，分别重写涉及事件的三个方法，打上日志，点击View，日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31.732</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/MainActivity: dispatchTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31.733</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomViewGroup: dispatchTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31.733</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomViewGroup: onInterceptTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31.734</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomView: dispatchTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31.734</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomView: onTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31.734</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomViewGroup: onTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31.734</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/MainActivity: onTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31.780</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/MainActivity: dispatchTouchEvent:up</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31.780</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/MainActivity: onTouchEvent:up</span><br></pre></td></tr></table></figure><p>可以看到，<code>action_down</code>事件是从dispatchTouchEvent开始，从上到下传递（以树的结构，父View为上，子View为下），经过onInterceptTouchEvent过滤，这里我们不拦截down事件，事件则能从上流到底端，后onTouchEvent则从下到上传递，可供各级View消费该事件，而之后的<code>action_up</code>事件为什么仅会从在Activity中传递呢？</p><p>这里引出一个最重要的结论：（个人觉得哈）<br>down事件是所有事件的起点，之后才会有其他事件传递过来，<br>方法onTouchEvent，决定了要不要消费之后分发过来的事件，如action_up,  在此次例子，默认的View和ViewGroup都返回false，所有他们表示都不要消费事件，这样，使得之后的事件由最上层View来消费，（Activity中本身其实也可以理解为View，其中包含有Window,Window由包含有DecorView,即DecorView是所有View的顶层View）。 </p><p>为了验证此结论，将ViewGroup的onTouchEvent返回true，表示该ViewGroup要消费后续的事件，则之后的up事件只会传到ViewGroup消费，（同理View）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">03.346</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/MainActivity: dispatchTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">03.348</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomViewGroup: dispatchTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">03.349</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomViewGroup: onInterceptTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">03.349</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomView: dispatchTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">03.349</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomView: onTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">03.350</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomViewGroup: onTouchEvent:down</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">03.400</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/MainActivity: dispatchTouchEvent:up</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">03.400</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomViewGroup: dispatchTouchEvent:up</span><br><span class="line"><span class="number">2019</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">03.400</span> <span class="number">31871</span>-<span class="number">31871</span>/com.wjp.eventtransferdemo D/CustomViewGroup: onTouchEvent:up    <span class="comment">// up事件传给ViewGroup消费</span></span><br></pre></td></tr></table></figure><p>也可在上面ViewGroup滑动，可以看到，所有的事件（move,up）都传给ViewGroup来消费：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">019-10-22 23:52:08.835 31871-31871/com.wjp.eventtransferdemo D/MainActivity: dispatchTouchEvent:down</span><br><span class="line">2019-10-22 23:52:08.835 31871-31871/com.wjp.eventtransferdemo D/CustomViewGroup: dispatchTouchEvent:down</span><br><span class="line">2019-10-22 23:52:08.836 31871-31871/com.wjp.eventtransferdemo D/CustomViewGroup: onInterceptTouchEvent:down</span><br><span class="line">2019-10-22 23:52:08.836 31871-31871/com.wjp.eventtransferdemo D/CustomView: dispatchTouchEvent:down</span><br><span class="line">2019-10-22 23:52:08.836 31871-31871/com.wjp.eventtransferdemo D/CustomView: onTouchEvent:down</span><br><span class="line">2019-10-22 23:52:08.836 31871-31871/com.wjp.eventtransferdemo D/CustomViewGroup: onTouchEvent:down  //这里返回true之后，之后的事件都给ViewGroup处理了，同时也不会传给上层（Activity消费了）</span><br><span class="line">2019-10-22 23:52:08.931 31871-31871/com.wjp.eventtransferdemo D/MainActivity: dispatchTouchEvent:move</span><br><span class="line">2019-10-22 23:52:08.931 31871-31871/com.wjp.eventtransferdemo D/CustomViewGroup: dispatchTouchEvent:move</span><br><span class="line">2019-10-22 23:52:08.932 31871-31871/com.wjp.eventtransferdemo D/CustomViewGroup: onTouchEvent:move</span><br><span class="line">2019-10-22 23:52:08.948 31871-31871/com.wjp.eventtransferdemo D/MainActivity: dispatchTouchEvent:move</span><br><span class="line">2019-10-22 23:52:08.981 31871-31871/com.wjp.eventtransferdemo D/CustomViewGroup: dispatchTouchEvent:move</span><br><span class="line">2019-10-22 23:52:08.981 31871-31871/com.wjp.eventtransferdemo D/CustomViewGroup: onTouchEvent:move</span><br><span class="line">2019-10-22 23:52:08.992 31871-31871/com.wjp.eventtransferdemo D/MainActivity: dispatchTouchEvent:up</span><br><span class="line">2019-10-22 23:52:08.992 31871-31871/com.wjp.eventtransferdemo D/CustomViewGroup: dispatchTouchEvent:up</span><br><span class="line">2019-10-22 23:52:08.992 31871-31871/com.wjp.eventtransferdemo D/CustomViewGroup: onTouchEvent:up</span><br></pre></td></tr></table></figure><p>由此，可以得出一个通俗的结论，<strong>事件是从上到下询问，确定之后该由谁来处理后续的事件（接受处理任务）</strong>，直至有人消费则停止询问，若无人去人给最上层处理。 </p><p>由上面的结论，可得知，若是我（某个不知名的View）想消费事件，只要在down事件来临时，return true, 表示我可以接受任务，那么若是上层和下层都想要消费事件，该由谁来消费呢？<br>默认情况下，下层的onTouchEvent先调用，所以当然优先由下层View来处理后续事件；那么若是上层View想要优先与下层来处理事件呢？</p><p>比如在ScrollView中，上下滑动时,开始先由子View来出来滑动事件，达到一定条件后拦截后续move事件让ScrollView来处理，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ScrollView</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//2 . 判断是上下滑动时，将后续的滑动事件交由ScrollView来处理</span></span><br><span class="line">      <span class="keyword">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//1 。开始的move事件不拦截，让子View处理，当上下滑动的大小达到一个系统滑动slop值时，（检测到用户是有意上下滑动），将isBeginDraggedd设为true</span></span><br><span class="line">       <span class="keyword">switch</span> (action &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class="line">                  <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY(pointerIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> yDiff = Math.abs(y - mLastMotionY);</span><br><span class="line">                    <span class="keyword">if</span> (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == <span class="number">0</span>) &#123;</span><br><span class="line">                        mIsBeingDragged = <span class="keyword">true</span>;</span><br><span class="line">                        mLastMotionY = y;</span><br><span class="line">                  </span><br><span class="line">                  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>写一个demo，一个<code>WantToHandlerMoveEventView</code>尽量的想要消费滑动事件，但是放在<code>ScrollView</code>里面，上下滑动该自定义View，日志如下：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2019-10-24 00:31:57.948 27211-27211/com.wjp.eventtransferdemo D/ScrollViewInnerAct: dispatchTouchEvent:down</span><br><span class="line">2019-10-24 00:31:57.948 27211-27211/com.wjp.eventtransferdemo D/WantToHandlerMoveEventView: dispatchTouchEvent:down</span><br><span class="line">2019-10-24 00:31:57.948 27211-27211/com.wjp.eventtransferdemo D/WantToHandlerMoveEventView: onTouchEvent:down</span><br><span class="line">2019-10-24 00:31:58.002 27211-27211/com.wjp.eventtransferdemo D/ScrollViewInnerAct: dispatchTouchEvent:move</span><br><span class="line">2019-10-24 00:31:58.002 27211-27211/com.wjp.eventtransferdemo D/WantToHandlerMoveEventView: dispatchTouchEvent:move</span><br><span class="line">2019-10-24 00:31:58.002 27211-27211/com.wjp.eventtransferdemo D/WantToHandlerMoveEventView: onTouchEvent:move  //开始由该自定View消费该move事件</span><br><span class="line">2019-10-24 00:31:58.018 27211-27211/com.wjp.eventtransferdemo D/ScrollViewInnerAct: dispatchTouchEvent:move</span><br><span class="line">2019-10-24 00:31:58.019 27211-27211/com.wjp.eventtransferdemo D/WantToHandlerMoveEventView: dispatchTouchEvent:cancel</span><br><span class="line">2019-10-24 00:31:58.019 27211-27211/com.wjp.eventtransferdemo D/WantToHandlerMoveEventView: onTouchEvent:cancel</span><br><span class="line">2019-10-24 00:31:58.035 27211-27211/com.wjp.eventtransferdemo D/ScrollViewInnerAct: dispatchTouchEvent:move  //达到一定滑动距离之后，后续滑动事件都由ScrollView来消费了</span><br><span class="line">2019-10-24 00:31:58.380 27211-27211/com.wjp.eventtransferdemo D/ScrollViewInnerAct: dispatchTouchEvent:move</span><br><span class="line">2019-10-24 00:31:58.381 27211-27211/com.wjp.eventtransferdemo D/ScrollViewInnerAct: dispatchTouchEvent:up</span><br></pre></td></tr></table></figure><p>由此，我们又可以得到一个结论，<strong>若是上下层View都想消费同一个事件，上层View可通过onInterceptTouchEvent获得有权</strong>。   </p><p>这样，通过上面，基本了解三个相关方法的关系。   </p><p>###<a href="https://github.com/wjploop/EventTransferDemo" target="_blank" rel="noopener">相关demo</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus总结</title>
      <link href="/2019/10/18/EventBus%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/18/EventBus%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前两天去面试，问起EventBus，发觉自己表达还是很糟糕啊~</p></blockquote><h3 id="EventBus是什么？应用场景？"><a href="#EventBus是什么？应用场景？" class="headerlink" title="EventBus是什么？应用场景？"></a>EventBus是什么？应用场景？</h3><p>方便组件通讯，降低耦合  </p><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>问题需求：  </p><p>QQ查找附近好友<code>列表页面</code>，跟这些用户关系，好友或非好友，查看某个非好友用户<code>详情页面</code>，并在详情页面添加为好友，返回到列表页面时，与他的关系没有更新；</p><p>传统解决方案：  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChangeRelationListener</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新列表中某个用户的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">change</span><span class="params">(userId:<span class="type">Int</span>,newRelation)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 列表页面实现该接口，并实现修改列表某个用户状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.详情页面，获取到列表页面的引用（该接口实现的实例），调用change方法</span></span><br></pre></td></tr></table></figure><p>其中麻烦的有两点：繁琐的创建额外一个接口；获取到接口实现的引用   </p><p>当然，也可以不实现接口，详情页面直接获取到列表页面的引用，但这就不符合设计原则了，详情页面不该拥有对列表页面的全部控制权。  </p><p>EventBus解决方案 </p><ol><li>列表页面作为订阅者，订阅修改状态的事件  </li><li>详情页面作为发布者，发布状态更新的事件</li></ol><p>这样，代码简单，耦合度也低了。<br>当然，评判好坏，偶合低的另一极端是，容易导致滥用，在多处地方发布时间，管理不当，可能会导致总线拥堵。</p><h3 id="EventBus的实现原理？"><a href="#EventBus的实现原理？" class="headerlink" title="EventBus的实现原理？"></a>EventBus的实现原理？</h3><p>注册订阅者时，遍历该订阅者类中标记<code>@Subscriber</code>的方法，明确这个订阅者订阅了<strong>什么事件</strong>，以及针对该事件该<strong>怎么处理</strong>，即将订阅者的信息注册到EventBus实例中。<br>发布者发送事件时，查询EventBus中订阅有该事件的订阅者，调用相应订阅方法</p><p>其中，如何获取到订阅者信息呢？有两种方式。</p><ol><li>运行时，通过反射获取订阅者信息</li><li>编译时，通过注解处理器生成订阅者信息的索引</li></ol><p>对比两者优劣，前者简单，后者稍有麻烦，通过减少注册时消耗的时间，提升性能   </p><p>注意，无论使用选择哪种方式，都要注意混淆时保留订阅者的处理事件方法的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes *Annotation*</span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">    @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line">-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;</span><br></pre></td></tr></table></figure><p>编译时生成订阅者索引的具体操作方法：</p><p>使用kotlin如下，java环境参考<a href="http://greenrobot.org/eventbus/documentation/subscriber-index/" target="_blank" rel="noopener">官网文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 应用对kotlin处理注解插件</span><br><span class="line">apply plugin: &apos;kotlin-kapt&apos; // ensure kapt plugin is applied</span><br><span class="line"> </span><br><span class="line">2. 添加依赖</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br><span class="line">    kapt &apos;org.greenrobot:eventbus-annotation-processor:3.1.1&apos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">3. 确定生命索引的名字，在EventBus实例中用到</span><br><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(&apos;eventBusIndex&apos;, &apos;com.example.myapp.MyEventBusIndex&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 创建实例时添加该索引</span><br><span class="line">EventBus.builder().addIndex(MyEventBusIndex()).installDefaultEventBus()</span><br></pre></td></tr></table></figure><h3 id="ThreadMode-列举描述"><a href="#ThreadMode-列举描述" class="headerlink" title="ThreadMode 列举描述?"></a>ThreadMode 列举描述?</h3><p><code>threadMode</code>线程模式描述了处理事件应该在哪个线程</p><ul><li><code>POSTING</code> 与发送事件的线程相同</li><li><code>MAIN</code> 始终在主线程</li><li><code>MAIN_ORDERED</code> 基于MAIN,并保证事件会同步有序处理</li><li><code>BACKGROUND</code> 与MAIN相反，是在不会在主线</li><li><code>ASYNC</code> 始终不会在发送事件的线程，发送事件事件方法调用会立刻返回</li></ul><p>具体解析：</p><p><code>POSTING</code>是默认的，这是为了性能考虑。当发送事件的线程和处理事件线程相同时，不会引起线程切换，而是直接的<code>方法调用</code><br><code>直接方法调用</code>存在一个问题：<br>发送事件的方法要等到处理事件的方法返回才能返回，假设处理方法耗时很久，发送事件方法也要一直等。<br>在<code>MAIN</code>模式中会有一个问题：<br>假设使用了MAIN模式来处理事件，线程<code>t1</code>, <code>t2</code>先后分别发送了<code>e1</code>,<code>e2</code>, 主线程会先处理e1，若是处理e1未结束，e2事件到来,那么主线程会交错处理<code>t1</code>,<code>t2</code>，可能不会是我们预想的结果，先处理完<code>t1</code>,再开始处理<code>t2</code>   </p><blockquote><p>开始没有想通，故写了demo来验证，可<a href="https://github.com/wjploop/EventBusDemo" target="_blank" rel="noopener">参考</a></p></blockquote><p>故可以使用<code>MAIN_ORDERED</code>来实现这个需求，内部通过一个维护一个<code>pendingPostPool</code>等待发送的事件列表，这样，才能够等t1处理完，在开始处理t2.</p><p><code>Async</code> 很强大保证每个发送的事件都会尽快处理，因为内部默认使用了可缓存的线程池<code>CacheThreadPool</code>来处理多个任务，避免多个事件到来时需要等待处理。  </p><p><code>newCacheThreadPool</code> 描述：</p><p>作为一个线程池，当没有任务到来时不会创建有线程，<br>有任务到来会创建线程来处理，处理结束后，不会直接销毁，而是保留一段时间（默认60s），存活期间可处理继续处理任务，避免了创建线程影响开销。  </p><p>相应的，除了上面提到的线程池，java默认还提供了3中线程池：</p><ul><li>newFixedThreadPool 默认就创建了几个核心的线程，核心线程不会因为任务结束而销毁，且也会限制最大的线程个数</li><li>newScheduledThreadPool 定时或周期性执行任务</li><li>newSingleThreadExecutor 使用单线程来处理任务，未处理的线程会进入等待队列</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-运行时数据区</title>
      <link href="/2019/10/15/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>/2019/10/15/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM运行时数据区构成"><a href="#JVM运行时数据区构成" class="headerlink" title="JVM运行时数据区构成"></a>JVM运行时数据区构成</h2><p>程序运行时，根据不同功能划分了不同的数据区。<br>一些区是程序启动后创建的，一些是线程创建后而创建的，即线程私有的。  </p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程私有。<br>每个线程都有一个PC，用于记录当前线程执行指令的地址。<br>通常是java程序是多线程的，若是只有一个内核运行情况下，一次只能运行一个线程，线程会来回切换执行。当线程挂起时，需要pc来保存当前运行到指令的位置，以便在它重新启动时，能够根据pc的保存的位置继续执行。  </p><h3 id="Java栈区"><a href="#Java栈区" class="headerlink" title="Java栈区"></a>Java栈区</h3><p>线程私有。<br>线程启动时创建，当方法调用时会创建一个<code>Stack Frame</code>栈帧，用于存储本地变量以及部分结果，对于该栈的操作，只存在,方法调用时，入栈，方法结束时出栈。  </p><h3 id="本地方法栈区"><a href="#本地方法栈区" class="headerlink" title="本地方法栈区"></a>本地方法栈区</h3><p>线程私有。<br>执行本地方法的栈区。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>线程共有。<br>最常说的堆，用于存放对象实例，在虚拟机启动时就分配。<br>规范没有规定GC的配置，不过通常是这样划分的：  </p><ul><li>新生代 young（1/3）<ul><li>eden (8/10)</li><li>from  (1/10)</li><li>to    (1/10)</li></ul></li><li>老年代 old（2/3）</li></ul><p>根据分代算法，实际可用的最大内存的为: eden + (from or to) + old = 9/10， 即最大占用90%的堆区  </p><h3 id="判断对象是否存活的算法："><a href="#判断对象是否存活的算法：" class="headerlink" title="判断对象是否存活的算法："></a>判断对象是否存活的算法：</h3><ol><li>引用计数<br> 对于每个对象，记录被引用的个数，若没有引用，则回收。缺点，无法解决引用循环的问题。</li><li>可达性分析方法 （根搜索方法） 通过一些GCRoot为节点对象开始，搜索通过的路径为引用链（ReferenceChain），若一个对象没有被引用链连接时，则回收。<br> GC Root:  <ul><li>Java栈中的引用对象 （形参指向；方法中本地变量指向）</li><li>本地方法栈的中引用的对象</li><li>激活的线程</li><li>被系统类加载器加载的Class对象</li><li>用于线程同步的锁对象</li></ul></li></ol><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ol><li><p>标记清除 将没有引用的内存块清除。 有碎片。</p></li><li><p>标记整理 将剩余的有引用的对象挪到另一端。解决碎片问题。效率低。</p></li><li><p>复制算法 将内存块一分为二，将存活的对象对象复制到另一边。 效率高，利用率低</p></li><li><p>分代算法 根据对象不同的存活的时间使用不同的方法： 新生代的from和to区使用复制算法，老年代使用标记整理算法<br> 新建对象放大到eden区，eden区满时，将存活的放到from，此后若是对象一直存活，则现在from和to往返，并记录其往返次数，达到一定次数时， 将该对象放到老年代。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>为了方便程序员，引用类型分了几种。</p></li><li><p>强引用常见的，new一个对象，赋予一个变量，即该变量对该对象有一个强引用。<br>宁愿内存满了，也会持有该引用，可能会导致OOM。</p></li><li><p>软引用 GC时，若是内存不够，则回收，内存够了，则继续保留。<br>适用一些缓存的处理。  </p></li><li><p>弱引用若是GC时，该对象仅有弱引用，则回收。<br>既可以通过该引用找到该变量，又不想干预其对象被回收。（既可得到了她的人，又不想对其负责的感觉）<br>适用例子：ThreadLocal,WeakHashMap<br>WeakHashMap，若是put(key,value)进去，若是除了该map对其key有引用之外，该key没有引用了，则应该回收key对象。ThreadLocal变量作为线程私有，¡通过Thread中的ThreadLocalMap中获取，而在该ThreadLocalMap中的Entry中，其Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt;</span>&#123;   </span><br><span class="line">   Object value;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当使用完ThreadLocal变量， 在该ThreadLocalMap中，将Key设置为弱引用，防止用户将threadLocal=null，key内存泄漏。  </p><p> 若是有一个线程私对象A，通过Thread()-&gt;ThreadLocalMap-&gt;Key-&gt;A来获取，<br> 在外部没有对A有引用的情况下，若是Entry是一个强引用，那么，线程不销毁，则A会一直存在。 当线程需要在线程池复用时，A就就不能被释放了。<br> 而 Entry就是一个弱引用，若是一个线程结束时，该线程私有的变量，Thread  -&gt;(Strong Reference) ThreadLocalMap -&gt;(SoftReference) Entry -&gt; Key<br> 可以看到若是不用WeakReference，则当线程结束结束后，该线程不能得到回收</p></li><li><p>虚引用比弱引用更弱，不会对引用的对象造成影响，需配合ReferenceQueue使用。（本人没搞懂~）</p></li></ol><h4 id="JVM启动时可配置参数"><a href="#JVM启动时可配置参数" class="headerlink" title="JVM启动时可配置参数"></a>JVM启动时可配置参数</h4><ul><li>-Xms 堆初始大小 -Xms256m</li><li>-Xmx 堆最大大小</li><li>-Xmn 堆中新生代的大小 </li><li>-Xss 每个线程栈堆大小</li><li>… </li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>线程共享<br>存储虚拟机加载类的信息，常量，静态变量。<br>JDK1.7之前，其大小固定，容易爆，之后可以动态分配了。</p><h3 id="运行时常量池-Run-Time-Constant-Pool"><a href="#运行时常量池-Run-Time-Constant-Pool" class="headerlink" title="运行时常量池 Run-Time Constant Pool"></a>运行时常量池 Run-Time Constant Pool</h3><p>这个区可以包括在方法区里面，是每个加载的Class或Interface私有的，其分配内存时机是当该Class类的实例对象创建时。（不是Class对象）它包括了一些字面常量，field references域引用，必须在运行时解析。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> java, jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/09/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="单例模式，懒汉模式，double-check"><a href="#单例模式，懒汉模式，double-check" class="headerlink" title="单例模式，懒汉模式，double check"></a>单例模式，懒汉模式，double check</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton sInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sInstance==<span class="keyword">null</span>)&#123; <span class="comment">//3</span></span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class)&#123; <span class="comment">//4</span></span><br><span class="line"><span class="keyword">if</span>(sInstance==<span class="keyword">null</span>)&#123; <span class="comment">//5</span></span><br><span class="line">sInstance=<span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>私有化构造方法，增加用户直接构造对象的难度。（用户还是可以通过反射的方法构造）</p></li><li><ul><li><p><code>static</code> 变量指向该静态对象，保证该对象创建后不会被回收。  一个对象是否被回收，取决于有没有gc root的变量指向它（直接或间接）。而常见的gc root有：</p><ol><li>class 由System Class Loader加载的类</li><li>方法栈中的变量</li><li>活着的线程Thread</li></ol></li><li><p><code>volatile</code>  确保该变量指向的对象在线程之间的可见性，防止在 <code>5</code> 中对象会创建多个。</p><p>创建一个对象有三个步骤：</p><ol><li>为该对象开辟内存</li><li>创建该对象</li><li>令变量指向该对象地址  </li></ol><p>在对象创建过程中，为了效率考虑，三个步骤的顺序是可以打乱重排的（三者顺序不确定），由于默认重排序的机制存在，在本例子中，在<code>5</code>中，可能还会出现创建多个对象的情况。<code>volatile</code>关键字有两个作用，禁止编译器为优化而指令重排，保证该变量指向对象的线程之间的可见性。<br>什么是线程之间可见性？<br>原本，不同线程中的变量是可以指向堆中同一个对象，若是有一个线程修改了该对象，其它线程按理说是可以马上获取到该改动的，因为它们的指向都没变嘛。可是，出现的问题在于变量与内存之间，还多个了个缓存。且，每个线程在读取内存中的对象实例后，都是放到它的私有缓存中，之后的修改也是修改该缓存中的实例对象。所以，当线程A修改对象时，线程B并没有收到A中的修改。即，我们可以称该现象为线程之间的不可见。<br>而<code>volitale</code>修饰的变量，<br>读取该变量时，先同步主内存的修改。<br>写操作时，将该修改同步到主内存。<br>这样，通过读写操作，即可保证该线程之间的可见性。</p></li></ul></li><li><p>这次判空检查，避免多个线程检验锁，（检验锁，若是没有获取到该对象锁，即会将该线程添加到该对象的锁等待池中。）这里为性能考虑。</p></li><li><p>使用Singleton.class对象做为对象锁，而不是其他对象，因为该对象是唯一的。</p><ul><li>sync 可以修饰在不同地方，比如静态方法，成员方法，锁住一个对象，但本质都是锁一个对象</li><li>若是在静态方法，就是锁该Class类对象。</li><li>若是成员方法，就是当前调用方法的变量了。</li><li>当然了，我们也可以显式指定对象。比如这样，sync（object）</li></ul></li><li><p>这次判空是要保证该对象的唯一。 若是多个线程从该锁对象的等待池中醒了过来，需要判空一下。当然了，需要加载volatile的判空处理。</p></li></ol><h2 id="静态内部单例"><a href="#静态内部单例" class="headerlink" title="静态内部单例"></a>静态内部单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//内部类，（内部静态类，内部非静态类都一样），都会被调用时才会被加载。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Instance();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外：</p><ol><li><p>非静态内部类， 为啥不能声明static变量？</p><p>答：因为这个内部类需要外部类的一个对象来指向， 反过来说，就是该内部类持有一个外部类实例的成员。即通过A().B.salary。 而静态内部类可以，是因为该内部类，没有持有外部类的应用，所以可以直接通过A.B.salary.</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2019/09/17/ThreadLocal/"/>
      <url>/2019/09/17/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><hr><p>/**</p><ul><li>This class provides thread-local variables.  These variables differ from</li><li>their normal counterparts in that each thread that accesses one (via its</li><li>{@code get} or {@code set} method) has its own, independently initialized</li><li>copy of the variable.  {@code ThreadLocal} instances are typically private</li><li>static fields in classes that wish to associate state with a thread (e.g.,</li><li>a user ID or Transaction ID).</li><li></li></ul><p>官方解释，即一个提供线程私有变量。<br>既然这里说，使用这个类可以提供一个线程私有的变量，那么就是说，不使用，就是线程共有的了。<br>即，不使用这个类，所有变量都是指向堆中的同一个个对象，只要一个线程修改了，其他线程也会受到影响。  </p><blockquote><p>的确，是会受到影响的，只不过以为每个线程都有自己的缓存的原因，它们所谓的共有，不能做到及时同步，需要额外处理，否则一般会出现bug的。 这里，可以使用volatile关键字强制同步。参见<code>单例模式一文</code></p></blockquote><p>而这里的线程私有，是指该对象只能从该线程获取，比如线程A创建的对象obj,B对象试图获取，得到的是null。 </p><p>看看源码，其实现还是相对简单的，  </p><p>在Thread内持有一个ThreadLocalMap,里面保存有该线程所有线程私有变量。  </p><p>其中，为了避免内存泄漏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal有个内部类ThreadLocalMap, 使用了一个很简易的HashMap实现方式,<br>不同的是，当有冲突时，其没有使用链表来保存额外的Entry,而是方法table的下一位，即线性检测。<br>原因是，应该是认为一个线程不应该有那么多私有变量啊。 </p><p>两个点是，使用WeakReference来包裹Entry,这样，要回收把一个变量放到ThreadLocal中，并不会持有该对象的强应用，若是只有该放到ThreadLocal这个对象，ThreadLocal<object> 整体作为Key，而Value是Object，当然Key为空null，table中也只是保存有entry，所以当只有entry指向该value时,  </object></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ThreadLcoal&lt;Object&gt; obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">obj作为一个key在Thread的LocalThreadMap中，若是key为<span class="keyword">null</span>，需要该指向的value也为</span><br></pre></td></tr></table></figure><p>弱引用,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;A&gt; aRef = <span class="keyword">new</span> WeakReference&lt;A&gt;();</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">aRef.set(a);</span><br><span class="line"><span class="comment">//持有有A对象有两个应用，一个强一个弱</span></span><br><span class="line"><span class="comment">//此时</span></span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">//实例A不会回收</span></span><br><span class="line"></span><br><span class="line">a=<span class="keyword">null</span></span><br><span class="line">再次</span><br><span class="line">System.gc();</span><br><span class="line">仅剩弱引用指向，故，实例A会被回收</span><br></pre></td></tr></table></figure><p>而在ThreadLcoalMap中，保存的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> ThreadLocal&lt;String&gt;()</span><br><span class="line"><span class="comment">//将t作为key放入当前线程中的map中，</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">t.set(data)</span><br><span class="line"><span class="comment">//当设值之后，data这个对象有两个引用，</span></span><br><span class="line">data=<span class="keyword">null</span>   <span class="comment">//去掉一个</span></span><br><span class="line"></span><br><span class="line">还有一个，在当前线程还活着的状态</span><br><span class="line">current_thread.threaLocalMap.entry.value</span><br><span class="line"><span class="comment">//map中的tables存放弱引用，故get()时，随时都可能==null，</span></span><br><span class="line">故，我觉得该data对象会被回收...</span><br><span class="line">但是，网上的文章说不会，没搞明白</span><br><span class="line">t.remove()</span><br></pre></td></tr></table></figure><blockquote><p>好吧，这个ThreadLocalMap中的弱引用没搞懂啊~</p></blockquote><p>其中，他的GET，SET方法，都是先通过Thread.currentThread来获取到当前调用方法的线程，在该线程的ThreadLocalMap中检查好是否设置有该变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler中的AndroidLeak</title>
      <link href="/2019/09/17/Handler%E4%B8%AD%E7%9A%84AndroidLeak/"/>
      <url>/2019/09/17/Handler%E4%B8%AD%E7%9A%84AndroidLeak/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class; In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler; Make all references to members of the outer class using the WeakReference object.</p></blockquote><p>Handler不恰当的使用方式，会导致内存泄漏。  </p><p>若是在Activity中使用非静态内部类的Handler时，该Handler会持有外部Activity的引用，（内部类的特点）。<br>使用handler发送出去的消息Message，其内部会持有一个handler的引用，即msg-&gt;handler-&gt;Activity.  d在Activity结束时，msg可能还在在消息队列中等待处理，所以，会导致有Activity对象不能得到回收。</p><p>针对这个问题，最简单的方法是，Activity的生命周期方法的onDestroy方法中调用removeAllCallBack(null),其方法会导致所以待处理的Message作废，即所以target指向为该handler消息都移除队列，并且target指向null。</p><p>另外一种方法是，使用Handler使用静态类，即其类的创建不再有指向Activity的引用了。但是一般情况，我们handler的处理消息，都要使用到Activity来处理啊，因而，我们在该静态的Handler类中，使用WeakReference来包装该Activity，即使用这个<code>有实无名</code>的Activity， （嗯~，渣男）</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android消息机制</title>
      <link href="/2019/09/17/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/09/17/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h3><p>消息机制可以说是4个类的关系，分别是</p><ul><li>Handler</li><li>Looper</li><li>MessageQueue</li><li>Message</li></ul><p>其中流程是这样子的，开启一个消息循环，每循环一次，便从消息队列中取出一个消息，然后交给相应的<code>Handler</code>来处理。<br>而消息循环的具体实现就是一个<code>Looper</code>，<code>Looper</code>内部持有了一个消息队列，我们要用<code>Looper</code>的<code>prepare()</code>方法在当前线程中创建唯一的<code>Looper</code>对象，其中，<code>Looper</code>内部持有一个消息队列，并</p><p>在ActivityThread的main（）函数中，即启动UI线程，便是开启一个消息循环。在UI线程中，确保有且仅有一个消息循环，之后，所有的与UI相关的操作，都会通过<code>Hanlder</code>以发消息的形式先放入<code>MessageQueue</code>，<code>Looper</code>通过执行一个循环，不断取出队列的消息<code>Message</code>, 再将该消息交给对应的<code>Handler</code>来处理。</p><p>有了这个消息机制，其他线程（包括UI线程本身），对应UI有什么操作想法，不再能直接就修改，而是将想法包装成消息，放到消息队列中，再一一处理。通过这样的机制，才能保证UI的运行正常。试想，若是线程A，B分别要在屏幕同一位置画一个鸡，鸭，若让A，B的请求同时执行，结果就是鸡鸭都画不成了，可知，对于不同的线程的请求，必须要有个先后。或是说，线程A可能要画3秒钟，再让B画两秒钟，通过消息，就很容易让这些任务同步。可能，这两个例子有点狭隘了。</p><h3 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">   Looper.prepareMainLooper()  <span class="comment">//准备一个唯一mainLooper</span></span><br><span class="line">   </span><br><span class="line">   Looper.loop()  <span class="comment">//启动消息循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Looper.prepareMainLooper</span></span><br><span class="line"> prepare(<span class="keyword">false</span>)</span><br><span class="line"> sychronized(Looper.class)&#123;</span><br><span class="line">     <span class="keyword">if</span>(sMainLooper!=<span class="keyword">null</span>)&#123;    <span class="comment">//确保只有一个主循环</span></span><br><span class="line">         <span class="keyword">throw</span> IllegalException()</span><br><span class="line">     &#125;</span><br><span class="line">     sMainLooper=mLooper()</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//prepare(false)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;   <span class="comment">//使用ThreadLocal确保每个线程只有一个Looper</span></span><br><span class="line">       <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Looper()</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;  <span class="comment">//创建一个消息队列</span></span><br><span class="line">       mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">       mThread = Thread.currentThread();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//启动循环</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Looper me = myLooper();   </span><br><span class="line">       <span class="comment">//额外话，为什么很多变量不直接用类的成员变量，而是新创建一个局部final变量来使用？</span></span><br><span class="line">       <span class="comment">//以为Java中变量都是可变的，若是在操作中变量指向改变了，逻辑就没法确定了，所以使用一个本地的final变量指向它</span></span><br><span class="line">       <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">//从消息队列获取消息，（这里的可能会阻塞，即执行到这里会等待，与Socket中Server等待客户端连接相似，具体是什么原理有待研究...）</span></span><br><span class="line">           Message msg = queue.next(); <span class="comment">// might block </span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//使用消息中对象target，来处理该消息，target就是handler</span></span><br><span class="line">           msg.target.dispatchMessage(msg);   </span><br><span class="line">           </span><br><span class="line">           <span class="comment">//消息回收处理</span></span><br><span class="line">           <span class="comment">//目的为了避免创建过多的对象，引发GC</span></span><br><span class="line">           msg.recycleUnchecked();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//recycleUnchecked</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">      <span class="comment">// Clear out all other details.</span></span><br><span class="line">      flags = FLAG_IN_USE;</span><br><span class="line">      what = <span class="number">0</span>;       <span class="comment">//就是消息中的成员都置空处理，使其指向的对象可以回收</span></span><br><span class="line">      arg1 = <span class="number">0</span>;</span><br><span class="line">      arg2 = <span class="number">0</span>;</span><br><span class="line">      obj = <span class="keyword">null</span>;</span><br><span class="line">      replyTo = <span class="keyword">null</span>;</span><br><span class="line">      sendingUid = UID_NONE;</span><br><span class="line">      workSourceUid = UID_NONE;</span><br><span class="line">      when = <span class="number">0</span>;</span><br><span class="line">      target = <span class="keyword">null</span>;</span><br><span class="line">      callback = <span class="keyword">null</span>;</span><br><span class="line">      data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">             next = sPool;   <span class="comment">//可以看到，这里的Message本身就作为一个列表节点，且这里使用头插法将消息放回池子中</span></span><br><span class="line">             sPool = <span class="keyword">this</span>;</span><br><span class="line">             sPoolSize++;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//msg.target.dispatchMessage(msg);   </span></span><br><span class="line">   <span class="comment">//可以看到，消息从队列拿出来后，根据msg和handler会有不同处理方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123; <span class="comment">//若是消息指定了callback了，即handler通过post*(r)方法来发的</span></span><br><span class="line">           handleCallback(msg);  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;    <span class="comment">//若是handler有callback，优先使用handler的callbak来处理</span></span><br><span class="line">               <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;  <span class="comment">//这里还要根据callback中的返回值，来判断是否还要继续调用Handler的handerMessage()方法</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           handleMessage(msg); <span class="comment">//这里是我们通常的写法，在handlerMessage中处理消息</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">//Hanlder的创建,以及发送消息</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用内部类来创建</span></span><br><span class="line">   <span class="meta">@SuppressLint</span>(<span class="string">"HandlerLeak"</span>)</span><br><span class="line">   Handler handler1 = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//传入callback来创建</span></span><br><span class="line">   Handler handler2 = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123; </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   hanlder.send*()</span><br><span class="line">   hanlder.post*()</span><br><span class="line">   <span class="comment">//通过handler来发送消息，无论是send*（）还是post*（），最终都是调用了</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       msg.target = <span class="keyword">this</span>;  <span class="comment">//</span></span><br><span class="line">       <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis); <span class="comment">//入队列</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h3><p><a href="https://wjploop.github.io/2019/09/17/Handler中的AndroidLeak">Handler中的AndroidLeak</a><br><a href="https://wjploop.github.io/2019/09/17/ThreadLocal">ThreadLocal</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus笔记</title>
      <link href="/2019/09/11/EventBus%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/11/EventBus%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="官方的自我介绍："><a href="#官方的自我介绍：" class="headerlink" title="官方的自我介绍："></a>官方的自我介绍：</h3><p>简化组件之间通信发送者与接收者处理逻辑的解耦可以在activity, fragment, service之中完美运行避免了与生命周期打交道，易于检测错误。</p><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>一个发布事件，订阅事件的系统，与Android自身的广播相比，使用更加简单，不依赖context，可以在不同线程发送/处理事件。  </p><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><blockquote><p>为了捉住这个库的主干，我对比看了EventBus的最初版本(即使用git切换到最初的版本)，即实现一个最简单的逻辑。</p></blockquote><p>EventBus作为一个单例，里面保存了两个最重要的Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个事件类型，拥有的的订阅Subscription，（subscriber,method）</span></span><br><span class="line"><span class="comment">//Subscription即表示一个订阅，里面保存着一个订阅者，一个当收到事件后的处理方法。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"><span class="comment">//一个订阅者，对应订阅了多少个事件，即一个订阅者订阅了什么事件。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br></pre></td></tr></table></figure><p>了解这两个键值对，就能大概明白这个模块具体思路。</p><p>首先，订阅者Subscriber订阅了事件A，并在onEvent中表达了收到事件后要做什么，表示为method，内部将这个订阅关系保存到系统中，有了一个Subscription（A,method），并将之放到Map&lt;A,Subscription&gt;中，并且，Subscriber对A事件的订阅关系，保存在typesBySubscriber中。发布一个事件到EventBus，EventBus根据这个事件类型找到相关的对应关系，并调用该Subscription中的方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fail-fast</title>
      <link href="/2019/09/03/fail-fast/"/>
      <url>/2019/09/03/fail-fast/</url>
      
        <content type="html"><![CDATA[<h3 id="fail-fast机制"><a href="#fail-fast机制" class="headerlink" title="fail-fast机制"></a>fail-fast机制</h3><p>fail-fast（快速失败）机制在Java集合中都存在，本文就<code>ArrayList</code>分析。 </p><h3 id="fail-fast是什么？"><a href="#fail-fast是什么？" class="headerlink" title="fail-fast是什么？"></a>fail-fast是什么？</h3><p>先从ArrayList的官方解释看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iterators returned by this class's &#123;<span class="doctag">@link</span> #iterator() iterator&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #listIterator(int) listIterator&#125; methods are &lt;em&gt;fail-fast&lt;/em&gt;:&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * if the list is structurally modified at any time after the iterator is</span></span><br><span class="line"><span class="comment"> * created, in any way except through the iterator's own</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ListIterator#remove() remove&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ListIterator#add(Object) add&#125; methods, the iterator will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of</span></span><br><span class="line"><span class="comment"> * concurrent modification, the iterator fails quickly and cleanly, rather</span></span><br><span class="line"><span class="comment"> * than risking arbitrary, non-deterministic behavior at an undetermined</span></span><br><span class="line"><span class="comment"> * time in the future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span></span><br><span class="line"><span class="comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span></span><br><span class="line"><span class="comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span></span><br><span class="line"><span class="comment"> * throw &#123;<span class="doctag">@code</span> ConcurrentModificationException&#125; on a best-effort basis.</span></span><br><span class="line"><span class="comment"> * Therefore, it would be wrong to write a program that depended on this</span></span><br><span class="line"><span class="comment"> * exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators</span></span><br><span class="line"><span class="comment"> * should be used only to detect bugs.&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>翻译：<br>在迭代器创建之后，集合有机构性修改，除非使用迭代器自身的<code>add</code>，<code>remove</code>动作，使用ArrayList上的方法对集合中数据进行任何操作（包括查询和修改），都会触发<code>快速失败</code>机制，表现为抛出<code>ConcurrentModificationExeception</code> 异常…迭代器的快速失败并不能保证，即存在有错误发生也没触发的情况，所以，不该依赖这个依赖异常来写程序，仅是用来检查程序是否有bug</p><p>通俗的个人理解：</p><p>快速失败机制，对于集合上的操作，比如查询，修改，若数据出现不确定的情况，便不再返回一个不确定的结果，而是直接抛出异常，让用户尽快知道有错误发生了。符合程序的<code>确定性</code>的原则。  </p><p>例子：</p><p>遍历过程中使用ArrayList的方法删除元素，在下一次调用迭代器的next（）方法时，抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始一个集合并设置数据</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    list.add(i+<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式1：增强型For遍历</span></span><br><span class="line"><span class="keyword">for</span> ( String e :list) &#123; <span class="comment">//以增强For来遍历集合时，会调用集合内部的迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (e.equals(<span class="string">"1"</span>)) &#123;    <span class="comment">//遍历过程中使用ArrayList的方法删除元素，在下一次调用迭代器的next（）方法时，抛出异常</span></span><br><span class="line">        list.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中，若是使用增强型For，遍历集合类时，本质使用其内部的迭代器来遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式2：增强型For的本质形式（去语法糖）</span></span><br><span class="line">ListIterator&lt;String&gt; lit = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (lit.hasNext()) &#123;</span><br><span class="line">    String e = lit.next();</span><br><span class="line">    <span class="keyword">if</span> (e.equals(<span class="string">"1"</span>)) &#123;</span><br><span class="line">        list.remove(e);   <span class="comment">//使用ArrayList的remove方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式3，使用自身的迭代器删除，不会抛出异常</span></span><br><span class="line">ListIterator&lt;String&gt; lit = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (lit.hasNext()) &#123;</span><br><span class="line">    String e = lit.next();</span><br><span class="line">    <span class="keyword">if</span> (e.equals(<span class="string">"1"</span>)) &#123;</span><br><span class="line">        lit.remove();   <span class="comment">//调用迭代器自身的remove方法，</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部实现原理："><a href="#内部实现原理：" class="headerlink" title="内部实现原理："></a>内部实现原理：</h3><p>List类中有一个变量<code>modCount</code>，记录当前集合结构性修改的次数，（比如增加元素，删除元素都会导致结构性修改），初始为0，在add（），remove（）方法中都会调用<code>modCount++</code>。  迭代器Iterator中有一个变量<code>expectedModCount</code>，用于跟踪List中的<code>modCount</code>的值，正常情况下，这两个值是保持相等的，这样可保证迭代器能够正确无误的遍历所有的元素。若是List自己的删除一个元素，<code>ModCount</code>加1，而迭代器中的<code>ExpectedModCount</code>并没有做修改，迭代器调用<code>next（）</code>方法时，检查到两个值不相同，即抛出异常，表示迭代器已经无法保证正确遍历元素了。若想要遍历中删除，就要使用该迭代器自身的remove方法，该方法会修改<code>expectedModCount</code>与<code>modCount</code>相等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2019/08/29/HashMap/"/>
      <url>/2019/08/29/HashMap/</url>
      
        <content type="html"><![CDATA[<blockquote><p> Map &gt; AbstractMap &gt; HashMap  </p></blockquote><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>翻译：  </p><p>一个键值对的集合。 一个map不能包括重复的key，一个key最多对应一个值。（即通过一个key最多能找到一个值，包括没有值的情况）  </p><p>这个接口是用来替换的<code>Dictionary</code>类，因为<code>Dictionary</code>是一个抽象类，而不是一个接口。  </p><p>Map提供了三种观察集合的方式，包括：</p><ol><li>a set of keys    键的集合</li><li>collection of values 值的集合</li><li>set of key-value mappings    键值对的集合  </li></ol><p>遍历map的顺序，定义为，迭代map并返回集合元素的顺序。每次迭代，得到元素的序列。在具体实现上，每次遍历<code>TreeMap</code>返回的序列顺序是唯一，而<code>HashMap</code>则不唯一。  </p><p>在key是可变的变量（即不用<code>final</code>修饰的变量）时，若是该变量的指向对象改变，Map是没有对该行为负责的。（尽量不要使用final的元素作为key）。Map中是不允许用自身作为它的一个key；若是把自身作为其中一个value，则在比较对象的是否相等的可靠性也不可保证。</p><p>通常的Map的实现都提供两个构造方法，一个无参的，一个Map（Map），接受一个map作为参数来作为初始元素。当然这只是个建议，接口没有强制这个建议手段，但是JDK的中的实现都遵循了这个建议。</p><p>有一些方法是没有具体实现的，所以抛出支持该操作的异常。</p><p>一个Map的实现，可能会对KEY和Value的类型做限制。比如允许key-value为空的，或对键的类型做限制。不顾这些限制会可能抛出异常。</p><p>很多集合框架，都会要求比较的两个对象是非空类型，这里Map不做要求。</p><p>一些操作会有’self-referential’的情形，在遍历这个集合时，无论是直接或间接<code>引用自身</code>，有可能要特殊处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">( Map&lt;? extends K,? extends V&gt; m)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//下面三个即上面提到的是三种视图。</span></span><br><span class="line">    <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">V <span class="title">setValue</span><span class="params">(V value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">equal</span><span class="params">(Object o)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//...一些比较实现，根据Key或Value来排序，或是通过Lamda来暴露比较的算法。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K extends Comparable&lt;? <span class="keyword">super</span> K&gt;,V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过方法，看到Java8提供了default关键字，让接口也能实现方法，（包括声明成员，如下），包括提供了lamda，使得函数也能作为参数。</span></span><br><span class="line"><span class="comment">//    default int value=10;</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiCosumer&lt;? <span class="keyword">super</span> Key,? <span class="keyword">super</span> V&gt; action)</span></span>;</span><br><span class="line">    <span class="comment">//... remove(), replace(),merge()操作</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h2><p>翻译：  </p><p>这个类提供了对<code>Map</code>提供了骨架的实现，减轻了子类对Map实现的负担。</p><p>要是实现一个不可变的Map，（unmodifiable map），只要继承该类并实现<code>entrySet()</code>方法，也就没有<code>add</code>，<code>remove</code>方法的具体实现，若是调用了直接报异常。实现一个可变的Map，就要实现<code>add()</code>, <code>remove()</code>方法了，并且在它的迭代器要同时实现添加移除的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//查询操作</span></span><br><span class="line">    <span class="comment">//size(),isEmpty(),containValues(),containKey() get()</span></span><br><span class="line">    <span class="comment">//比如：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">if</span>(key==<span class="keyword">null</span>)&#123;      <span class="comment">//key为null的情况</span></span><br><span class="line">            <span class="keyword">while</span>(i.hasNext())&#123;     <span class="comment">//先通过hasNext()方法判断在该游标之后是是否仍有元素, 再通过.next()方法获取该元素。</span></span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span>(e.getKey()==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> e.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//key非空的情况</span></span><br><span class="line">            <span class="keyword">while</span>(i.hasNext())&#123; </span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="keyword">if</span>(key.equals(e.getKey()))&#123;</span><br><span class="line">                    <span class="keyword">return</span> e.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改操作</span></span><br><span class="line">    <span class="comment">//put(),remove()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Bulk Operation批量操作</span></span><br><span class="line">    <span class="comment">//putAll(),  clear()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Views 查看</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line">    <span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br><span class="line">    <span class="comment">//keySet(),values(),entrySet()，注意这里的entrySet（）方法是抽象方法。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Comparing and hashing 一些比较，哈希方法的实现</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>翻译：  </p><p>使用了哈希表来实现了<code>Map</code>接口。实现了所有可选的方法，允许key和value为空的情况。<code>HashMap</code>类似<code>HashTable</code>，不同之处在于<code>HashMap</code>不同步的，且允许null的情况。由于使用Hash表实现的方式，所以遍历是出来的元素顺序不保证相同。</p><p>HashMap的在对元素<code>get</code>，<code>put</code>操作时，提供了常量时的性能（时间复杂度为O(1)），前提是哈希函数能够将元素合理地分散在桶子里。（愿译：assuming thehas function disperses the elements properly among buckets.） 遍历集合视图（即遍历所有元素）需要时间复杂度n（n=桶子的数量+所有链表的元素size之和）。所以在设置初始容量（initial capacity）或是加载因子太低（the load factory）,否则遍历性能会很低。</p><p>HashMap有两个参数会决定它的性能，初始容量和加载因子。初始容量就是在在哈希表创建时，桶子的数量，加载因子是表示哈希表多满时（即装元素的桶子数目/所有桶子数目），容量会自动增加。当前元素数量超出capacity*factor之后，哈希表需要rehashed（内部数据结构重建），表的桶子数量大约翻倍。  </p><p>通常说，加载因子默认为0.75，是在时间与空间较合适的选择。加载因子高了，空间利用高，但是在操作上（put，get）花的时间会变高。若是可以提前估计要存放的的数量，来设置初始容量和加载因子是最好不过的，要是设置初始容量大于实际存放的最大值，过程中就可以避免rehashed。</p><p>要是每个entry的<code>hasCode()</code>返回同一值，那么出现一种极端情况，相当于将数据存放在一个链表了，查询速度会很低（O(N)。</p><p>HashMap不是线程安全的，若是有多个线程同时访问一个Map，若有一个线程对Map有结构修改，必须在外部保证其线程安全。结构性调整是比如添加，删除，仅是修改key对应的值是不归于的。具体处理，可以<br> Map m = Collections.syschronizedMap(new HashMap(…));</p><p>在迭代器创建后，有结构性修改发生，除了使用迭代器使用自己的remove方法，会抛出<code>ConcurrentModificationException</code>,即<code>快速失败</code>fail-fast,在面对不可靠的数据时，尽量快的抛出异常而不是允许数据不可靠。但是，也不可能根据抛异常来判断是否可靠,这个异常仅应该用来检测bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;,<span class="title">Clonable</span>,<span class="title">Seriazable</span></span>&#123;</span><br><span class="line">    <span class="comment">//默认容量16，且容量必须是2的次幂</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INIT_CAPACITY = <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAPACITY = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        </span><br><span class="line">        Node(<span class="keyword">int</span> hash,K key, V value, Node&lt;K,V&gt; next)&#123;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来检测fast-failed</span></span><br><span class="line">    <span class="keyword">int</span> modCount;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;e;</span><br><span class="line">        <span class="comment">//试图获取entry，若不为空，则返回其值</span></span><br><span class="line">        <span class="comment">//问题归于找到entry, 如何找到hash值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> :e.value;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> h;</span><br><span class="line">            <span class="comment">//这里为了让hash值分布更加均匀</span></span><br><span class="line">            <span class="comment">//若是一部分的数，生成的都小于2^16，则会使得元素都放在table前面，下面这个操作</span></span><br><span class="line">            <span class="comment">//原本 h=0000 1011    //假设只有8位，32位同理</span></span><br><span class="line">            <span class="comment">//经过这个操作后：0100 1101 </span></span><br><span class="line">            <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); <span class="comment">//这里使用无符号右移，</span></span><br><span class="line">            <span class="comment">//有符号右移需要区分数字的正负，正数右移高位补0，负数右移高位补1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span></span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e ; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span>((tab=table)!=<span class="keyword">null</span> &amp;&amp; (n = tab.length)&gt;<span class="number">0</span> </span><br><span class="line">        &amp;&amp; (first=tab[(n-<span class="number">1</span>)&amp; hash]) !=<span class="keyword">null</span>)&#123;    <span class="comment">//找到的第一个元素是</span></span><br><span class="line">        <span class="comment">//这里n-1 转为二进制 0111 1111 </span></span><br><span class="line">        <span class="comment">//index = 0111 1111 &amp; 0100 1101 = 1100 1101   </span></span><br><span class="line">        <span class="comment">//这里为什么要用n-1再与操作，是因为，Int类型中最高位仅是用来存放符号</span></span><br><span class="line">           <span class="keyword">if</span>((first.hash==hash &amp;&amp; </span><br><span class="line">           ((k=first.key)==key) || (key!=<span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>((e=first.next) != <span class="keyword">null</span>)&#123;    <span class="comment">//first仅仅是作为一个头部，不存放数据</span></span><br><span class="line">               <span class="keyword">if</span>(first <span class="keyword">instanceof</span> TreeNode)&#123;       <span class="comment">//要是表头，即使红黑树，使用红黑树搜索</span></span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);    <span class="comment">//从当前链表（红黑树了）获取合适的节点</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//否则，是一个常规的链表，一个个比对搜搜 </span></span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于普通对象重写的hashcode(), equals()方法的常见问题</p><p>重写一个bean类时，使用idea右键generate重写两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 判断两个不同对象是否相同，先判断对象的class是否相同，再判断关键的属性的是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        A a1 = (A) o;</span><br><span class="line">        <span class="keyword">return</span> a == a1.a &amp;&amp; b == a1.b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 使用工具类算出相应的 hashcode</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Objects.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 对于关注的几个属性，如何生成一个hash的算法</span></span><br><span class="line">      <span class="comment">// 使用质数31乘以当前值，</span></span><br><span class="line">        <span class="keyword">for</span> (Object element : a)</span><br><span class="line">            result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewPager</title>
      <link href="/2019/08/11/ViewPager/"/>
      <url>/2019/08/11/ViewPager/</url>
      
        <content type="html"><![CDATA[<p>ViewPager 其作用是分页展示一个内容，现在Android主流应用布局，如微信，就是主页面是一个ViewPager，底部一个TabLayout构成。用户可以左右滑动来翻页，页上下滚动的多用RecyclerView或ListView来实现，若是要实现左右翻动效果的，Android过去似乎并有一个正统的实现方式。过去可以魔改ViewPager。不过，现在已经出了一个ViewPager2，它参考了RecyclerView的实现，翻动的可以是传动的Fragment，还可以是View。这里，先看看传统ViewPager的实现部分。</p><blockquote><p>什么时候使用适配器？为什么要使用？</p></blockquote><p>我们需要展现一数据集，且这数据集的形式有多种，比如已经获取到的List,或是从数据库Cursor，若是不使用适配器，我们就需要分别展示数据的AListView，ACursorView，这里的两个View都是可以展现对应数据集。而这里的问题在于，其实我们要展示的该类数据的样式，以及与该View的交互是一样了，即没有能复用相同的逻辑。因而，为了不重复，引入适配器，ListView不再直接操作数据源，而是告知适配器我们需要什么操作，比如问问这个数据源总共有几个，第i个的数据是什么，交互的，ListView还可以通知我们要或删除的一项了，而具体的添加，删除工作，就归Adapter来实现了。所以，<strong>引入适配器是为了复用展示和交互的逻辑。</strong></p><p>到此，我们确定三者，ViewPager负责展示数据以及交互，PageAdapter一个作为数据与View的中间桥梁，数据源。这里我们只要分析<code>PagerAdapter</code>，<code>ViewPager</code>.</p><p>PagerAdapter是直接为与ViewPager交互的的接口，其实现有FragmentPagerAdapter,FragmentStatePagerAdapter.两者有所不同应用场景，FragmentPagerAdapter适合哪种页数固定，且页数少的，其创建后就要创建并保留所有的页面FragmentStatePagerAdapter 适合页面较多的，因为该适配器不会去创建所有的页面，只会在需要时再去创建所需的，它还需负责保存和恢复过去的状态。</p><p>ViewPager中有个属性，mOffscreenPageLimit，默认为1，即ViewPager左右需要创建并保留多少个页面，比如，ViewPager会向Adapter预估要，当前项 + 前后* mOffscreenPageLimit的数据。 </p><p>回到PagerAdapter,</p><p>继承它需要实现4个方法，可以说要回答是个问题。</p><p>instantiateItem(container,pos)  如何创建某项destroyItem(container,pos)      如何删除某项getCount()                      总共有几项isViewFromObject(view,key)   确认page view是否已经关联上指定的key值</p><p>其简单版本， </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">view_pager.apply &#123;</span><br><span class="line"></span><br><span class="line">          adapter = <span class="keyword">object</span> : PagerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">val</span> sources = Array&lt;String&gt;(<span class="number">4</span>) &#123;</span><br><span class="line">                  <span class="string">"page <span class="variable">$it</span>"</span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">//创建一个View并添加人该其父视图，</span></span><br><span class="line">              <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">instantiateItem</span><span class="params">(container: <span class="type">ViewGroup</span>, position: <span class="type">Int</span>)</span></span>: Any &#123;</span><br><span class="line">                  Log.d(<span class="string">"wolf"</span>,<span class="string">"instantiate pos:<span class="variable">$position</span>"</span>)</span><br><span class="line">                  <span class="keyword">return</span> TextView(container.context).apply &#123;</span><br><span class="line">                      text=sources[position]</span><br><span class="line">                      container.addView(<span class="keyword">this</span>)</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//直接销毁既可</span></span><br><span class="line">              <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">destroyItem</span><span class="params">(container: <span class="type">ViewGroup</span>, position: <span class="type">Int</span>, obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">                  Log.d(<span class="string">"wolf"</span>,<span class="string">"destroy pos:<span class="variable">$position</span>"</span>)</span><br><span class="line">                  <span class="keyword">if</span> (container.getChildAt(position) == obj) &#123;</span><br><span class="line">                      container.removeView(obj <span class="keyword">as</span> View?)</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//这里直接就用该项的View作为key即ok，</span></span><br><span class="line">              <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isViewFromObject</span><span class="params">(view: <span class="type">View</span>, obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">                  <span class="keyword">val</span> result=view==obj</span><br><span class="line">                  Log.d(<span class="string">"wolf"</span>, <span class="string">"isCreateFromObject: <span class="variable">$result</span>"</span>)</span><br><span class="line">                  <span class="keyword">return</span> result</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> sources.size</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>其实我们再看看FragmentPagerAdapter的实现，也是蛮简单的。它的用的是FragmentManager来管理，创建时，尝试通过 findFragmentByTag(tag)，若找到，即已经添加fragmentManager了，直接attach（fragment),这会引发view的视图树变化，若没有找到，即add(containerId,fragment,tag),注意到是，这里的Fragment都是已经创建好点的，也就是说这里的instantiate和destroyItem仅仅attach和detach而已。不过，注意到的是，这个还是设置了，setPrimaryItem,即设置当前要展示的页面，在设置这个页面之后，并调用了setUserVisibilityHint()方法，通知Fragment此时的状态是否作显示</p><p>看看ViewPager，其直接继承了ViewGroup，那么我就看看三个方法吧，onMeasure(), onLayout(), onDraw()</p><blockquote><p>先猜猜个大概，</p></blockquote><p>其高度肯定是遍历子视图，找到最大的高度，其宽度，在当前页处于首尾页时，加上一个mOffscreenLimit个的宽度，否则，就加两个，当然，不能缺了每个页面的margin。</p><p>放置时，所有子页面并排放即可。绘制时，交个子页面绘制。</p><blockquote><p>实际看看其实现</p></blockquote><p>onMeasure()</p><p>因为我们会添加任意大小的View的，当然我们不希望其宽高随之变化，而是应该由父视图来决定其大小</p><p>…卒</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-note_1</title>
      <link href="/2019/06/05/python-note-1/"/>
      <url>/2019/06/05/python-note-1/</url>
      
        <content type="html"><![CDATA[<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>构造方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span>  //继承自object </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span>  //注意类中方法，必须传递一个形参self</span><br><span class="line">        self.name = name    </span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p>访问限制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span> 与java对应的public, default, protected, private</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">()</span>:</span></span><br><span class="line">    _name  //约定，仍可从外部直接访问，但依照约定，提示使用者应该将其视为私有变量</span><br><span class="line">    __name  //解释器将其编译成 _Student__name, 使用者不能直接使用__name来访问了，可以说，将门槛提更高来告知限制</span><br></pre></td></tr></table></figure><p>继承多态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'go go go ...`)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Duck(Animal):</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    def run(self):</span></span><br><span class="line"><span class="string">        print('</span>duck run slowly<span class="string">')</span></span><br></pre></td></tr></table></figure><p>Duck 可以拥有父类的成员，概念和java一样<br>只不过的，作为动态类型的python，在方法调用时，假设要传入一个Animal类型来使用其run方法。<br>java要求其参数必须是Animal的类型实例，而python不做要求，只要其对象实例拥有run方法既可。</p><p>判断对象是否是某个类的实例，可以使用 isInstance(object,Class) 来判断object是否是Class的类型</p><p>获取对象信息：</p><p>使用type(), 判断对象类型。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">123</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(<span class="string">'123'</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> `<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line">a = Animal()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a) </span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Animal</span>'&gt;   //即一个<span class="title">main</span>线上的<span class="title">Animal</span>类型</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">额外的，还可以判断一个对象是否是函数类型。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">import</span> <span class="title">types</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">type(fn) == types.FunctionType  //<span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>使用isInstance(obj,cls) 判断obj是否是cls类型</p><p>使用 dir() 列出一个对象的所有属性和方法，返回一个字符串的list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(<span class="string">'123'</span>)</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>,</span><br><span class="line"> <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__getnewargs__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>,</span><br><span class="line">  <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mod__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, </span><br><span class="line">  <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rmod__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>,</span><br><span class="line">   <span class="string">'capitalize'</span>, <span class="string">'casefold'</span>, <span class="string">'center'</span>, <span class="string">'count'</span>, <span class="string">'encode'</span>, <span class="string">'endswith'</span>, <span class="string">'expandtabs'</span>, <span class="string">'find'</span>, <span class="string">'format'</span>, <span class="string">'format_map'</span>, </span><br><span class="line">   <span class="string">'index'</span>, <span class="string">'isalnum'</span>, <span class="string">'isalpha'</span>, <span class="string">'isascii'</span>, <span class="string">'isdecimal'</span>, <span class="string">'isdigit'</span>, <span class="string">'isidentifier'</span>, <span class="string">'islower'</span>, <span class="string">'isnumeric'</span>, </span><br><span class="line">   <span class="string">'isprintable'</span>, <span class="string">'isspace'</span>, <span class="string">'istitle'</span>, <span class="string">'isupper'</span>, <span class="string">'join'</span>, <span class="string">'ljust'</span>, <span class="string">'lower'</span>, <span class="string">'lstrip'</span>, <span class="string">'maketrans'</span>, <span class="string">'partition'</span>, </span><br><span class="line">   <span class="string">'replace'</span>, <span class="string">'rfind'</span>, <span class="string">'rindex'</span>, <span class="string">'rjust'</span>, <span class="string">'rpartition'</span>, <span class="string">'rsplit'</span>, <span class="string">'rstrip'</span>, <span class="string">'split'</span>, <span class="string">'splitlines'</span>, <span class="string">'startswith'</span>, </span><br><span class="line">   <span class="string">'strip'</span>, <span class="string">'swapcase'</span>, <span class="string">'title'</span>, <span class="string">'translate'</span>, <span class="string">'upper'</span>, <span class="string">'zfill'</span>]</span><br></pre></td></tr></table></figure><p>有很多内置方法，比如<em>_add</em> ，字符串拼接时，就是调用了这个方法，使用上，直接使用 ‘+’ ，重载操作符。<br>由此，可以联想到，在我们自定义的类中，也可以重载这些方法。</p><p>为了方便，判断一个对象是否某方法或属性，我们可以用 getattr(), setattr(), hasattr()</p><p>比如： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readImage</span><span class="params">(fp)</span>:</span>      //判断对象fp是否read方法，若是有读取数据返回，否则返回<span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span>(hasattr(fp, <span class="string">'read'</span>):</span><br><span class="line">        <span class="keyword">return</span> readData(fp)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>类属性，实例属性</p><p>感觉这个有点神坑啊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">()</span>:</span>        //定义了一个Student类型，并赋予了一个类属性 name</span><br><span class="line">    name = <span class="string">'student'</span></span><br><span class="line">    </span><br><span class="line">s = Student();  //创建一个实例</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name      //通过实例，可以访问到类属性</span><br><span class="line">student</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'wolf'</span> //定义一个对象属性，而且与类属性重名</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name  //访问该属性，实例属性优先于类属性。（实例属性屏蔽类属性）</span><br><span class="line">wolf</span><br></pre></td></tr></table></figure><p>实例属性，尽量不要定义跟类属性一样了</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ScrollView自动滚动至获取焦点的View</title>
      <link href="/2019/04/27/ScrollView%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8%E8%87%B3%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E7%9A%84View/"/>
      <url>/2019/04/27/ScrollView%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8%E8%87%B3%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E7%9A%84View/</url>
      
        <content type="html"><![CDATA[<p>遇到了个好问题，以及一个好答案，记之</p><p>问：在xml布局中，ScrollView 里面包含一个RecyclerView，页面启动之后，直接滚动RecyclerView的位置了。答：分析流程：</p><ol><li>在Activity加载该xml布局后，通过<code>LayoutInflater.inflater(XmlPullParser parser, ViewGroup root, boolean attachToRoot)</code>.</li></ol><p>加载并解析xml文件后，便开始构造View树。 rInflater(…)</p><p>其内部，是创建View，并递归加入到已有的View中。</p><p>addView（child，index，LayoutParams params）</p><p>其内部调用了addViewInner（child,index,params,preventRequestLayout) //addView之后，可以选择是否立即刷新当前布局的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在添加一个拥有焦点的View时，递归为找到具体的view，其真有获有焦点</span><br><span class="line">final boolean childHasFocus = child.hasFocus();</span><br><span class="line">if (childHasFocus) &#123;</span><br><span class="line">    requestChildFocus(child, child.findFocus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看requestChildFocus()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//看到这个，可以直接阻止上层View获取焦点，这个蛮方便的</span></span><br><span class="line"><span class="keyword">if</span> (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We had a previous notion of who had focus. Clear it.</span></span><br><span class="line">        <span class="keyword">if</span> (mFocused != child) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFocused != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mFocused.unFocus(focused);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mFocused = child;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="comment">//请求</span></span><br><span class="line">         <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.requestChildFocus(<span class="keyword">this</span>, focused);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestChildFocus</span><span class="params">(View child, View focused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INPUT_RESIZE) &#123;</span><br><span class="line">        Log.v(mTag, <span class="string">"Request child focus: focus now "</span> + focused);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//会重绘</span></span><br><span class="line">    checkThread();</span><br><span class="line">    scheduleTraversals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，可以知道，焦点会在加载之后确定。</p><p>另一个问题，为什么在Scrollview中，为什么会滚动到，获取的到焦点的View</p><p>在在ScrollView的重绘, onLayout()有，有一个mChildToScrollTo属性，若是其不为空，会移动到该View位置。</p><p>而在requestChildFocus中，已经为其赋值。</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看《时间简史》感想</title>
      <link href="/2019/04/23/%E7%9C%8B%E3%80%8A%E6%97%B6%E9%97%B4%E7%AE%80%E5%8F%B2%E3%80%8B%E6%84%9F%E6%83%B3/"/>
      <url>/2019/04/23/%E7%9C%8B%E3%80%8A%E6%97%B6%E9%97%B4%E7%AE%80%E5%8F%B2%E3%80%8B%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>昨天晚上没睡着，放纵自己又在瞎折腾了一会，看了一会书才睡下，觉得有些东西挺有受益的，故记录之。</p><h3 id="惊叹逻辑的相通"><a href="#惊叹逻辑的相通" class="headerlink" title="惊叹逻辑的相通"></a>惊叹逻辑的相通</h3><blockquote><p>科学的终极目的是用简单的理论去描述整个宇宙。… 毕全功于一役地设计一种能描述整个宇宙的理论，看来是非常困难的。反之，我们将这问题分成许多小块，并发明许多部分理论。每一部分理论描述和预言有一定有限范围的观测，同时忽略其他量的效应或用一组简单的数来代表之。</p></blockquote><p>遇到问题，分而克之。在生活中，有同样的思路，我们试图追究怎么做才是最好的，把人生分阶段，每个阶段做最优解。阶段长度定了极短，可谓”今朝有酒今早醉”，极长，便容易茫然自己找不到方案，或是”活在未来”，也许”活在当下”是个褒义词，其本质应便是规划的长度刚好是最优的，过程中未知对错，直至终止条件出现（算法中的动态规划）。<br>同时，这般理论，与其他领域的也是相通的。程序算法中的常见的思想，在马克思中对于绝对真理与相对真理的思辨。</p><blockquote><p>可能这方法是全错的。如果宇宙中的每一件东西都以非常基本的方式依赖于其他的任何一件东西，很可能不能用隔离法研究问题，部分去逼近其完备的答案。</p></blockquote><p>反思，辩证看待自己的思想，知道其局限性，也更加容易接纳新的更优的思想。（贪心算法的局限性）</p><blockquote><p>尽管如此，这肯定是我们在过去取得进展所用的方法。如牛顿引力理论。。。</p></blockquote><p>否定之否规律。</p><p>看了第一章的感觉，感慨作者的逻辑的清晰感慨作者的逻辑的清晰，思想还可以这么表达出来的。</p><h3 id="四维空间"><a href="#四维空间" class="headerlink" title="四维空间"></a>四维空间</h3><blockquote><p>点 &gt; 圆 &gt; 圆锥 &gt; **(四维空间)</p></blockquote><p>试着感受前后者，感受其不同，我们能直观的感受到3维的事物，也能容易体会更加低维度的事物，如此递推，想象四维。（想象4维生物看待我们，应是能”一眼”看尽我们的一生）</p><h3 id="宿命论"><a href="#宿命论" class="headerlink" title="宿命论"></a>宿命论</h3><p>看了一个心理学读者的观感总结，按现有的物理学，更偏向认同人一生的”决定论”。固然”我”不能改写未来，但是”我”能参与展开的未来不断改写（我的自我认同）。《三生有幸》</p>]]></content>
      
      
      <categories>
          
          <category> 看书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LoadingLayout</title>
      <link href="/2019/04/21/LoadingLayout/"/>
      <url>/2019/04/21/LoadingLayout/</url>
      
        <content type="html"><![CDATA[<h3 id="自定义LoadingLayout的笔记"><a href="#自定义LoadingLayout的笔记" class="headerlink" title="自定义LoadingLayout的笔记"></a>自定义LoadingLayout的笔记</h3><p>在学习<a href="https://github.com/scwang90/SmartRefreshLayout" target="_blank" rel="noopener">SmartRefreshLayout</a>库当中看到了一个<a href="https://github.com/czy1121/loadinglayout" target="_blank" rel="noopener">LoadingLayout</a>, 用于在请求数据时，状态改变，如 <code>empty</code> &gt; <code>loading</code> &gt; <code>error</code> &gt; <code>normal</code>。日常的app还是会经常使用的，每次实现很麻烦，所以将其维护成一个库还是挺好的（开发效率为王）。看了作者的实现之后，发现其中确实有些东西是很值得学习，原版实现较简单，因而维护先自己的版本。（方便自己的整理思路）</p><h3 id="类库描述"><a href="#类库描述" class="headerlink" title="类库描述"></a>类库描述</h3><p>作为一个View，内部维护有4种状态：</p><ol><li>空白   </li><li>加载中 </li><li>错误</li><li>正常内容</li></ol><p>对外提供修改状态，页面展现相应的内容页面，创建<code>LoadingLayout</code>中，提供对状态对应页面的展现配置。提供了在style.xml配置，或在代码中配置。配置<code>normal</code>状态没有意义，所以可以为其余三个状态配置对应的资源文件。<code>normal</code>状态的是处于<code>LoadingLayout</code>的子视图，配置这个关系，可以在xml文件中配置，也提供了<code>wrap(view)</code>,‘wrap(activity)’方法手动配置，无需修改xml文件。 </p><p>由于空白页，错误页都是常见的，一般会由一个图片和描述组成，项目不同只要修改相应的图片和文字，所以，类库提供了直接配置相应图片，文字。在错误页提供了”重新加载接口”。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>利用FrameLayout来存放各个状态的View，当需要展现特定View时，set all view gong and set target view to visible.</p><p>更具体的说，内部维护了Map&lt;resId,View&gt;，并且该数据时懒加载的，在第一次加载对应View时inflate相应的ResId，并对加载的View配置相应的属性（如图片，文字）</p><p>遇到了一个问题：在配置style文件中的dimension中，注意引用指向引用的问题，有种指针的味道。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wifi连接手机</title>
      <link href="/2019/03/09/wifi%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA/"/>
      <url>/2019/03/09/wifi%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前提知识：</p><ol><li>手机电脑连接，手机作为服务器，电脑作为客户端。</li><li>手机服务器(adbd)，可以配置接受usb连接（默认），也可以配置tcpip连接（即我们想要的通过wifi连接）。</li></ol></blockquote><p>下面分为两种情况：</p><h4 id="一-有usb线，手机没有root，连接后不用usb线"><a href="#一-有usb线，手机没有root，连接后不用usb线" class="headerlink" title="一. 有usb线，手机没有root，连接后不用usb线"></a>一. 有usb线，手机没有root，连接后不用usb线</h4><blockquote><p>先用usb连接到手机服务器，配置手机服务器接受tcpip连接</p></blockquote><p>具体步骤：</p><ol><li><p>手机、电脑确保连在同一个局域网</p></li><li><p>将手机的服务器设置接受tcpip连接（此后可以断开usb连接了）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb  tcpip 5555</span><br></pre></td></tr></table></figure></li><li><p>连接手机</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect IP   # IP替换自己手机的IP，可以通过wifi设置中查看，如（192.168.0.111）</span><br></pre></td></tr></table></figure></li></ol><h5 id="二-无usb线，手机需root"><a href="#二-无usb线，手机需root" class="headerlink" title="二. 无usb线，手机需root"></a>二. 无usb线，手机需root</h5><ol><li><p>在root过的手机上装一个shell终端（网上下载一个），设置手机服务器接受tcpip连接</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su   # 切换到超级管理员</span><br><span class="line">setprop service.adb.tcp.port 5555# 配置接受tcpip端口为5555， 改为-1 即接受usb连接</span><br><span class="line">stop adbd # 下面两行为重启adbd服务，使其配置生效</span><br><span class="line">start adbd</span><br></pre></td></tr></table></figure></li><li><p>连接手机，如上面的方法中的步骤3</p></li></ol><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>默认adbd接受usb连接，关键一步就是，将adbd接受tcpip连接。用usb连接后修改，或手机root直接修改都可以。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
