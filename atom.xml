<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>萝卜平</title>
  
  <subtitle>没想好的一个副标题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wjploop.github.io/"/>
  <updated>2021-10-17T02:38:01.321Z</updated>
  <id>http://wjploop.github.io/</id>
  
  <author>
    <name>萝卜平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈对声明式框架的理解</title>
    <link href="http://wjploop.github.io/2021/08/28/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://wjploop.github.io/2021/08/28/谈谈对声明式框架的理解/</id>
    <published>2021-08-28T08:58:51.000Z</published>
    <updated>2021-10-17T02:38:01.321Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚把<code>React</code>的官方入门Demo敲了一遍，感觉对声明式的框架 <code>React,Flutter,Android-Compose</code>都有了一些认知，故想记录下。</p><p>我开始学习的是Flutter，看了文档，敲Demo，对比Android原生开发的一些熟悉概念，后面看到Android也推出了Compose，又跑去玩玩Compose，发现两个框架都在”抄” React，忍不住去认认这”祖师爷”，通过不同框架对同一概念的实现，从而加深对声明式框架的理解。</p><p>前端，主要干的活，定义如何展示数据，处理数据和视图的关系，处理事件到来后数据变化，重新渲染数据成视图。</p><p>其中，由于数据在视图中是变化的，故，我们将之称为状态state，而对于一部分数据对本视图而言，它是不可变的，我们称之为属性props，要注意的是这里的可变或不可变是对于本视图而言的，一般，父亲的state对孩子的来说就是props。而，事件通常分为用户产生，如触摸事件，和系统产生，如时钟滴答导致状态进入下一个生命周期，我们称之为动作action。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = props + state 　// 数据由不变的属性和可变状态组成</span><br><span class="line">view = render(model)    // 视图通过渲染model形成</span><br></pre></td></tr></table></figure><p>此后便是声明式和传统的开发的区分</p><p>传统的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">action(model) &gt;&gt; diff   // 事件过来进行处理，产生一些变化diff</span><br><span class="line">new_view = view + renderDiff(dff)   // 根据这个diff渲染出一部分区别的view,　再将这个差别view融入原来的view以形成新的view</span><br></pre></td></tr></table></figure><p>存在的问题是，我们渲染数据的逻辑变得很复杂，为何？一个事件，产生一个变化diff，需要对这个diff添加新的渲染代码，即随着事件的远远不断地到来，我们要不断地维护更新这个视图树，随着事件变多，往往会出现，model和view不同步的情况，因为我们在修改model的同时，也要同时修改view。</p><p>而声明式的方法是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">action(model) &gt;&gt; new_model  // 事件过来产生一个新的model</span><br><span class="line">new_view = render(new_model)    // 由于新的model和原来的model结构完全一致，故，我们可以使用原来的render方法</span><br></pre></td></tr></table></figure><p>这样，当定义好一个渲染逻辑后，只要model的结构不变，我们就可以不用改变原来的render方法，从而保持渲染逻辑的简单。</p><p>以上，是对声明式框架的理解，以下做一些额外的思考。</p><p>若论性能而言，传统开发更优，但是声明式开发模式更注重开发效率和代码维护性。 以此，声明式开发是未来的一种趋势。</p><p>传统方式，直接修改原来数据，然后视图同步数据的修改，而声明式开发，复制了全部的数据，修改数据后交给视图一个全新的数据镜像重新渲染。根据这点，声明式要使用更多的内存和更频繁的对象销毁回收，因此在利用计算机性能上效率低。但，从历史趋势的趋势上声明式开发是未来，一方面，计算性能在增加，另一方面，降低编程心智负担一直我们追求的目标；这个论证过程也可从编程语言的发展史得到印证。</p><p>而在框架的具体实现上，性能上也做了很多优化。Flutter，从用户描述到渲染经过了 widget &gt; element &gt; renderObject的过程，widget是我们对一个组件的最简单的描述定义，element表示了其组件的关系树，而renderObject才是真正用于渲染的视图树。其作用是，导致widget对象都很小，回收成本低，而真正的渲染树，在widget修改时，对应渲染树只是增量更新，而不是和widget一样全量更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨晚把&lt;code&gt;React&lt;/code&gt;的官方入门Demo敲了一遍，感觉对声明式的框架 &lt;code&gt;React,Flutter,Android-Compose&lt;/code&gt;都有了一些认知，故想记录下。&lt;/p&gt;
&lt;p&gt;我开始学习的是Flutter，看了文档，敲Demo，对比
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写简历时的烦躁</title>
    <link href="http://wjploop.github.io/2021/07/20/%E5%86%99%E7%AE%80%E5%8E%86%E6%97%B6%E7%9A%84%E7%83%A6%E8%BA%81/"/>
    <id>http://wjploop.github.io/2021/07/20/写简历时的烦躁/</id>
    <published>2021-07-20T15:09:25.000Z</published>
    <updated>2021-07-21T11:59:26.360Z</updated>
    
    <content type="html"><![CDATA[<p>感受到自己的目前的工资很低后，又产生了换工作的念头，找到原来的简历后，发觉之前的工作经历描述不太恰当，想要更新简历，修改过程中感觉十分烦躁，故想记录下当下的心情，并尝试理清烦躁的源头。</p><p>从何说起呢？</p><h3 id="为何产生换工作的念头？"><a href="#为何产生换工作的念头？" class="headerlink" title="为何产生换工作的念头？"></a>为何产生换工作的念头？</h3><p>简单说，工资低了，在深圳工作三年工资14k，低于行业水平了。对比其他人的工资后，感受到了这点，越想越忧郁。<br>以下列举下其他人工资的例子：</p><ul><li>听同学转述，有人换行过来搞Android去了vivo外包都有19k</li><li>转行过来的同事告知，去华为外包至少也有15k，而且公积金是按工资全额12%交的，而目前自己是按工资5k的5%缴纳</li><li>看到V站一网友专科学历5年经验去了华为外包有30k+</li><li>曾今计算机社团的部分同学进了中大厂，深感自己好菜</li></ul><p>对比以上例子后，感觉自己不该混的如此惨的。</p><h3 id="我不服气的理由"><a href="#我不服气的理由" class="headerlink" title="我不服气的理由"></a>我不服气的理由</h3><p>对于计算机，这是我热爱而选择的方向啊。</p><p>高中时期，虽不如一些大佬们有计算机竞赛的环境，我对手机刷机等东西是很热衷的，志愿是自己坚定选择了计算机。</p><p>大学期间，加入了计算机社团，逃了挺多课去实验室学习；基本是自学入门了Java、Android，认真看了一些至今还觉得不错的书，如《How Tomcat Works》、《Http图解》。</p><p>参加工作后，仍记得刚第一年接触到RxJava时那份欣喜，感叹其巧妙，不禁在QQ空间发了一个说说。</p><p>至今，我陆陆续续刷了三百多道LeetCode题，虽是为了准备面试，还是感受到了算法思想的魅力。</p><h3 id="反思下自己失败的原因"><a href="#反思下自己失败的原因" class="headerlink" title="反思下自己失败的原因"></a>反思下自己失败的原因</h3><ol><li>浑浑噩噩地工作。</li></ol><p>热爱编程，能感受到编程的乐趣，并不能在求职中脱颖而出。毕竟，所谓热爱是一个非常主观的评价，在求职时，还是要根据展现出来的能力来评判。如何展示能力？ 似乎有很方面可以展示，毕业时考察学校、竞赛经历、学分等，而我学校一般本科，竞赛没有，类似的只有参加一校内大创、学分绩点不突出。毕业后，考察工作经历、开源经历，而我，毕业后进入的都是一些小作坊般的公司，工作经历拉跨，在开源上，我也没有诸如上千start的项目。</p><p>而这些，我能做的，没有努力准备。</p><ol start="2"><li>不愿承受压力，在一些关键的时刻，我选择逃避居多。</li></ol><p>大学时，一次性过了四级后，本应认真准备六级。学校不要求六级，之后六级考试也就次次裸考，最终未过六级成为我大学生涯一大憾事。我认为，当觉得自己有能力却没有做到时，便为遗憾吧。<br>为何觉得自己有能力过呢？<br>女票与我同水平的英语能力，认真做了几套模拟卷过了，而我在一次失败的考研经历中，英语成绩考了82分，以考研反映的英语水平按理可以过六级的。</p><p>对于求职，我也倾向于逃避居多。<br>写简历，如何恰当地介绍自己是一件困难的事。由于自己的曾今经历并不出色，在会回顾自己时，是很痛苦的。当自己不敢面对自己的失败的经历时，在下次的求职中，所犯的错误仍会存在。在一次次失败过程中，马太效应表现突出，弱者恒弱。</p><h3 id="相信自己，去弥补遗憾吧"><a href="#相信自己，去弥补遗憾吧" class="headerlink" title="相信自己，去弥补遗憾吧"></a>相信自己，去弥补遗憾吧</h3><p>我仍相信自己是可以的，愿遗憾能成为我的动力。</p><p>如何相信自己？</p><p>信心不会凭空产生，从内心的小骄傲寻找。</p><p>我更认同大家的先天智力是差不多，后天的培养更为重要。</p><p>认识、自律，相信明天更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;感受到自己的目前的工资很低后，又产生了换工作的念头，找到原来的简历后，发觉之前的工作经历描述不太恰当，想要更新简历，修改过程中感觉
十分烦躁，故想记录下当下的心情，并尝试理清烦躁的源头。&lt;/p&gt;
&lt;p&gt;从何说起呢？&lt;/p&gt;
&lt;h3 id=&quot;为何产生换工作的念头？&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="日记" scheme="http://wjploop.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit</title>
    <link href="http://wjploop.github.io/2021/07/10/Retrofit/"/>
    <id>http://wjploop.github.io/2021/07/10/Retrofit/</id>
    <published>2021-07-10T07:08:41.000Z</published>
    <updated>2021-07-21T11:59:26.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体认识"><a href="#整体认识" class="headerlink" title="整体认识"></a>整体认识</h2><p>Retrofit 用接口中的方法和注解来描述一个HTTP请求，用户只用关注接口如何描述这个请求，而不用关注内部的具体实现。它将网络请求中，封装Request对象，解析Response对象等模板代码封装了起来，使得使用者<em>只要描述做什么，而无需关心怎么做</em>。</p><p>内部网络请求部分依赖了OkHttp,这样，解析方法后，就是OkHttp的工作了，创建Request，解析Response，而在这两个过程，涉及到数据（json, xml, 二进制（protobuf)）与Java对象的转换，即数据序列化/反序列，这里Retrofit没有新造轮子，而是提供一个适配器，让用户选择合适自己需求的工具，完美践行了<em>对扩展开放</em>的原则。</p><h2 id="感叹细节实现"><a href="#感叹细节实现" class="headerlink" title="感叹细节实现"></a>感叹细节实现</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>关于这个设计模式，说下自己的理解。</p><p>代理，需要一个服务<code>ServiceA</code>，存在现有的类（代理目标类<code>Obj</code>）可以满足或满足部分需求，这时，假设想让<code>User</code>也拥有提供该服务的能力，我们不是直接继承<code>Obj</code>， 而时将该服务抽象为一个接口<code>ProvideServiceA</code>，表示具备可以提供这个服务A，此时，真正提供具备这个服务实现类为<code>Obj</code>，而我们的<code>User</code>也想拥有这份能力，可<code>User</code>又不但仅有这份能力，它还可能拥有A,B,C能力，故，它在是实现了 <code>ProviderServiceA</code>接口，但不是自己实现，而是直接使用<code>Obj</code>来提供该服务。</p><p>简单说，就是声明了具备某个服务的能力后，内部提供该接口的实现类的实例，在方法中转发该消息到实例来完成。</p><p>可以发现，当有一个类可以提供某个服务后，我们不是简单继承它来表示具备有该服务能力，而是添加一个接口，表示是是实现该接口的类都具备有这份能力，这样，我们会发现，我们需要额外引入一个接口类，这是不是Java不支持多继承导致的额外成本呢？</p><p>这个问题我无法判断。</p><p>在Java的概念中，接口表示一份契约，只是表示提供了某个服务，具体的实现延迟到了具体的实现类实现。  </p><p>一个复杂的类，可以实现多个接口，它表示可以提供一系列服务的类，这些服务对外形成了一个整体的概念，而在实现方法中，又可以划分为子服务，在内部使用其他自服务的实例来完成，以这个概念来看，我觉得这样的思考方法非常符合<code>分治</code>的思维，将大问题拆分为子问题，在子问题的实现上，可能又会继续拆分。大问题和子问题之间的关系，完成依照它们的接口来完成，不会跟他们的子问题实现产生联系，这样，在查看代码时，使得我们很容易在了解这一个层次上类关系，而不是陷入子问题实现的细节中。       </p><p>好吧，扯得有点远了。<br>代理模式在印象中有一个案例是，在Android插件化中，对于Android四大组件类，我们会对他们进行插桩，在Manifest清单文件中声明一个ProxyActivity，而在我们得插件类PluginActivity中，虽然我们实现了Activity得方法，但是其具体得实现是转发给ProxyActivity来是实现的，比如 <code>findViewById()</code>,<code>getAssertManager()</code>方法，因为即使我们在插件模块中创建了Activity实例，我们也不能直接使用相关的方法，因为这个Activity是没有在Android系统中注册，系统在处理Intent时是找不到该Activity。</p><p>而动态代理，区别于静态代理需要声明一个接口，在目标类和代理中都要是实现接口方法，动态代理不需要在编译时引入接口类，在调用代理类方法时，除了转发给目标类对应方法，也可以添加自己的增强代码（日志、额外操作等）。</p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整体认识&quot;&gt;&lt;a href=&quot;#整体认识&quot; class=&quot;headerlink&quot; title=&quot;整体认识&quot;&gt;&lt;/a&gt;整体认识&lt;/h2&gt;&lt;p&gt;Retrofit 用接口中的方法和注解来描述一个HTTP请求，用户只用关注接口如何描述这个请求，而不用关注内部的具体实现。它
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SparseArray</title>
    <link href="http://wjploop.github.io/2021/07/07/SparseArray/"/>
    <id>http://wjploop.github.io/2021/07/07/SparseArray/</id>
    <published>2021-07-07T08:18:29.000Z</published>
    <updated>2021-07-14T11:17:57.912Z</updated>
    
    <content type="html"><![CDATA[<p>给自己一个自认为熟悉的感念，表达出来能得到多少分？</p><p>是的，我认为我对 <code>SparseArray</code> 熟悉，可当我要表述这个数据结构时，我该怎么表达呢？</p><h3 id="首先，描述使用范围，对比HashMap"><a href="#首先，描述使用范围，对比HashMap" class="headerlink" title="首先，描述使用范围，对比HashMap"></a>首先，描述使用范围，对比HashMap</h3><p><code>SparseArray</code> 适用于key-value结构的数据，相比于Java基础库提供的通用的 <code>HashMap</code>，<code>SparseArray</code> 限制了key只能为int类型，可以节省存储空间，在数据范围小时存取效率优于 <code>HashMap</code>。</p><p>为何省空间？</p><p>其key直接使用了基本类型int，不同于HashMap存储时经过装箱使用Integer，而且，当确定value也是一种基本类型时，可以使用对相应得SparseXXXArray，比如对于 &lt;Integer,Integer&gt;，可以使用 <code>SparseIntArray</code>，这样value也可以存储在基本类型数组，而基本类型所占内存是远小于对象的。</p><p><code>SparseArray</code>内部有两个数组，<code>mKeys</code>, <code>mValues</code>, key直接升序放置在 <code>mKeys</code>数组中，其插入过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; binarySearch -&gt; index </span><br><span class="line">    put key in mKeys[index]</span><br><span class="line">    put value in mValues[index]</span><br></pre></td></tr></table></figure><p>将key转换成index是一次二分查找得过程，其要求key在数组中有序的。</p><p>而 HashMap 其内部可以看作有一个 <code>tables</code>，元素类型是一个Entry&lt;Key,Value&gt;，其插入过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key -&gt; hash -&gt; index</span><br><span class="line">     h = key.hashCode()</span><br><span class="line">     hash = h ^ ( h &gt;&gt;&gt; 16) </span><br><span class="line">     ensure hash &lt; n ,(n = table.length)</span><br><span class="line">     index = hash &amp; (n - 1)   // 依赖n为2的k次方</span><br></pre></td></tr></table></figure><p>生成hash时，将高16位与低位异或，高16位相当于取非了，从而把高位的信息分配到低位上，这样做的原因是，最后我们可以利用到的高位的信息。<br>为何？假设 n = table.length &lt;= pow(2,16)，那么在转移成index时，我们仅仅利用到了hash的低16位。</p><p>生后hash后，要确保hash值能在范围n里面，其思路是指截取n包括的低比特位，大于n的比特位都丢掉的，这样便得到所需的index。</p><p>使用index时，理想情况下，table[index]没有元素，即无hash冲突。<br>冲突时，转为链表，其实存储时，tables存储的就是链表节点，甚至为树节点。<br>存在类存在这样的继承关系，Entry &gt; Node &gt; TreeNode。    </p><p>两者都存在从 key 到 index的过程，理论上，可以看到查找时间复杂度，前者为 O(logN)，后者为 O(1)，似乎后者更胜一筹。 但应了解到，这里说的时间复杂度是简化分析后的结果，忽略了复杂度前面的常量，前者常量可能是1，后者可能是50，当数据量N比较小时，假设N=20，<code>1 * log2(20) &lt; 50 * 1</code>实际上是前者更快一点的。这一点，做题时也有所体会，有时暴力比最优解更快，原因是用例N太小了。 </p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除时用于标记某坑位，避免每次删除时都要挪动元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object DELETED = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 是否有可能清理DELETED垃圾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mGarbage = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键两个数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mKeys;</span><br><span class="line">    <span class="keyword">private</span> Object[] mValues;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSize;</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找到这个key应该放在哪？</span></span><br><span class="line">    <span class="comment">// 这个二分查找，特别之处在于当找不到时，返回该插入下标的取非（不是相反数吧，取反+1才是，不纠结）</span></span><br><span class="line">    <span class="comment">// 取非必然为负数，因为首位0改为1了,这样用负数表示不能存在该key，而且还把该插入的下标变相地保存了下来</span></span><br><span class="line">    <span class="comment">// 是我孤陋寡闻了</span></span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 存在已放置的 key 相同，直接替换（并没有HashMap的替换与否的策略）</span></span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 转为该插入下的下标</span></span><br><span class="line">        i = ~i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发现居然那个坑是无用的，直接替换，免除数组插入的困扰</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 坑位使用完了，且可能存在垃圾，尝试回收下</span></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            <span class="comment">// 思路就是移除mValues数组中DELETED无效元素，有效元素往前移</span></span><br><span class="line">            <span class="comment">// JVM老年代垃圾清除算法思路（更追求省内存，碎片整体）</span></span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将key插入到mKeys的i位置上</span></span><br><span class="line">        <span class="comment">// mSize + 1 == mKeys.length 时，扩容 currentSize &lt;= 4 ? 8 : currentSize * 2，创建新的数组复制原来的元素</span></span><br><span class="line">        <span class="comment">// 即使不需要扩容，也需要移动 i 位置之后元素后移一位</span></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询-无需整理"><a href="#查询-无需整理" class="headerlink" title="查询,无需整理"></a>查询,无需整理</h4><p>通过key来查询，不需要整理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> key, E valueIfKeyNotFound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用标记，我们确认某个key不存在，或已经被删除</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || mValues[i] == DELETED) &#123;</span><br><span class="line">        <span class="keyword">return</span> valueIfKeyNotFound;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) mValues[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询，需整理"><a href="#查询，需整理" class="headerlink" title="查询，需整理"></a>查询，需整理</h4><p>发现依赖了index的查询需要gc,当然还包括插入时也得gc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    if (mGarbage) &#123;</span><br><span class="line">        gc();</span><br><span class="line">    &#125;</span><br><span class="line">    return mSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int keyAt(int index) &#123;</span><br><span class="line">    if (mGarbage) &#123;</span><br><span class="line">        gc();</span><br><span class="line">    &#125;</span><br><span class="line">    return mKeys[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>可以欣赏的一点就是，频繁删除元素后，不会马上整理Values数组，而时延后到查询/插入时才会整理，整理就是清除无用的DELETED坑位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    delete(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeReturnOld</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            <span class="keyword">final</span> E old = (E) mValues[i];</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>另外，SparseXXXMap都要求Key必须为int，若是key不是int，可以用ArrayMap，大略看了下，相似度挺高的，大致是将key转为hash作为key来排序。</p><p>好了，发现自己表达起来确实很着急~对比大佬的<a href="https://juejin.cn/post/6844903961963528199#heading-10" target="_blank" rel="noopener">博文</a></p><p>别人家写的，虽然自己也能感受到的，但表达出来还是很困难。</p><p>引用大佬总结的三个关键字，<em>双数组，二分查找，DELETED标记</em>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给自己一个自认为熟悉的感念，表达出来能得到多少分？&lt;/p&gt;
&lt;p&gt;是的，我认为我对 &lt;code&gt;SparseArray&lt;/code&gt; 熟悉，可当我要表述这个数据结构时，我该怎么表达呢？&lt;/p&gt;
&lt;h3 id=&quot;首先，描述使用范围，对比HashMap&quot;&gt;&lt;a href=&quot;#首
      
    
    </summary>
    
    
      <category term="Android" scheme="http://wjploop.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>关于并发</title>
    <link href="http://wjploop.github.io/2021/06/19/%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91/"/>
    <id>http://wjploop.github.io/2021/06/19/关于并发/</id>
    <published>2021-06-19T07:50:13.000Z</published>
    <updated>2021-08-28T08:57:57.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="区别与并行"><a href="#区别与并行" class="headerlink" title="区别与并行"></a>区别与并行</h3><blockquote><p>感觉了解其区分，描述起来好难</p></blockquote><h4 id="他人的回答："><a href="#他人的回答：" class="headerlink" title="他人的回答："></a>他人的回答：</h4><p> 并发（Concurrency）是说进程B的开始时间是在进程A的开始时间与结束时间之间，我们就说A和B是并发的。</p><p> 并行（Parallel Execution）是并发的真子集，指同一时间两个进程运行在不同的机器上或者同一个机器不同的核心上。</p><h4 id="自己的话"><a href="#自己的话" class="headerlink" title="自己的话"></a>自己的话</h4><p>并行是同一个时刻有多个任务被执行，至少得有两个CPU。</p><p>并发不要求同一个刻被运行，两个任务可以交替执行，或是同时运行，即并发包括了并行的情况。</p><h3 id="工作中理解到并发"><a href="#工作中理解到并发" class="headerlink" title="工作中理解到并发"></a>工作中理解到并发</h3><p>在Android中什么时候有多个任务并发运行呢？  </p><p>多个任务并发运行，即可以理解为多个线程的情况。容易想到的是JVM中存在一个用于垃圾回收守护线程和主线程，守护线程一直在监控着资源的使用情况，</p><p>进行耗时操作，比如网络请求、解析xml文件，创建一个子线程来处理。</p><p>子线程处理完后，如何将结果通知给主线程呢？</p><p>比如 Main 启动一个 A线程执行任务，那么计算完如何通知A线程呢？</p><p>想到的是创建一个Callback，创建任务传递A线程，那么在A线程计算得到结果后，调用callback？</p><p>若是在A线程中直接调用callback，那么该方法实在A线程中运行的，而我们想要该callback在Main线程中执行呢？</p><p>想到这，此刻我有点惊讶我没有认真过这个问题~ </p><p>我们假设一种简单情况，Main线程在启动A线程后，阻塞等待，等待A线程返回结果后再执行后续的处理, 那么可以使用 <code>join()</code>方法等待A线程计算完成，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个公共变量，在A线程中修改，在主线程中展示，这里使用volatile使其修改对主线程可见</span></span><br><span class="line"><span class="comment">// 使用数组达到传址的效果</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread tA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"a:"</span> + result[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        tA.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主线程等待a线程执行完</span></span><br><span class="line">        tA.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main:"</span> + result[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了 <code>join()</code> ，其实现还是用了 wait/notify机制，直接使用wait/notify带来实现上述需求</p><p>obj.wait() 将该线程进入等待状态，知道其它线程调用obj的notify或被当前线程被中断<br>其本质是将本线程加入到<code>obj</code>的对象头中的等待集合中，并且本线程不再作为该对象的owner of the object’s monitor,<br>本线程不再拥有该对象的拥有权，注意是拥有该对象的所有权才能调用该方法的  </p><p>obj.notify()，也是得到了该对象的所有权后才能调用notify(),故需要先获取锁再操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个对象作为锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread tA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"a:"</span> + result[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;   <span class="comment">// 获取到锁</span></span><br><span class="line">            <span class="comment">// 唤醒其他等待在该lock的一个线程</span></span><br><span class="line">            <span class="comment">// 注意只是唤醒,其他线程还是等到本线程释放锁才能获取继续运行</span></span><br><span class="line">            lock.notify();</span><br><span class="line">            <span class="comment">// 假设这里 sleep(3000)，线程A还是会因为持有该锁，故，主线程得等到sync结束后才能继续运行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tA.start();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"main:"</span> + result[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，主线程阻塞运行，等待子线程结束后才继续运行，而，若是想再开启子任务后，想要主线程继续运行呢？</p><p>这个样的需求，其实就是Handle处理的场景，那我们不依赖Android如何实现呢？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护一个任务队列 queue，主线程开启一个死循环，不断取出队列中的任务来执行；<br>当我们想在主线程开启一个子线程来计算时，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;区别与并行&quot;&gt;&lt;a href=&quot;#区别与并行&quot; class=&quot;headerlink&quot; title=&quot;区别与并行&quot;&gt;&lt;/a&gt;区别与并行&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;感觉了解其区分，描述起来好难&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;他人的回
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于JVM</title>
    <link href="http://wjploop.github.io/2021/06/17/%E5%85%B3%E4%BA%8EJVM/"/>
    <id>http://wjploop.github.io/2021/06/17/关于JVM/</id>
    <published>2021-06-16T16:26:33.000Z</published>
    <updated>2021-08-28T08:57:51.528Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 自己能说多少？</p></blockquote><p>用于执行Java字节码指令的虚拟机，相对操作系统来说，它是一个进程，一般的虚拟机都是用C/C++来写的，在不同的系统中，它的实现是不同的，作为Java程序和操作系统的中间层，通过它实现了同一套Java程序可以在不同程序中运行。</p><p>尽管被称之为Java虚拟机，但是它可以运行Kotlin、Scala语言编写的程序，是因为对于JVM来说，它能运行的是Class字节码，通过不同语言的编译器，这些语言代码都会编译成Class文件。</p><h3 id="对比Dalvik虚拟机、ART"><a href="#对比Dalvik虚拟机、ART" class="headerlink" title="对比Dalvik虚拟机、ART"></a>对比Dalvik虚拟机、ART</h3><p>首先，需要了解的是，在Android系统中，并不是直接用JVM虚拟机，早期用的Dalvik虚拟机，后面用的是ART，不过，后两者都是执行是dex文件，而非JVM的Class文件。</p><p>而class到dex的转换是在apk打包过程中进行的，dex相比于class，其重要的一个区别是，使得字节码占用的存储变小了，主要原因是在dex中常量池是复用的，而在class中，每个class文件拥有一个常量池，导致很多相同常量在class文件之间不能复用，而在字节码中，常量池占比一般是最大的。</p><p>而无论是什么字节码，都会有两部分构成，数据、指令，而常量池属于数据，常量池包括类、方法、的全限名。比如<code>Lang\java\Object</code>,还包括一些字面量，初略  的看，代码中所有的字符都是存在常量池中的，比如类名、类方法，类成员，故这些信息占的存储空间是很大的。  </p><p>对于Class字节码，其构成大致包括<br>魔数，用来标志该文件是什么文件的，Class文件的魔术是对应的16进制的CAFEBABE,其实只是一个标志而已<br>支持的版本信息，表示该Class是Java什么版本编译出来的，当前JVM会检验能不能支持运行该版本的Class文件。<br>常量池<br>方法表  </p><h3 id="凭什么dex能共用常量池，而class一个文件一个常量池？"><a href="#凭什么dex能共用常量池，而class一个文件一个常量池？" class="headerlink" title="凭什么dex能共用常量池，而class一个文件一个常量池？"></a>凭什么dex能共用常量池，而class一个文件一个常量池？</h3><p>当看到经过dex化后可以减少存储空间的占有，咋一看感觉dex字节码更胜一筹，难道真的如此吗？</p><p>个人认为，诸如类似的优化，其思想都是依据使用场景变化后调整了策略，并无高低之分。</p><p>class设计成单个文件自带一个常量池，是因为出于class可以单个文件独立加载到JVM来运行的需要，场景是可以网络下载了一个class便可以直接运行。而dex将原本多个class的常量池复用，那么就不再适用于网络加载一个class就能运行场景，得加载原来多个class得信息量，也就是加载一个dex文件才能运行。    </p><p>可以说，若是都是网络加载字节码来运行，那么一个dex包大小比class大得多。</p><p>另外，既然可以打包class，Java体系中使用了jar来打包，不知道是否相关得压缩信息量得策略。</p><p>而，Android中网络加载dex来运行得案例也是有的，比如热修复技术中thinker，就是下载一个补丁dex文件。</p><h3 id="栈式虚拟机、寄存器式虚拟机对比？"><a href="#栈式虚拟机、寄存器式虚拟机对比？" class="headerlink" title="栈式虚拟机、寄存器式虚拟机对比？"></a>栈式虚拟机、寄存器式虚拟机对比？</h3><p>JVM是栈式的，而Dalvik是寄存器式。</p><p>在于指令不同，首先，指令由操作码和操作数组成，操作码表示要干什么，操作数表述对什么数值进行操作；<br>而两者的最大区别应该是操作数的寻址方式不同，栈式的指令的寻址地址永远是栈顶的数，而寄存器式指令，指令本身包括了操作数所在的位置，比如在某个寄存器，前者寻址是隐式的，而后者是显式的。  </p><p>比如一个加法指令，栈式指令的执行过程是，先后弹出栈顶两数相加，后把结果推入栈顶。<br>而寄存器式指令，则可以是由三地址组成，即 <code>iadd dest src1 src2</code>，这样，要分配三个寄存器，首先要把操作数读取到两个源寄存器中，经过CPU计算后，将结果存放在目标寄存器中。    </p><p>这样，利用的栈的数据结构，操作地址都是隐式的，可以让指令更简练，即指令集更小。  </p><p>而表达更简练的后果是，同一个操作，需要指令更多，而CPU执行指令的过程是不断地<code>取指令</code>和<code>执行指令</code>，而当时间都耗费在取指令上时，效率就降低了。</p><h3 id="关于Java字节码指令，所知多少？"><a href="#关于Java字节码指令，所知多少？" class="headerlink" title="关于Java字节码指令，所知多少？"></a>关于Java字节码指令，所知多少？</h3><p>除了上面所提及的栈式指令整体以外，从具体的一些指令举例。<br>比如一个加载指令，为什么要区分 sload, iload, dload, lload, 即区分操作数类型。<br>指令本身的信息就得包括类型，因为这告知了CPU加载一个数，该从内存起点偏移多长，比如short类型只包括两个字节，int包括4个字节等等。</p><h3 id="关于JIT、AOT"><a href="#关于JIT、AOT" class="headerlink" title="关于JIT、AOT"></a>关于JIT、AOT</h3><p>虚拟机中的指令，最终指令还是要转换成本地机器码，即CPU能够识别的指令。    </p><p>JIT是 just in time, 即执行过程中，虚拟机在运行时将字节码指令转换成本地机器指令。<br>AOT是 ahead of time,在运行之前就将字节码转换成机器码。  </p><p>两者的区别可以理解为懒汉式和饿汉式，也可以用我们考量空间和时间区别，或时间消耗的不同。JIT可以在加载部分Class文件后便执行，可以快速的看到执行效果，AOT则是选择在APK安装中，将字节码全部转换成机器码，导致安装比较久，而且安装后占用存储空间大，这在android 7.0中体现。</p><p>而在7.0之前，全部只用JIT，导致运行性能不够高，毕竟运行时还要将时间消耗在转换字节码上。  </p><p>而在8.0之后，ART,即Android Runtime，在这两者做了平衡，而是在运行过程中，才将字节码转换，并且将转换后的字节码保存下来，而且是计算了常常使用到的字节码才做转换，保存在optimized目录下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 自己能说多少？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用于执行Java字节码指令的虚拟机，相对操作系统来说，它是一个进程，一般的虚拟机都是用C/C++
来写的，在不同的系统中，它的实现是不同的，作为Java程序和操作系统的中间层，通过它实现了
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于线程</title>
    <link href="http://wjploop.github.io/2021/06/11/%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://wjploop.github.io/2021/06/11/关于线程/</id>
    <published>2021-06-11T13:59:45.000Z</published>
    <updated>2021-08-28T08:57:42.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于线程，自己能说多少呢？"><a href="#关于线程，自己能说多少呢？" class="headerlink" title="关于线程，自己能说多少呢？"></a>关于线程，自己能说多少呢？</h2><h3 id="线程是什么？"><a href="#线程是什么？" class="headerlink" title="线程是什么？"></a>线程是什么？</h3><p>线程是作为CPU调度的最小单位</p><p>表现在一个线程对应了一个程序计数器，程序计算器记录着CPU执行到了哪个指令了</p><p>一个段代码块，经过编译后，对应了一串指令，CPU执行过程就是取指令和执行指令，过程中总要记录下一个该取哪个指令，这个指令的下标就是放在PC中。</p><p>对于普通的指令，执行完后PC加一，表示取下一条指令来执行<br>对于跳转指令，执行该指令的实质就是给PC赋值，这样，在取指令的时，就可以取到对应的指令，最终实现指令跳转，而对于CPU来说，永远是取的PC中的指令来执行，可以说，CPU对于是否跳转是无感知的。</p><p>一段代码块想要被执行，就必须以线程的形式交由给虚拟机，这样才有机会获得CPU执行的可能。</p><p>以CPU视角来看，只认识线程，故，只有将代码逻辑包裹在线程中才可得以执行。</p><h3 id="对比进程？"><a href="#对比进程？" class="headerlink" title="对比进程？"></a>对比进程？</h3><p>进程是包含线程的，一个进程可以包含多个线程。进程持有了一段内存空间，用来分配给线程使用，而我们指的堆，就是在进程内存空间中的，供不同线程使用。另外，系统中的一些权限也是以进程为单位分配的。</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程的状态有<br>刚创建好、可运行、阻塞、等待、超时等待、终止   </p><p>其中，可运行状态的是对于虚拟机来说的，为什么没有区分为在ready和running，对于操作系统中的线程，是区分这两个状态的，而对于JVM来说，却把这两个状态都归为runnable状态，表示虚拟机不关注线程是否正在被运行，JVM对于操作系统来说，它是将一个线程交付给操作系统运行的，把JVM中的线程映射到操作系统中的线程。</p><p>一个线程中在执行中 <code>serverSocket.accept()</code>方法，被称为阻塞运行，这时候检查该线程的状态，发现它是 <code>Runnable</code>，对于想JVM来说它就是在运行的，但在操作系统中，它就是在等待状态，它不会占据CPU。</p><p>对于Runnable，虚拟机认为这是可运行的线程，由操作系统调度运行，可能在等待某个资源，比如CPU、或IO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于线程，自己能说多少呢？&quot;&gt;&lt;a href=&quot;#关于线程，自己能说多少呢？&quot; class=&quot;headerlink&quot; title=&quot;关于线程，自己能说多少呢？&quot;&gt;&lt;/a&gt;关于线程，自己能说多少呢？&lt;/h2&gt;&lt;h3 id=&quot;线程是什么？&quot;&gt;&lt;a href=&quot;#线程是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android-Transition</title>
    <link href="http://wjploop.github.io/2021/04/26/Android-Transition/"/>
    <id>http://wjploop.github.io/2021/04/26/Android-Transition/</id>
    <published>2021-04-26T03:47:36.000Z</published>
    <updated>2021-06-20T07:23:07.721Z</updated>
    
    <content type="html"><![CDATA[<p>对Android Transition好奇，记录追踪代码</p><h2 id="Transition是什么？"><a href="#Transition是什么？" class="headerlink" title="Transition是什么？"></a>Transition是什么？</h2><img src="/images/transitions.gif" width="240" height="200"><p>如图，关注左上角的图块</p><p>可以看到，它先改变颜色，后平移到右下角，平移过程中大小也在变化，整体上看就是三个Animator的组合完成；现在我们看到使用Transition如何实现的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> transition = TransitionInflater.from(<span class="keyword">this</span>).inflateTransition(R.transition.custom_transistion)</span><br><span class="line">root.setOnClickListener &#123;</span><br><span class="line">    <span class="comment">// 每一次点击，往返切换start、end 状态</span></span><br><span class="line">    TransitionManager.beginDelayedTransition(root, transition)</span><br><span class="line">    end = !end</span><br><span class="line">    toggleView()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区分当前状态，start or end</span></span><br><span class="line"><span class="keyword">var</span> statusEnd = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toggleView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    container.children.forEach &#123;</span><br><span class="line">        it.visibility = <span class="keyword">if</span> (statusEnd) View.INVISIBLE <span class="keyword">else</span> View.VISIBLE</span><br><span class="line">    &#125;</span><br><span class="line">    view_target.layoutParams = (view_target.layoutParams <span class="keyword">as</span> FrameLayout.LayoutParams).apply &#123;</span><br><span class="line">        gravity = <span class="keyword">if</span> (statusEnd) (Gravity.BOTTOM or Gravity.RIGHT) <span class="keyword">else</span> (Gravity.TOP or Gravity.LEFT)</span><br><span class="line">        width = <span class="keyword">if</span> (statusEnd) <span class="number">300</span> <span class="keyword">else</span> <span class="number">100</span></span><br><span class="line">        height = <span class="keyword">if</span> (statusEnd) <span class="number">300</span> <span class="keyword">else</span> <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">    view_target.setBackgroundColor(<span class="keyword">if</span> (statusEnd) Color.BLUE <span class="keyword">else</span> Color.RED)</span><br><span class="line">    view_target.apply &#123;</span><br><span class="line">        alpha = <span class="keyword">if</span>(statusEnd) <span class="number">1f</span> <span class="keyword">else</span> <span class="number">0.5f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体上看，依据 <code>statusEnd</code> 定义了两个状态 start，end，而依据这个状态，确定View的 visibility，position,size,color的属性。<br>切换状态，并非生硬地切换，而是在切换过程加入针对相关属性的过度动画，我想这就是Android加入这个库的用处吧。  </p><p>一个页面的两种状态，换个角度，也可以把这两种状态是视为两个页面，切换状态就是切换页面了，这里，我们将变化的页面称之为 <code>Scene</code>, 变化的过度动画交给 <code>Transition</code> 处理。</p><h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><p>表示一个页面，会绑定到一个实际的View中。作为一个页面，会有进入和弹出两个动作，在这两个动作发生时会执行View中某些property的动画。</p><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>切换的涵盖了从一个旧的Scene到新的Scene的过程，包括 old scene exit 和 new scene enter.</p><p>维护一些动画信息，在Scene变化时执行持有的动画。主要做两件事：</p><ol><li>capture property value</li><li>play animations based on change to captured property value</li></ol><h2 id="还是跟着代码看看吧"><a href="#还是跟着代码看看吧" class="headerlink" title="还是跟着代码看看吧"></a>还是跟着代码看看吧</h2><p>先看看上面使用的使用到的 beginDelayedTransition()</p><blockquote><blockquote><p>感觉注释写得很好了</p></blockquote></blockquote><p>方法名为意思为 启动一个延迟的切换， 为什么时延迟的呢？ 这个切换并没有马上执行，因为一个新的scene还没有确定呢。而这个新的scene的创建过程也很有意思，它是依据下一帧与当前帧的“变化“确定的，而且它关注的只有参数中sceneRoot的ViewGroup节点下View的变化哦。本来下一帧要确定好准备绘制的，但是遇到存在Transition未执行，会将其执行玩才真正绘制最终的下一帧。</p><p>换个说法，current frame &gt;&gt; next frame 之间，提取出 change in sceneRoot, 为这些 change 执行参数中的transition,即执行动画。本质上，就是本来要绘制下一帧nextFrame的，发现有transition,则nextFrame要延后，在currentFrame与nextFrame之间插入一系列的frame，而这些frame由transition来确定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beginDelayedTransition</span><span class="params">(@NonNull <span class="keyword">final</span> ViewGroup sceneRoot, @Nullable Transition transition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预备的执行的Transitions集合添加该某个View作为sceneRoot,</span></span><br><span class="line">    <span class="comment">// 限制了view只能能添加一次</span></span><br><span class="line">    <span class="keyword">if</span> (!sPendingTransitions.contains(sceneRoot) &amp;&amp; ViewCompat.isLaidOut(sceneRoot)) &#123;</span><br><span class="line">        sPendingTransitions.add(sceneRoot);</span><br><span class="line">        <span class="keyword">if</span> (transition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            transition = sDefaultTransition;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Transition transitionClone = transition.clone();</span><br><span class="line">        <span class="comment">// 停止当前运行的动画，记录当前帧的属性值、给scene机会执行一个可能需要exitAction</span></span><br><span class="line">        sceneChangeSetup(sceneRoot, transitionClone);</span><br><span class="line">        <span class="comment">// 将当前sense设为空，即达到退出的效果</span></span><br><span class="line">        Scene.setCurrentScene(sceneRoot, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 当scene变化时执行Transition，看看怎么监听sense变化的</span></span><br><span class="line">        sceneChangeRunTransition(sceneRoot, transitionClone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sceneChangeRunTransition</span><span class="params">(<span class="keyword">final</span> ViewGroup sceneRoot, <span class="keyword">final</span> Transition transition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (transition != <span class="keyword">null</span> &amp;&amp; sceneRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        MultiListener listener = <span class="keyword">new</span> MultiListener(transition, sceneRoot);</span><br><span class="line">        <span class="comment">// 为View sceneRoot 添加attach、preDraw 状态的监听</span></span><br><span class="line">        sceneRoot.addOnAttachStateChangeListener(listener);</span><br><span class="line">        sceneRoot.getViewTreeObserver().addOnPreDrawListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当该View的脱离Window时先执行动画</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        removeListeners();</span><br><span class="line"></span><br><span class="line">        sPendingTransitions.remove(mSceneRoot);</span><br><span class="line">        ArrayList&lt;Transition&gt; runningTransitions = getRunningTransitions().get(mSceneRoot);</span><br><span class="line">        <span class="keyword">if</span> (runningTransitions != <span class="keyword">null</span> &amp;&amp; runningTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Transition runningTransition : runningTransitions) &#123;</span><br><span class="line">                runningTransition.resume(mSceneRoot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mTransition.clearValues(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此刻，视图树上所有的View都已经测量，放置好位置，只是没有绘制</span></span><br><span class="line">    <span class="comment">// 在这个时间点，用户可以选择是否满意当前的布局，return true绘制当前帧， return false可以取消当前帧的绘制，</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        removeListeners();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意只是在第一次nextFrame操作，后续动画播放过程中的onPreDraw就不会处理了</span></span><br><span class="line">    <span class="comment">// Don't start the transition if it's no longer pending.</span></span><br><span class="line">        <span class="keyword">if</span> (!sPendingTransitions.remove(mSceneRoot)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add to running list, handle end to remove it</span></span><br><span class="line">        <span class="keyword">final</span> ArrayMap&lt;ViewGroup, ArrayList&lt;Transition&gt;&gt; runningTransitions =</span><br><span class="line">                getRunningTransitions();</span><br><span class="line">        ArrayList&lt;Transition&gt; currentTransitions = runningTransitions.get(mSceneRoot);</span><br><span class="line">        ArrayList&lt;Transition&gt; previousRunningTransitions = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentTransitions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentTransitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            runningTransitions.put(mSceneRoot, currentTransitions);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            previousRunningTransitions = <span class="keyword">new</span> ArrayList&lt;&gt;(currentTransitions);</span><br><span class="line">        &#125;</span><br><span class="line">        currentTransitions.add(mTransition);</span><br><span class="line">        mTransition.addListener(<span class="keyword">new</span> TransitionListenerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTransitionEnd</span><span class="params">(@NonNull Transition transition)</span> </span>&#123;</span><br><span class="line">                ArrayList&lt;Transition&gt; currentTransitions = runningTransitions.get(mSceneRoot);</span><br><span class="line">                currentTransitions.remove(transition);</span><br><span class="line">                transition.removeListener(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mTransition.captureValues(mSceneRoot, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (previousRunningTransitions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Transition runningTransition : previousRunningTransitions) &#123;</span><br><span class="line">                runningTransition.resume(mSceneRoot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 播放Transition,其实是 create animators and run </span></span><br><span class="line">        mTransition.playTransition(mSceneRoot);</span><br><span class="line">                <span class="comment">// 适应 对比前后，创建很多animator</span></span><br><span class="line">            &gt;&gt;  createAnimators(sceneRoot, mStartValues, mEndValues, mStartValuesList, mEndValuesList);</span><br><span class="line">            &gt;&gt;  runAnimators();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="那启动一个Activity是如何执行Transition呢？"><a href="#那启动一个Activity是如何执行Transition呢？" class="headerlink" title="那启动一个Activity是如何执行Transition呢？"></a>那启动一个Activity是如何执行Transition呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// options 不为空，默认不传也会获取主题默认的，不过需要当前Window支持 Window.FEATURE_ACTIVITY_TRANSITIONS</span><br><span class="line">startActivityForResult(intent, -1, options);</span><br><span class="line">// 取消输入开始退出</span><br><span class="line">&gt;&gt; cancelInputsAndStartExitTransition</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">public void startExitOutTransition(Activity activity, Bundle options) &#123;</span><br><span class="line">    mEnterTransitionCoordinator = null;</span><br><span class="line">    if (!activity.getWindow().hasFeature(Window.FEATURE_ACTIVITY_TRANSITIONS) ||</span><br><span class="line">            mExitTransitionCoordinators == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityOptions activityOptions = new ActivityOptions(options);</span><br><span class="line">    if (activityOptions.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class="line">        int key = activityOptions.getExitCoordinatorKey();</span><br><span class="line">        int index = mExitTransitionCoordinators.indexOfKey(key);</span><br><span class="line">        if (index &gt;= 0) &#123;</span><br><span class="line">            mCalledExitCoordinator = mExitTransitionCoordinators.valueAt(index).get();</span><br><span class="line">            mExitTransitionCoordinators.removeAt(index);</span><br><span class="line">            if (mCalledExitCoordinator != null) &#123;</span><br><span class="line">                mExitingFrom = mCalledExitCoordinator.getAcceptedNames();</span><br><span class="line">                mExitingTo = mCalledExitCoordinator.getMappedNames();</span><br><span class="line">                mExitingToView = mCalledExitCoordinator.copyMappedViews();</span><br><span class="line">                mCalledExitCoordinator.startExit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void startExit() &#123;</span><br><span class="line">    if (!mIsExitStarted) &#123;</span><br><span class="line">        backgroundAnimatorComplete();</span><br><span class="line">        mIsExitStarted = true;</span><br><span class="line">        pauseInput();</span><br><span class="line">        ViewGroup decorView = getDecor();</span><br><span class="line">        if (decorView != null) &#123;</span><br><span class="line">           // 禁止 layout乱入，layout也会导致 draw，而我们依赖着 draw前的时间点创建animator</span><br><span class="line">            decorView.suppressLayout(true);</span><br><span class="line">        &#125;</span><br><span class="line">        // 这个将共享元素移动到OverLay层，最高层哦</span><br><span class="line">        moveSharedElementsToOverlay();</span><br><span class="line">        startTransition(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if (mActivity != null) &#123;</span><br><span class="line">                    beginTransitions();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    startExitTransition();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void startExitTransition() &#123;</span><br><span class="line">    Transition transition = getExitTransition();</span><br><span class="line">    ViewGroup decorView = getDecor();</span><br><span class="line">    if (transition != null &amp;&amp; decorView != null &amp;&amp; mTransitioningViews != null) &#123;</span><br><span class="line">        setTransitioningViewsVisiblity(View.VISIBLE, false);</span><br><span class="line">        TransitionManager.beginDelayedTransition(decorView, transition);</span><br><span class="line">        setTransitioningViewsVisiblity(View.INVISIBLE, false);</span><br><span class="line">        // 请求重绘，正好对应上了，onPreDraw</span><br><span class="line">        // 否则没机会执行transition</span><br><span class="line">        decorView.invalidate();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        transitionStarted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对Android Transition好奇，记录追踪代码&lt;/p&gt;
&lt;h2 id=&quot;Transition是什么？&quot;&gt;&lt;a href=&quot;#Transition是什么？&quot; class=&quot;headerlink&quot; title=&quot;Transition是什么？&quot;&gt;&lt;/a&gt;Transiti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程笔记</title>
    <link href="http://wjploop.github.io/2021/04/15/%E5%8D%8F%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://wjploop.github.io/2021/04/15/协程笔记/</id>
    <published>2021-04-15T02:40:24.000Z</published>
    <updated>2021-06-16T18:30:47.135Z</updated>
    
    <content type="html"><![CDATA[<p>协程在安卓中，用来处理即时任务，相对于那些延迟任务，使用Worker来处理。</p><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>协程中的Job描述一个后台进行的任务，可以手动取消，感知自己的作用域；</p><p>Jobs 工作链之间可以构成父子关系，这样，会导致，当父节点取消时，同时会递归地取消子节点。当子节点异常结束时，也会到导致父节点立刻去结束。这些，父子之间的行为可以通过<code>SupervisorJob</code>来解决</p><p>Job实例创建的常见形式如下：</p><ul><li>直接使用 launch的协程构造器，</li><li>使用CompleteJob的工厂方法，当任务结束时会回调complete()方法</li></ul><p>概念上，Job也不产生结果，只有方法调用的副作用，关注结果的Job可以用其子类 <code>Defferd</code>   </p><h3 id="Job-states"><a href="#Job-states" class="headerlink" title="Job states"></a>Job states</h3><p>Job的状态由三个变量构成，isActive, isCompleted, isCanceled, 通过不同组合，可以形成不同的状态，000表示刚创建出来100表示进入激活状态010表示完美结束了代码块001表示正在取消，cancelling011表示已取消,cancelled这里，通常创建后就会进入active状态，不过也可以创建时指定Coroutine.Lazy，延迟激活，通过start/join方法启动一个激活的协程会一直运行，下一个状态可能是代码执行完毕，complete，或执行失败，抛异常，或被取消</p><p>抛异常会导致进入cancelling状态，Job可以调用cancel方法立刻进入cancelling状态，不过若是作为父节点，也要得子节点完成。</p><p>完成一个协议，也可以调用它的complete方法，也会等到子协程完成再完成。注意到，completing状态只是内部状态，并不对外公开，再完成子协程前，在外面观察者看到，当前协程还是active状态。</p><h3 id="Cancellation-cause"><a href="#Cancellation-cause" class="headerlink" title="Cancellation cause"></a>Cancellation cause</h3><p>协程可以当出现异常时进入canceled状态。当子节点出现异常取消时，也会导致父节点取消。实现方式上，是通过抛异常来让让协程进入到cancelled状态的。正常取消和异常取消区别于抛出的异常类型，正常取消抛出 <code>CancellationException</code>,其他类型异常则视为属于异常退出了。有趣的是，这个异常是Java基础库一致的。</p><h3 id="线程安全保证"><a href="#线程安全保证" class="headerlink" title="线程安全保证"></a>线程安全保证</h3><h3 id="实现类都是不稳定"><a href="#实现类都是不稳定" class="headerlink" title="实现类都是不稳定"></a>实现类都是不稳定</h3><p>指的是 JopSupport吧，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;协程在安卓中，用来处理即时任务，相对于那些延迟任务，使用Worker来处理。&lt;/p&gt;
&lt;h2 id=&quot;Job&quot;&gt;&lt;a href=&quot;#Job&quot; class=&quot;headerlink&quot; title=&quot;Job&quot;&gt;&lt;/a&gt;Job&lt;/h2&gt;&lt;p&gt;协程中的Job描述一个后台进行的任务，可
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>刷题中对一些算法思想的理解</title>
    <link href="http://wjploop.github.io/2021/03/31/%E5%88%B7%E9%A2%98%E4%B8%AD%E5%AF%B9%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://wjploop.github.io/2021/03/31/刷题中对一些算法思想的理解/</id>
    <published>2021-03-31T13:34:30.000Z</published>
    <updated>2021-06-16T18:30:47.210Z</updated>
    
    <content type="html"><![CDATA[<p>刷题过程中，对一些大家熟知的概念有了自己的体会，这是一个满足的体验啊。比如，理解一些思路为何能上升为”思想”，如分治思想。</p><p>以排序的快排、归并为例，最开始我们了解它们一般都是先接触它们的思路，   </p><h3 id="快排的思路"><a href="#快排的思路" class="headerlink" title="快排的思路"></a>快排的思路</h3><p>在一个序列中选择一个数为中轴 <code>pivot</code>，将小于等于中轴数的放到左边，大于它的放在右边；<br>不断对左边和右边的子序列作以上操作。</p><h3 id="归并思路"><a href="#归并思路" class="headerlink" title="归并思路"></a>归并思路</h3><p>排序一个序列，先不断的划分为两部分别排序，再将左右两边的有序序列合并；不断对左右两边分别以上操作。</p><p>从归并再反思快排，我们发现，归并比快排要”懒”一些啊~    </p><p>快排一次划分将序列分成了三部分，且将三者排好序，而归并一次划分仅将序列分为两部分，两者没有急着排序，而是优哉游哉将排序放到不可划分之后。  </p><p>快排像一个勤奋或急功近利的年轻人，每次操作，便急着将中轴数放到最终的位置，付出的”比较汗水”很多，每个数会比较n-1次；  </p><p>归并像一个深谋远虑的老者，不急不躁，将比较的操作放到”合并”流程中，使得每次”比较”的结果都能给后面的”比较”助力，为什么这么说呢？<br>比如合并 [1,3,5] 与[2,4,6]，左边的1与右边2比较后，发现1比2小，且右边是递增的有序序列，故1也一定比2之后的数据小，也就是无需再与2之后的数比较，那么至少省了2次比较呀。  </p><p>而且啊，基于快排”排序不稳定”，归并”排序稳定”，它们年轻人、老者的形象似乎更加立体了。  </p><p>在不同的场景下，它们各有千秋，在现实的世界中，无疑还是年轻人干活的场景更多一点呀。  </p><p>在啰嗦完它们不同点之后，我们来找它们的共同点，为何他俩能在众多排序算法中更加惹人注目呢？ 我想，它俩相比与一些暴力蛮干的排序相比，它俩都散发着”分治”智慧。遇到”排列好一堆数”的复杂问题，能寻见其间的共通，将复杂问题化为共通部分的叠加子问题，求解简单的子问题，便能可求得原问题之解。</p><p>具体上，再看上面提及的两个排序思路，都是”分治思想”应用，仅是划分角度的不同。<br>快排，将问题化为，排序一个数和两个子序列简单子问题，排序一个数与两个序列可省力多了，毕竟只要花O(n)；<br>归并，似乎”分为治之”更为明显，遇到问题，若非问题规模为1，即1个数无需排序，否则统统将问题规模减半，令人惊艳的在于，合并的过程中，子问题的答案能够为父问题求解提供帮助，从而在整体求解上起飞。  </p><p>分而治之，基于问题本就由一个个子问题构成的客观事实，拆解问题便是我们认识世界的过程，可以说，分而治之是我们与生俱来解决问题思路。</p><p>另外，若能将问题拆分后，若子问题之间不依赖，并发执行，也是可以提高效率吧。</p><p>前天遇到了一道题，<a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">颠倒二进制</a>, 引出上文~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刷题过程中，对一些大家熟知的概念有了自己的体会，这是一个满足的体验啊。比如，理解一些思路为何能上升为”思想”，如分治思想。&lt;/p&gt;
&lt;p&gt;以排序的快排、归并为例，最开始我们了解它们一般都是先接触它们的思路，   &lt;/p&gt;
&lt;h3 id=&quot;快排的思路&quot;&gt;&lt;a href=&quot;#快
      
    
    </summary>
    
    
      <category term="code" scheme="http://wjploop.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Fragment Transactions &amp; Activity State Loss (译)</title>
    <link href="http://wjploop.github.io/2021/03/05/Fragment-Transactions-Activity-State-Loss-%E8%AF%91/"/>
    <id>http://wjploop.github.io/2021/03/05/Fragment-Transactions-Activity-State-Loss-译/</id>
    <published>2021-03-05T03:13:31.000Z</published>
    <updated>2021-06-16T18:30:47.210Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html" target="_blank" rel="noopener">原文</a></p></blockquote><h1 id="Fragment-Transactions-和-Activity-状态丢失"><a href="#Fragment-Transactions-和-Activity-状态丢失" class="headerlink" title="Fragment Transactions 和 Activity 状态丢失"></a>Fragment Transactions 和 Activity 状态丢失</h1><p>自Android3.0后，以下报错信息在StackOverflow困扰众人许久了</p><blockquote><p>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceStateat android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341)at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352)at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)</p></blockquote><p>本文将要解释该异常为什么会出现，以及何时会出现，随便给出几个建议来处理该问题。</p><h2 id="该异常为什么会发生？"><a href="#该异常为什么会发生？" class="headerlink" title="该异常为什么会发生？"></a>该异常为什么会发生？</h2><p>该异常抛出的原因是，在Activity状态已经保存后仍试图提交一个FragmentTransaction，其导致了一个现象被称之为状态丢失。在探究其中的各种细节之前，我们先来看看<code>onSaveInstanceState()</code>方法调用时发生了什么。正如在我的上一篇文章<a href="https://www.androiddesignpatterns.com/2013/08/binders-death-recipients.html" target="_blank" rel="noopener">Binders &amp; Death Recipients</a> 所说,在Android的运行环境中，App对自己的命运掌控甚少。Android系统在内存不足的情况下可以在杀死任意进程，导致后台Activity在未收到任何通知下被杀掉。为了避免用户察觉的到这种不稳定的问题（切换到后台的App，被杀或不被杀，当切回到前台时表现会不一样；不被杀，数据正常，被杀掉了，数据跟关闭前的不一样），在Activity可能被销毁的情况下，系统给给了它一个机会，能使用<code>onSaveInstanceState()</code>方法先来保存好当前的状态。当App由后台切换到前台时，恢复之前保存的状态，这样，无论App是否被杀与否，用户体验都是一样的。</p><p>当系统回调<code>onSaveInstanceState()</code>方法时，它将一个<code>Bundle</code>对象传给Activity用于保存Dialog,Fragment,Views的状态，在该方法返回后，系统序列化该Bundle数据（通过parcel序列化）通过Binder传给系统服务进程（System Server process）,使其能安全保存着。之后当系统重建创建Activity时，又将该Bundle传回给应用使其恢复原来的状态。</p><p>那为什么该异常会抛出呢？该问题源自于该Bundle数据代表Activity在调用<code>onSaveInstance()</code>这一时刻的快照，这意味着在<code>onSaveInstance()</code>之后调用<code>FragemntTransaction#commit()</code>，这个transaction将不会被保存。而从用户的角度上看，会导致UI的数据混乱。为了保证用户体验，Android只好抛异常来避免状态丢失了（默认数据正确性优先）。</p><h2 id="何时该异常会抛出？"><a href="#何时该异常会抛出？" class="headerlink" title="何时该异常会抛出？"></a>何时该异常会抛出？</h2><p>假如你之前遇到该异常，你可能会注意到该异常抛出的时间点在不同Android版本上会有所不同。比如，你可能注意到在老设备上更容易抛出该异常，或是当使用支持库（android.support.Fragment）而非官方库(android.app.Fragment)时你的应用可能更容易崩溃。这些细小的不一致行为导致很多人认为支持库是存在bug而不能被信任，而这些观点，通常是错误的。</p><p>这些不一致行为，原因是在在Android3.0之后，Activity的生命周期方法发生了一些重大改变。3.0之前，Activity是在paused之后就可以被系统认为是”可杀的”，意味着在<code>onPause()</code>方法之前会保证调用<code>onSaveInstance()</code>。而在3.0之后，Activity是要在<code>onStop()</code>后才会被认为是可杀的，也就是会在<code>stoped</code>之前保证保存状态。</p><p>由于Activity生命周期的变化，支持库需要兼容不同的平台版本。比如，该异常会在<code>onSaveInstanceState()</code>方法后执行<code>commit()</code>便会抛出，以此提示开发者状态丢失了。而<code>onSaveInstanceState()</code>调用时机在3.0之前更早一些，也就导致低版本更容易状态丢失。为了能够在支持不同版本，Android团队做了妥协：允许在低版本上Android中，在<code>onPause()</code>和<code>onStop()</code>之间提交commit会导致异常。支持库在不同版本表现如下表格：</p><table><thead><tr><th></th><th align="center">3.0前</th><th align="center">3.0后</th></tr></thead><tbody><tr><td>在 onPause()前 commit()</td><td align="center">OK</td><td align="center">OK</td></tr><tr><td>在 onPause() 和 onStop() 之间commit()</td><td align="center">状态丢失</td><td align="center">OK</td></tr><tr><td>在 onStop() 之后commit()</td><td align="center">Exception</td><td align="center">Exception</td></tr></tbody></table><h2 id="如何避免该异常"><a href="#如何避免该异常" class="headerlink" title="如何避免该异常"></a>如何避免该异常</h2><p>一旦理解状态丢失是如何发生之后，避免该异常就容易多了。若是你在阅读本文之前就理解了，也希望你可以通过本文知道支持库是如何工作的以及为什么App中避免状态丢失如此重要。若是你在搜索一个快速的解决方案而看到本文，这里有几个建议希望能够对你处理FragmentTransaction有帮助。</p><h3 id="在Activity生命周期提交事务（commit-transaction）时需要谨慎"><a href="#在Activity生命周期提交事务（commit-transaction）时需要谨慎" class="headerlink" title="在Activity生命周期提交事务（commit transaction）时需要谨慎"></a>在Activity生命周期提交事务（commit transaction）时需要谨慎</h3><p>大部分应用只会在onCreate()方法中或是响应用户操作时才会提交事务，这不会出现什么问题。然而，在其它的生命周期方法中提交事务时，事情就会变得复杂了，比如<code>onActivityResult()</code>,<code>onStart()</code>,<code>onResume()</code>. 比如，你不应该在<code>onResume()</code>方法中提交事务，因为有可能此时Activity的状态没有恢复原来保存的状态（restored）,详见<a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onResume()" target="_blank" rel="noopener">文档</a>,</p><blockquote><p>文档内容（译者加）：</p><ul><li>Activity#onResume()<br>分发 onResume() 方法给Fragment。注意，为了更好的兼容低版本平台，该activity中attached Fragment并没有进入resumed。这意味着Activity原来保存的状态（若是以前保存有）没有恢复（原来的状态还是在bundle中，而非在当前state中），当前是不允许提交事务修改状态的，你应该在<code>onResumeFragments()</code>方法中提交事务修改。</li></ul></blockquote><p>如果你需要在onCreate()之外的生命周期中提交事务，应该在<code>FragmentActivity#onResumeFragemnts()</code>或<code>Activity#onPostResume()</code>。这两个方法保证原来的状态已经正确的恢复，因此可以避免状态丢失的可能性。（若是想要在<code>Activity#onActivityResult()</code>方法中提交事务，可以参看我的StackOverFlow中的<a href="https://stackoverflow.com/questions/16265733/failure-delivering-result-onactivityforresult" target="_blank" rel="noopener">回答</a> ）</p><h3 id="避免在异步的回调方法中提交事务"><a href="#避免在异步的回调方法中提交事务" class="headerlink" title="避免在异步的回调方法中提交事务"></a>避免在异步的回调方法中提交事务</h3><p>常见的异步回调方法，比如 <code>AsyncTask#onPoastExecute()</code>和<code>LoadManager.LoaderCallback#onLoadFinished()</code>，当在这些方法提交事务时，我们并不知道当前Activity所处的状态。如下展示异常出现的过程。</p><ol><li>Activity中开始执行一个<code>AsyncTask</code></li><li>用户点击Home键，导致Activity的<code>onSaveStateInstance()</code>和<code>onStop()</code>执行</li><li><code>AsyncTask</code>任务完成执行<code>onPostExecutes()</code>,并不意识到Activity已经 stopped</li><li>在<code>onPostExecutes()</code>中提交事务，导致异常抛出</li></ol><p>通常来说，最好不在异步回调中提交事务。谷歌工程师认同这一原则，在Android开发团队的一篇<a href="https://groups.google.com/d/msg/android-developers/dXZZjhRjkMk/QybqCW5ukDwJ" target="_blank" rel="noopener">文章</a> 中，认为在异步回调中执行提交事务会使得界面突然切换，这会造成糟糕的用户体验。若是你的App一定要在异步回调中提交事务，并没有容易的方法来保证提交事务在保存状态前执行，你可能需要使用<code>commitAllowStateLoss()</code>，但这需要自己处理状态能会丢失的情况。(StackOverFlow有两篇帖子可以参考，<a href="https://stackoverflow.com/questions/8040280/how-to-handle-handler-messages-when-activity-fragment-is-paused" target="_blank" rel="noopener">帖子1</a><a href="https://stackoverflow.com/questions/7992496/how-to-handle-asynctask-onpostexecute-when-paused-to-avoid-illegalstateexception" target="_blank" rel="noopener">帖子2</a>）</p><h3 id="使用commitAllowStateLoss-应当作为最后选项"><a href="#使用commitAllowStateLoss-应当作为最后选项" class="headerlink" title="使用commitAllowStateLoss 应当作为最后选项"></a>使用commitAllowStateLoss 应当作为最后选项</h3><p><code>commit()</code>和<code>commitAllowStateLoss()</code>两者唯一区别在于后者在状态状态可能丢失时，不会抛异常。通常你也不该使用该方法，因为这意味这要承受状态丢失的可能。最好的解决方案当然是保证commit在保存状态前执行，这保证了良好的用户体验。除非状态丢失无法避免，否则<code>commitAllowStateLoss</code>不该使用。</p><p>希望这些建议能够解决你遇到的问题。若是你仍遇到问题，在StackOverFlow提交问题并在下面评论区留下链接，我会帮忙看看滴。</p><p>总之，感谢你的阅读。若是有问题欢迎评论，别忘了点赞分享~</p><blockquote><p>上次更新于2014-1-8<br>译者翻译于2021-3-5，哭了~，陈年好文啊</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
    
      <category term="翻译" scheme="http://wjploop.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>朴素的思路-俄罗斯套娃</title>
    <link href="http://wjploop.github.io/2021/03/05/%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%80%9D%E8%B7%AF-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/"/>
    <id>http://wjploop.github.io/2021/03/05/朴素的思路-俄罗斯套娃/</id>
    <published>2021-03-05T03:06:52.000Z</published>
    <updated>2021-03-05T12:05:00.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意提取"><a href="#题意提取" class="headerlink" title="题意提取"></a>题意提取</h2><p>信封有两属性，宽（w），高（h）;<br>信封a套入信封b的要求:w[a] &lt; w[b] &amp;&amp; h[a] &lt; h[b]</p><p>求，在一堆信封中，最多能有多少个个信封可以套在一起？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="基于生活经验的朴素思路："><a href="#基于生活经验的朴素思路：" class="headerlink" title="基于生活经验的朴素思路："></a>基于生活经验的朴素思路：</h3><p>既然想要套更多的信封，那么先找最小的信封出来，准没错，找出宽高最小的信封a。</p><p>然后，再选一个 “最贴近a，又比a大” 的信封。重复该步骤，积累的信封个数就是题目所求了。</p><p>写代码时，排序，按宽优先升序排序,这样，a的下一个信封，就是“最贴近a，又比a大”的信封。</p><p>结果发现，像这样（排序后）的用例是没问题的。</p><blockquote><p>[1,1], [2,3], [3,4]</p></blockquote><p>但是，如下的用例就出现问题了 </p><blockquote><p>[1,7], [2,3], [3,4]</p></blockquote><p>按照写法，我们会直接选择，[1,7]，之后的信封都不能继续套入，故结果为1，而更优的选择为选后两个信封，结果为2。</p><p>问题出在哪里了呢？</p><p>我们平白无故的添加一个比较条件，按<code>宽</code>优先排序，比如 [1,7] &lt; [2,3]，我<code>宽</code>小于你，可我<code>高</code>大于你，凭啥我就低你一等呢？</p><p>原来，信封[1,7]，[2,3] 之间并没有所谓的大小关系，故我们朴素思路问题出现在了这里。</p><blockquote><p>感慨，生活中很多时候，自己遇到比较复杂的问题时，会想当然的添加某些条件，使其合理化。比如，为啥自己工作那么久还在小公司颠簸，安慰自己说，进大厂的人毕竟是少数，自己是野鸡大学的嘛。而这问题出现在哪呢？</p></blockquote><p>回归本题，我们添加这个“按宽优先升序”条件后，虽然不能直接用朴素的思路来解决，但似乎有点用到，如，比信封i大的信封一定在其后面了，故基于此继续思考。</p><p>面对排序好的信封 envelopes，如何选择第一封信封呢？如</p><blockquote><p>[1,7], [2,3], [3,4] </p></blockquote><p>我们选择了[2,3]作为第一个信封，因为选择它之后，我们可以再套一个[3,4]，而其它两个信封着都没有这样的“额外好处”，或者说其他两信封给的“额外好处”为0，可以说，我们是根据它们给的“好处值”的大小来做出选择的，我们定义每个信封的好处值<code>goods[i]</code>为，选择它之后增加了多少个信封。如以上用例的好处值分别为：</p><blockquote><p>1, 2, 1</p></blockquote><p>那么我们问题所求 ans = maxOf(goods[0], goods[1]… goods[n-1])</p><p>我们试图分别求每个goods[i]值，让人难以理解的一点是，求goods[i]似乎是跟求原问题是类似的…</p><p>发现求goods[i] 依赖后面信封的好处值和大小，而求最后一个信封的好处值是最容易的，必须等于1.</p><p>goods[n-1] = 1 </p><p>goods[k] = 在后面的信封中，选择比envelopes[k]大的集合中选择好处值最大的 good+1</p><blockquote><p>哇，发现描述起来好难~</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = envelopes.length;</span><br><span class="line">        <span class="comment">// 将信封按宽优先升序排序</span></span><br><span class="line">        Arrays.sort(envelopes, (o1, o2) -&gt; o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? Integer.compare(o1[<span class="number">1</span>], o2[<span class="number">1</span>]) : Integer.compare(o1[<span class="number">0</span>], o2[<span class="number">0</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] goods = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        goods[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> good = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[j][<span class="number">0</span>] &gt; envelopes[i][<span class="number">0</span>]) &#123;   <span class="comment">// 比较宽</span></span><br><span class="line">                    <span class="keyword">if</span> (envelopes[j][<span class="number">1</span>] &gt; envelopes[i][<span class="number">1</span>]) &#123;    <span class="comment">// 比较高</span></span><br><span class="line">                        good = Math.max(good, goods[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;   <span class="comment">// 寻找比信封i大的信封，信封j不可能时，前面的信封宽更小，</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            goods[i] = good + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> goods : goods) &#123;</span><br><span class="line">            res = Math.max(res, goods);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题意提取&quot;&gt;&lt;a href=&quot;#题意提取&quot; class=&quot;headerlink&quot; title=&quot;题意提取&quot;&gt;&lt;/a&gt;题意提取&lt;/h2&gt;&lt;p&gt;信封有两属性，宽（w），高（h）;&lt;br&gt;信封a套入信封b的要求:
w[a] &amp;lt; w[b] &amp;amp;&amp;amp; h[
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://wjploop.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Android Single Activity design (译)</title>
    <link href="http://wjploop.github.io/2021/02/26/Android-Single-Activity-design-%E8%AF%91/"/>
    <id>http://wjploop.github.io/2021/02/26/Android-Single-Activity-design-译/</id>
    <published>2021-02-26T03:28:40.000Z</published>
    <updated>2021-06-20T07:23:07.720Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="(https://proandroiddev.com/part-3-single-activity-architecture-514791724172)">原文</a></p></blockquote><h1 id="Android-单一Activity设计思路"><a href="#Android-单一Activity设计思路" class="headerlink" title="Android: 单一Activity设计思路"></a>Android: 单一Activity设计思路</h1><p>在19年Google I/O Talk上，单一Activity设计原则伴随着 Jetpack Navigation 被提及，现在Google更推荐<code>单一Activity</code>设计作为首选架构。</p><blockquote><p>我们又有造新名词了吗？”SAAs(Single Activity Applications)” 关于”单一Activity”，这个设计思路，即使Android开发圈子也并不是新鲜事物。</p></blockquote><p>单一Activity设计，可以类比web开发中<code>单页面应用</code>,<code>单页面应用</code>设计思路在现代web开发框架中非常流行。</p><p>本文我们将讨论以下几点：</p><ul><li><code>单一Activity</code>设计解决了什么问题？</li><li>何时该采用<code>单一Activity</code>设计?</li><li>对于现有的项目我们能做什么？</li></ul><p>在讨论这几点之前，先简单介绍下Activity和Fragment  </p><h2 id="Activity是什么？"><a href="#Activity是什么？" class="headerlink" title="Activity是什么？"></a>Activity是什么？</h2><p>Activity作为Android应用的入口，显然在任何一个应用中至少需要一个Activity。</p><blockquote><p>Activity作为四大组件之一，聚焦于一点，描述用户能做什么。几乎所有的Activity都与用户交互，故<code>Activity</code>类负责创建<code>Widnow</code>展示内容给用户，通过<code>setContentView(View)</code>方法我们可以放置所要展示的内容。尽管<code>Activity</code>通常用来展示全屏页面，但是也是可以用于其他方式…</p><p>摘自官方文档 <a href="https://developer.android.com/reference/android/app/Activity" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/Activity</a></p></blockquote><h2 id="使用Activity有什么问题？"><a href="#使用Activity有什么问题？" class="headerlink" title="使用Activity有什么问题？"></a>使用Activity有什么问题？</h2><p>嗯…并没有出现多大的问题，以致你一定要使用单一Activity设计。  </p><p>而且，Android设计的理念，一个页面对应了一个Activity。至少，在引入Fragment之前是这样的，这种理念从Android诞生之后就一直被这么采用。</p><h2 id="Fragment是什么？"><a href="#Fragment是什么？" class="headerlink" title="Fragment是什么？"></a>Fragment是什么？</h2><blockquote><p>Fragment能替代Activity，因为Activity能做的，Fragment也能做。</p></blockquote><p>引入Fragment主要的目的，是让我们描述UI的代码可以复用，支持动态灵活的UI设计，因为Activity之间不能嵌套。（LocalActivityManager已经永远地被遗弃了）。</p><p>Fragment的APIs推出后已经改进很多了。最初，Fragment只是拥有与Activity相似的生命周期，如今，Fragment已经支持自己<code>后退栈</code>，并使用FragmentManager来管理。</p><p>在以下场景中，Fragment显得非常强大:</p><ul><li>支持多屏适配</li><li>使用ViewPager，这要求一定要使用Fragment</li><li>创建一个包含UI库，暴露一个Fragment而不是一个Activity意义就大很多了</li></ul><h2 id="Fragment存在什么问题"><a href="#Fragment存在什么问题" class="headerlink" title="Fragment存在什么问题?"></a>Fragment存在什么问题?</h2><p>Fragment曾存在很多问题，但随着Jetpack架构架构组件的引入，特别是<code>ViewModel</code>和<code>LiveData</code>的引入，很多问题都得到了解决。</p><p>实际上，抛开view-base框架，我们也毫无选择而必须使用Fragment。</p><blockquote><p>在本文，我不会去讨论其他避免使用Fragment的方法，比如：<a href="https://github.com/bluelinelabs/Conductor" target="_blank" rel="noopener">Conductor</a></p></blockquote><p>Fragment有一个优势：它现在不是Android框架的一部分，而是存在于Jetpack中。这样，很容易利于Android团队修复问题和添加新特性。</p><p>因此，对于我们自己的app，若是想要展示UI，我们必须声明一个Activity作为入口，但对于实现其他页面，我们可以存在很多方案。</p><h2 id="方案1：每一个页面作为独立的Activity"><a href="#方案1：每一个页面作为独立的Activity" class="headerlink" title="方案1：每一个页面作为独立的Activity"></a>方案1：每一个页面作为独立的Activity</h2><p>就如同Fragment未曾出现过一样。</p><p>比如，我们设计一个”购物”流程。我们可能会需要三个页面，购物清单清点页面，购物车详情页面，支付页面。这样就会有三个Activity需要被创建：</p><ol><li>OrderListReviewActivity</li><li>ShippingDetailActivity</li><li>PaymentActivity</li></ol><h2 id="方案2：每一个流程（模块）独立为一个Activity"><a href="#方案2：每一个流程（模块）独立为一个Activity" class="headerlink" title="方案2：每一个流程（模块）独立为一个Activity"></a>方案2：每一个流程（模块）独立为一个Activity</h2><p>App中每个模块独立为一个Activity，模块中的子页面使用Fragment来实现。</p><p>如此，将会有下列需实现：</p><ol><li>CheckoutActivity</li><li>OrderListReviewFragment</li><li>ShippingDetailFragment</li><li>PaymentFragment</li></ol><h2 id="方案3：单一Activity"><a href="#方案3：单一Activity" class="headerlink" title="方案3：单一Activity"></a>方案3：单一Activity</h2><p>将只有一个Activity作为应用入口，所有的页面使用Fragment实现，这个Activity作为宿主负责存放和管理Fragment。</p><p>给个例子，当前流程跨平台框架都在使用该方案，比如 Xamarin, Ionic, Flutter, Reactive Native, 它们表现都很好。</p><p>通常，我看到的情况是，开始会选择方案1，只用Activity，慢慢地Fragment被引入，绝大数是因为：</p><ol><li>需要支持手机和平板</li><li>需要复用UI</li><li>需要使用ViewPager，这个强制使用Fragment</li><li>使用了一些第三方库，其使用了Fragment作为暴露UI的方式，如:Google Maps</li></ol><p>理论上，我们可能处于方案1和方案2之间，而方案2切换到单一Activity设计差别不大。</p><h2 id="单一Activity设计解决了什么问题？"><a href="#单一Activity设计解决了什么问题？" class="headerlink" title="单一Activity设计解决了什么问题？"></a>单一Activity设计解决了什么问题？</h2><h3 id="1-不同版本Activity表现不一致"><a href="#1-不同版本Activity表现不一致" class="headerlink" title="1. 不同版本Activity表现不一致"></a>1. 不同版本Activity表现不一致</h3><p>Activity作为Android框架一部分，其行为和支持特性绑定了Android版本。添加的新特性和修复的bug并不能保证在低版本系统中可用。或许，你可能选择兼容库如 ActivityCompat,ActivityOptionCompat等来解决那些边角问题，但这很痛苦。</p><p>多个Activity不仅增加了开发时间，也增加了测试时间。表现不一致的问题，也同样存在于不同设备和不同版本。</p><p>###2. 在Activity功能共享数据</p><p>在Activity之间，想要共享数据，只能将该数据放在Application级别作用域中。然而，在该作用域中，其他的Android组件也能获取到了，如Service，BroadcastReceiver,ContentProvider.</p><p>理想中，应该存在一个独立的作用域，用于存放几个页面共享的的数据，最好是在Activity级别的。</p><p>###3. 糟糕的用户体验</p><p>当切换Activity时，整个窗口都会被替换。因而，Toolbar/ActionBar也将会替换。我个人认为，Toolbar不应该被替换，而是应该更新相关的内容即可。如同桌面应用一样，Toolbar永远不变，变的仅有下面的内容。</p><p>而且，由于不同版本的Activity表示不一致，其场景切换动画也会在不同设备不同版本表现不一致。</p><p>###4. 开发体验</p><p>当使用多个Activity时: </p><ul><li><p>每添加一个页面都要同步添加该Activity到Manifest文件中，仔细想想是不是有点奇怪。</p></li><li><p>某个控制功能需要在多个页面都需要实现时，将会耗费额外的精力。比如NavigationDrawer，底部栏，通用的菜单栏。</p></li><li><p>检测应用是否正在运行将变得困难，会发现在同一个时间，会有多个Activity在栈中。</p></li></ul><p>单一Activity设计看来是一个很好的架构设计。但，直到现在，这样的架构缺少相关的框架，实现是困难的。目前存在一些支持单一Activity的框架比如Conductor和Scoop,但它们不支持Fragment。</p><p>随着Navigation组件的引入，现在已经很容易实现单一Activity的架构了。</p><h2 id="什么时候该采用单一Activity设计"><a href="#什么时候该采用单一Activity设计" class="headerlink" title="什么时候该采用单一Activity设计"></a>什么时候该采用单一Activity设计</h2><p>采用单一Activity设计遇到的问题，Navigation组件已经为我们解决大部分了，所以，若是你现在开始新的项目，你应该毫无疑问的采用该设计。</p><p>Navigation组件提供了容易理解的API，类storyboard（IOS开发）的编辑器和详尽的文档和入门教程。</p><p>Navigation支持以下：</p><ol><li>处理<a href="https://developer.android.com/training/app-links/deep-linking" target="_blank" rel="noopener">deep link</a></li><li>简单可靠的转场动画</li><li>更易用处理Toolbar</li><li>支持动态特性模块</li></ol><h2 id="对于现有的项目我们能做什么？"><a href="#对于现有的项目我们能做什么？" class="headerlink" title="对于现有的项目我们能做什么？"></a>对于现有的项目我们能做什么？</h2><p>理论上，对于那些已经混合了Activity和Fragment的现有项目，逐渐迭代到单一Activity设计是有意义的。开始，可以选择一个小模块进行单一Activity多Fragment切换。  </p><p>若是有人拥有迭代现有项目到单一Activity设计的经验，我原意与之一起讨论其中的细节。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单一Activity设计不是新鲜的概念了</li><li>诸如Conductor和Scoop基于View-based实现单一Activity的框架不支持Fragment</li><li>在Navigation推出之前，使用Fragment实现单一Activity设计不划算</li><li>Navigation组件可实现基于Fragment的单一Activity</li><li>对于新项目，应该毫无疑问使用单一Activity设计了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;(https://proandroiddev.com/part-3-single-activity-architecture-514791724172)&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Andr
      
    
    </summary>
    
    
      <category term="翻译" scheme="http://wjploop.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>navigation走的弯路</title>
    <link href="http://wjploop.github.io/2021/02/25/navigation%E8%B5%B0%E7%9A%84%E5%BC%AF%E8%B7%AF/"/>
    <id>http://wjploop.github.io/2021/02/25/navigation走的弯路/</id>
    <published>2021-02-25T07:17:26.000Z</published>
    <updated>2021-03-05T12:05:00.531Z</updated>
    
    <content type="html"><![CDATA[<p>最近在尝试使用Jetpack中的Navigation组件，遇到了一个问题，差点放弃了，最后坚持下来了，做下记录  </p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>根据Google推出的一个设计理念，在</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在尝试使用Jetpack中的Navigation组件，遇到了一个问题，差点放弃了，最后坚持下来了，做下记录  &lt;/p&gt;
&lt;h3 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>失效的技巧</title>
    <link href="http://wjploop.github.io/2021/02/20/%E5%A4%B1%E6%95%88%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    <id>http://wjploop.github.io/2021/02/20/失效的技巧/</id>
    <published>2021-02-20T02:47:32.000Z</published>
    <updated>2021-03-05T12:05:00.530Z</updated>
    
    <content type="html"><![CDATA[<p>开工了，2021年~</p><p>过年在V站看到一个帖子<a href="https://www.v2ex.com/t/753483" target="_blank" rel="noopener">有些技巧以前很重要，现在越来越没用了</a> ，感慨很多。以前学的很多技巧，用来解决某个问题，而当问题不在之后，这个技巧也就失效了。</p><p>对于失效的技巧，发现大家的反应会分为两种</p><ul><li>感性派（源于技巧的关键字，开始怀念过去）  </li><li>理性派（反思为什么会这样子，如何避免花过多精力于技巧）  </li></ul><h2 id="我想我是感性派"><a href="#我想我是感性派" class="headerlink" title="我想我是感性派"></a>我想我是感性派</h2><p>其中有个人提及的</p><blockquote><p>斯凯 MTK 应用。通过<em>#220807#、</em>#777755999#打开国产山寨手机的 mrp 应用列表入口，可能需要安装 applist.mrp yyrj.mrp dsm_gm.mrp 三个文件，然后把其他 mrp 格式的应用放到对应位置就可以打开了。当年 mrp 软件和游戏还是有很多精品的，可惜现在 mrp 这个关键词都搜不到了。</p></blockquote><p>提及“MTK”、”MRP“、那都是满满的青春回忆~   *#220807# 应用入口命令，再熟悉不过了，看到一个新的山寨机，便会不由自主的按下试试支不支持安装应用。<br>对了，还有一个文件夹名称，“mythroad”，支持安装应用的手机，会在SD卡根目录下生成该文件夹。当时英文不好，只是记着这7个单词，现在回头看，发现这个可以是 “myth road” 神话之路，突然能感受取这个名字的用意了。</p><p>其实，我咋看以为是 “my throat(d)” 我的喉咙，啊，感觉到不对劲，查了下，才发人家的原意，现在的英文也还不行，不过，这提示我们命名要用驼峰或下划线啊~</p><h2 id="假装是理性派"><a href="#假装是理性派" class="headerlink" title="假装是理性派"></a>假装是理性派</h2><p>为什么技巧会失效？</p><p>技巧是是针对某个问题的巧妙方法，是解决问题的方式，问题消失了，我们技巧也就没用了。比如，我怀念的山寨机应用神话之路，当今已经没有山寨机，这种技巧也就没有用武之地了。  </p><p>如何避免技巧会失效？</p><p>避免技巧失效，依据失效的原因，就是要避免问题会消失。而问题会消失吗？有点的会，有的不会，故有些技巧会一生有用，比如，沟通时需照顾对方感受时采取换位思考，有的技巧注定会失效，比如记住那个*#220807#应用入口命令。我们凭什么认为换位思考的技巧一生有效？深究起来似乎也站不住脚，假如人与人不需要沟通了呢？去掉假如，我与之沟通的不是人，而是一台机器呢？啊，别抬杠自己了。与人交流这个需求，在我的认知里面永远会存在。</p><p>技巧失效的场景，想到了职业问题，为什么医生会越老越吃香，而程序员老了就没人要了。是不是存在一个原因是，两者工作的对象，人的变化相对机器要少很多，故而，医生掌握的技巧对有效性更久一些。</p><p>我们试图寻求在不变的问题，从而将技巧的有效性延长。我们所遇的问题中，很多问题是相通的，不同的问题是存在相同部分，我们解决的问题选择分治法，将问题拆分，逐一解决，解决子问题时使用掌握的技巧。这样，可以说，技巧是存在延续性的。根据这点，我们能所做的是，平时遇到问题后，三思而行，将问题拆分逐一解决，积累解决通用问题的工具包。</p><p>感觉这种策略是普遍的，大家也都是这么做的。突然想到了数学的一些名词，定义，性质，推论，我们有限的小脑子要掌握哪些东西呢？定义永远是优先掌握的吧，性质用来让我们如何更加立体理解定义，推论用来解决我们的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开工了，2021年~&lt;/p&gt;
&lt;p&gt;过年在V站看到一个帖子&lt;a href=&quot;https://www.v2ex.com/t/753483&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有些技巧以前很重要，现在越来越没用了&lt;/a&gt; ，感慨很多。
以前学的很多技
      
    
    </summary>
    
      <category term="随想" scheme="http://wjploop.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>左右抖动的动画</title>
    <link href="http://wjploop.github.io/2020/07/18/2020-07-18%E5%B7%A6%E5%8F%B3%E6%8A%96%E5%8A%A8%E7%9A%84%E5%8A%A8%E7%94%BB/"/>
    <id>http://wjploop.github.io/2020/07/18/2020-07-18左右抖动的动画/</id>
    <published>2020-07-18T07:21:59.000Z</published>
    <updated>2020-07-20T06:28:08.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标效果"><a href="#目标效果" class="headerlink" title="目标效果"></a>目标效果</h3><img src="/images/anim_target.gif" width="240" height="200"><p>触发后，金币左右抖动多次，向上移动并消失，文字向下移动显示   </p><p>实现方式似乎很简单，依次实现上述三个动画即可</p><p>而本文主要展示我在第一个动画的探索过程</p><h3 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h3><p>我们需要保持动画结束时的状态，故采用属性动画。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>,  -<span class="number">100f</span>,  <span class="number">100f</span>).apply &#123;</span><br><span class="line">    duration = <span class="number">1000</span></span><br><span class="line">    repeatCount = <span class="number">2</span></span><br><span class="line">    repeatMode = ValueAnimator.REVERSE</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><img src="/images/anim_version_0.gif" width="240" height="200"><p>存在问题，动画播放开始时，金币直接跳到左边，而非缓慢移动到左边，导致动画开始时和结束时很突兀。</p><h3 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h3><p>针对发现的原因，我们把中点到左边的过程也纳入动画中，<br>改变如下</p><p>原本： left -&gt; right<br>现在： mid -&gt; left -&gt; mid -&gt; right -&gt; mid   </p><p>同时，重复模式也要改成<code>RESTART</code>, 原因，动画重复时，当前定义的路径是不能翻转的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>,  <span class="number">0f</span>, -<span class="number">100f</span>, <span class="number">0f</span>, <span class="number">100f</span>, <span class="number">0f</span>).apply &#123;</span><br><span class="line">    duration = <span class="number">1000</span></span><br><span class="line">    repeatCount = <span class="number">2</span></span><br><span class="line">    repeatMode = ValueAnimator.RESTART</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><img src="/images/anim_version_1.gif" width="240" height="200"><p>存在问题，重复播放到中点时，金币摆动的速度会变得很慢，后才逐渐加快</p><h3 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h3><p>一直误以为插值器是匀速线性，即<code>LinearInterpolator</code>，导致的这个错误认知的原因应该来源于这个方法。<br>当设的值为空时，便设为<code>LinearInterpolator</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> void setInterpolator(TimeInterpolator value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        mInterpolator = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInterpolator = new LinearInterpolator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而实际上默认的插值器是非线性的,即<code>AccelerateDecelerateInterpolator</code>，先加速后减速。仔细想想使用这个插值器更加合理，更加接近自然效果。生活中，当我们用力推动一个小球一段时间，加速到减速的过程更加符合实际。</p><p>而这里，我们尝试将插值器改为线性的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>,  <span class="number">0f</span>, -<span class="number">100f</span>, <span class="number">0f</span>, <span class="number">100f</span>, <span class="number">0f</span>).apply &#123;</span><br><span class="line">    duration = <span class="number">1000</span></span><br><span class="line">    repeatCount = <span class="number">2</span></span><br><span class="line">    interpolator=LinearInterpolator()</span><br><span class="line">    repeatMode = ValueAnimator.RESTART</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><img src="/images/anim_version_2.gif" width="240" height="200"><p>存在问题，摆动的整个过程很僵硬，不符合自然效果。</p><h3 id="版本4"><a href="#版本4" class="headerlink" title="版本4"></a>版本4</h3><p>为了让金币摆动自然，我的方案是将金币摆动的过程分为三个动画实现，每个动画使用默认的插值器。</p><p>动画1：mid -&gt; left<br>动画2：left -&gt; right<br>动画3：right -&gt; mid   </p><p>注意duration时间的分配</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AnimatorSet().apply &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> xDuration = <span class="number">1000L</span></span><br><span class="line">    <span class="keyword">val</span> xOffset = <span class="number">100f</span></span><br><span class="line"></span><br><span class="line">    playSequentially(</span><br><span class="line">        ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>, -xOffset)</span><br><span class="line">            .setDuration((xDuration / <span class="number">2</span>)),</span><br><span class="line">        ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>, -xOffset, xOffset).apply &#123;</span><br><span class="line">            duration = xDuration</span><br><span class="line">            repeatMode = ValueAnimator.REVERSE</span><br><span class="line">            repeatCount = <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ObjectAnimator.ofFloat(iv_coin, <span class="string">"translationX"</span>, <span class="number">0f</span>).setDuration((xDuration / <span class="number">2</span>))</span><br><span class="line">    )</span><br><span class="line">&#125;.start</span><br></pre></td></tr></table></figure><img src="/images/anim_version_3.gif" width="240" height="200"><p>效果已经符合我的需求，不知道有没有更好的实现方式？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;目标效果&quot;&gt;&lt;a href=&quot;#目标效果&quot; class=&quot;headerlink&quot; title=&quot;目标效果&quot;&gt;&lt;/a&gt;目标效果&lt;/h3&gt;&lt;img src=&quot;/images/anim_target.gif&quot; width=&quot;240&quot; height=&quot;200&quot;&gt;


&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>有限状态机</title>
    <link href="http://wjploop.github.io/2020/06/30/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://wjploop.github.io/2020/06/30/有限状态机/</id>
    <published>2020-06-30T10:33:37.000Z</published>
    <updated>2020-06-30T10:40:50.362Z</updated>
    
    <content type="html"><![CDATA[<p>有限状态机，刷题了解到这个概念时，惊叹了我。故此想要记录一下。  </p><p>原题<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a><br>题目描述</p><blockquote><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</p></blockquote><p>看到这样的题目，给人感觉就是好像思路了解了，但会有好多情况要判断啊。 </p><p>我能尝试写出的代码是这样子的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(s:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 是否是第一个字符</span></span><br><span class="line">    <span class="keyword">var</span> first = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 第一个字符时什么了，根据该类型继续判断后面的的输入是否正确</span></span><br><span class="line">    <span class="comment">// 1 正负号 2 小数点 3 数字 </span></span><br><span class="line">    <span class="keyword">var</span> firstCharType = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ch <span class="keyword">in</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first)&#123;  <span class="comment">//若是第一个字符</span></span><br><span class="line">            first = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">when</span>(ch)&#123;   <span class="comment">//记录第一个字符类型，为后续判断做为条件</span></span><br><span class="line">                <span class="string">'+'</span> or <span class="string">'-'</span> -&gt;&#123;  </span><br><span class="line">                    firstCharType = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span> -&gt;&#123;</span><br><span class="line">                    firstCharType = <span class="number">3</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="string">'.'</span> -&gt;&#123;</span><br><span class="line">                    firstCharType = <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt;&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>    <span class="comment">//第一个字符就可以确定不是数子</span></span><br><span class="line">                &#125;       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">when</span>(firstCharType)&#123;    <span class="comment">// 依据前面的状态，判断后续能有什么输入</span></span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码，写出来是不放心的，总感觉自己会遗漏某个分支情况。而且写出来后，代码肯定很长很繁琐。</p><p>而大佬使用有限状态机的代码是这样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        states = [</span><br><span class="line">            &#123; <span class="string">' '</span>: <span class="number">0</span>, <span class="string">'s'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">4</span> &#125;, <span class="comment"># 0. start with 'blank'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">4</span> &#125; ,                <span class="comment"># 1. 'sign' before 'e'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">3</span>, <span class="string">'e'</span>: <span class="number">5</span>, <span class="string">' '</span>: <span class="number">8</span> &#125;, <span class="comment"># 2. 'digit' before 'dot'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">3</span>, <span class="string">'e'</span>: <span class="number">5</span>, <span class="string">' '</span>: <span class="number">8</span> &#125;,         <span class="comment"># 3. 'digit' after 'dot'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">3</span> &#125;,                         <span class="comment"># 4. 'digit' after 'dot' (‘blank’ before 'dot')</span></span><br><span class="line">            &#123; <span class="string">'s'</span>: <span class="number">6</span>, <span class="string">'d'</span>: <span class="number">7</span> &#125;,                 <span class="comment"># 5. 'e'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">7</span> &#125;,                         <span class="comment"># 6. 'sign' after 'e'</span></span><br><span class="line">            &#123; <span class="string">'d'</span>: <span class="number">7</span>, <span class="string">' '</span>: <span class="number">8</span> &#125;,                 <span class="comment"># 7. 'digit' after 'e'</span></span><br><span class="line">            &#123; <span class="string">' '</span>: <span class="number">8</span> &#125;                          <span class="comment"># 8. end with 'blank'</span></span><br><span class="line">        ]</span><br><span class="line">        p = <span class="number">0</span>                           <span class="comment"># start with state 0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'0'</span> &lt;= c &lt;= <span class="string">'9'</span>: t = <span class="string">'d'</span> <span class="comment"># digit</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">"+-"</span>: t = <span class="string">'s'</span>     <span class="comment"># sign</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">".eE "</span>: t = c     <span class="comment"># dot, e, blank</span></span><br><span class="line">            <span class="keyword">else</span>: t = <span class="string">'?'</span>               <span class="comment"># unknown</span></span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> states[p]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p = states[p][t]</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>这样的代码看得真的舒服，加上配的状态转移图，逻辑也是清晰很多。<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/" target="_blank" rel="noopener">大佬的题解</a></p><p>个人的蹩脚的理解   </p><p>在一个系统中，当前的状态称为<code>现态</code>，外界输入称为<code>动作</code>, 随着输入后当前状态改变的结果称为<code>次态</code>,次态生成之后便成为新的现态，周而复始。 而<code>次态</code>的生成，不仅依赖输入，也依赖<code>现态</code>。这样会有这么一个逻辑，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = f(state, action)</span><br></pre></td></tr></table></figure><p>而这个函数<code>f</code> 是什么呢？我们可以体会到，它像数学中的条件函数，可以枚举出所有的条件，以及可接受的所有action,结果也就随之确定。</p><p>在这道题中,比如当前状态是，前面是空格（初始状态），下一个字符只能是数字，正负号等等，而不能接受<code>e</code>等输入。在这道题目中，我们可以体会到状态区分不是很清晰的，当前状态时之前所有输入的叠加。 </p><p>代码上，我们用states集合定义所有状态，而其中状态能够接受什么action和转移后的次态，分别用Key-Value表示。</p><p>联想日常开发中的相似的东西，当前页面的加载数据的状态。</p><p>Init –(request fetch data)–&gt; Loading –(load failed)–&gt; Failed –(retry)–&gt; Loading –(load success)–&gt; Success </p><p>这么一个流程，初始页面，请求数据，加载中，加载失败，重试，加载成功。</p><p>我们似乎可以意识到，想要达到<code>加载成功</code>状态，那么之前的状态是确定的，不存在从<code>初始状态</code>直接跳转到<code>加载成功</code>，期间必须经历状态<code>加载中</code>。 在页面的加载中，似乎可以列举出所有的状态，甚至所有的函数<code>f</code>,状态转移的关系。</p><p>页面加载中，状态较少，输入也少，因而不引入有限状态的概念我们也能理清他们的转移关系。不过，感觉这个概念确实是个好工具，针对多个状态的场景就很有必要了。但愿以后在业务复杂的场景能够引入这个概念来解决问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有限状态机，刷题了解到这个概念时，惊叹了我。故此想要记录一下。  &lt;/p&gt;
&lt;p&gt;原题&lt;a href=&quot;https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/&quot; target=&quot;_blan
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Glide源码略看</title>
    <link href="http://wjploop.github.io/2020/06/29/Glide%E6%BA%90%E7%A0%81%E7%95%A5%E7%9C%8B/"/>
    <id>http://wjploop.github.io/2020/06/29/Glide源码略看/</id>
    <published>2020-06-29T10:55:50.000Z</published>
    <updated>2020-06-30T07:10:47.446Z</updated>
    
    <content type="html"><![CDATA[<p>##碎碎念</p><p>介绍Glide的文章看了挺多，偶尔也会点击查看部分的Glide的源码，可感觉对Glide的还是不太懂。个人觉得，每个人的水平不同，对知识点的掌握的面不同，可能他人的已掌握的知识点于自己而言是盲点，，写源码分析的人一般将自己觉得值得写的东西记录下来，故通过看他人的二手资料来了解一个库，可能会出现这么个情况，感觉自己自己看懂了，但却没有学到什么东西。看文章时是假设他人掌握的知识来得出结论的，可自己实际上没有学到那些前置知识。故，我还是想尝试自己看看。</p><p>##开始</p><p>看不懂现在的库，切换早些年的版本，比较容易查看整体轮廓。</p><h2 id="版本时间2012-12-21"><a href="#版本时间2012-12-21" class="headerlink" title="版本时间2012/12/21"></a>版本时间2012/12/21</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.两个缓存</span></span><br><span class="line">    <span class="comment">//加载图片，二级缓存，优先从内存获取，其次从磁盘，最后才会请求网络。</span></span><br><span class="line">    <span class="keyword">private</span> PhotoDiskCache diskCache;</span><br><span class="line">    <span class="keyword">private</span> LruPhotoCache memoryCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.图片大小转换器</span></span><br><span class="line">    <span class="comment">//解决源图片，与我们显示的图片大小不一致的问题</span></span><br><span class="line">    <span class="keyword">private</span> PhotoStreamResizer resizer;</span><br><span class="line">    <span class="comment">//3.任务调度</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Future&gt; taskManager = <span class="keyword">new</span> HashMap&lt;Object, Future&gt;();</span><br><span class="line">    <span class="keyword">private</span> Handler backgroundHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二个缓存"><a href="#二个缓存" class="headerlink" title="二个缓存"></a>二个缓存</h3><p>加载图片的流程，感觉是最常问也最重要的知识点了。加载图片，存在二个缓存，内存缓存和磁盘缓存，空间换时间的经典例子了。其中，缓存的实现使用是LRU算法，内部实现可以使用<code>LinkedHashMap</code>，只要将构造方法中<code>accessOrder</code>设为true既可。</p><h3 id="图片大小转换器"><a href="#图片大小转换器" class="headerlink" title="图片大小转换器"></a>图片大小转换器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 有图片地址，有想要图片的大小，故我们需要将原图缩放成指定的大小</span></span><br><span class="line">    <span class="comment">// 转换时耗时的，故这里使用Future来</span></span><br><span class="line">    <span class="comment">// Future个人理解就是可以获得返回结果的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;Bitmap&gt; <span class="title">loadApproximate</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> <span class="keyword">int</span> width, <span class="keyword">final</span> <span class="keyword">int</span> height, ResizeCallback callback)</span></span>&#123;</span><br><span class="line">        Callable&lt;Bitmap&gt; task = <span class="keyword">new</span> Callable&lt;Bitmap&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Utils.streamIn(path, width, height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> startTask(task, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###关于线程切换，这里使用了<code>Handler</code>的例子。<br>比如我们执行转换图片的任务，需要到子线程处理，转换完成后，需要将结果给UI线程来处理接口。<br>如何将一部分实现交给调用者，这里使用了<code>Callback</code>。如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamResizeFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 处理的结果结果需要交给UI线程处理，故需要主线程的handler</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mainHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResizeCallback callback;</span><br><span class="line">    <span class="keyword">private</span> Bitmap result;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.done();</span><br><span class="line">        <span class="keyword">if</span> (!isCancelled())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = get();</span><br><span class="line">                <span class="comment">// 将部分逻辑在UI线程执行</span></span><br><span class="line">                mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callback.onResizeComplete(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callback.onResizeFailed(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片大小转换的具体实现"><a href="#图片大小转换的具体实现" class="headerlink" title="图片大小转换的具体实现"></a>图片大小转换的具体实现</h3><p>感觉缩放图片的大小具体实现挺有意思（见识短，大惊小怪）   </p><p>将变换的逻辑在矩阵上操作，比如放大，设置轴点，再将该变换应用于图片流上，最后便得到我们想要的图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Bitmap&gt; <span class="title">resizeCenterCrop</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> <span class="keyword">int</span> width, <span class="keyword">final</span> <span class="keyword">int</span> height, ResizeCallback callback)</span></span>&#123;</span><br><span class="line">    Callable&lt;Bitmap&gt; task = <span class="keyword">new</span> Callable&lt;Bitmap&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Bitmap result = <span class="keyword">null</span>, streamed = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取到图片流，</span></span><br><span class="line">            streamed = Utils.streamIn(path, width, height);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (streamed.getWidth() == width &amp;&amp; streamed.getHeight() == height) &#123;</span><br><span class="line">                <span class="keyword">return</span> streamed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//from ImageView/Bitmap.createScaledBitmap</span></span><br><span class="line">            <span class="comment">//https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java</span></span><br><span class="line">            <span class="comment">//https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> scale;</span><br><span class="line">            <span class="keyword">float</span> dx = <span class="number">0</span>, dy = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 创建矩阵，将图片流画在矩阵中</span></span><br><span class="line">            Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">            <span class="keyword">if</span> (streamed.getWidth() * height &gt; width * streamed.getHeight()) &#123;</span><br><span class="line">                scale = (<span class="keyword">float</span>) height / (<span class="keyword">float</span>) streamed.getHeight();</span><br><span class="line">                dx = (width - streamed.getWidth() * scale) * <span class="number">0.5f</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                scale = (<span class="keyword">float</span>) width / (<span class="keyword">float</span>) streamed.getWidth();</span><br><span class="line">                dy = (height - streamed.getHeight() * scale) * <span class="number">0.5f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            m.setScale(scale, scale);</span><br><span class="line">            m.postTranslate((<span class="keyword">int</span>) dx + <span class="number">0.5f</span>, (<span class="keyword">int</span>) dy + <span class="number">0.5f</span>);</span><br><span class="line">            Bitmap bitmap = Bitmap.createBitmap(width, height, streamed.getConfig());</span><br><span class="line">            Canvas canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">            Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">            <span class="comment">//only if scaling up</span></span><br><span class="line">            paint.setFilterBitmap(<span class="keyword">false</span>);</span><br><span class="line">            paint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">            canvas.drawBitmap(streamed, m, paint);</span><br><span class="line">            result = bitmap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> startTask(task, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="似乎是一个常见的面试问题的源头"><a href="#似乎是一个常见的面试问题的源头" class="headerlink" title="似乎是一个常见的面试问题的源头"></a>似乎是一个常见的面试问题的源头</h3><p>如何加载一个很大的图片？假设一张原图片像素有10000<em>10000,而我们只需要10</em>10的像素的图片，那么我们不该将整个图片读取下来再缩放成我们想要的大小，而且假设有一个巨大大图片，读取整个图片内存直接爆了。我们是能否将部分图片读取显示呢？</p><p>大佬也遇到了这个问题，也给(google)出了答案。<br>其中，思路是这样的，</p><ol><li>读取图片文件前半部分的字节（16字节足以），获取到该图片的信息，如图片大小</li><li>根据原图大小和想要的大小，算出采样的比例，再次读取是传入采样比例,这样子，读取的图片就只有目标图片所占的内存。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from http://stackoverflow.com/questions/7051025/how-do-i-scale-a-streaming-bitmap-in-place-without-reading-the-whole-image-first</span></span><br><span class="line"><span class="comment">//streams in to near, but not exactly at the desired width and height.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">streamIn</span><span class="params">(String path, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Bitmap result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个Opitions来记录图片大小</span></span><br><span class="line">        <span class="keyword">final</span> BitmapFactory.Options decodeBitmapOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        <span class="comment">// For further memory savings, you may want to consider using this option</span></span><br><span class="line">        InputStream first = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(path), <span class="number">16384</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find the dimensions of the actual image</span></span><br><span class="line">        <span class="comment">//获取到原图的实际大小</span></span><br><span class="line">        <span class="keyword">final</span> BitmapFactory.Options decodeBoundsOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        <span class="comment">// 如其所说，仅解码该图片大小</span></span><br><span class="line">        decodeBoundsOptions.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeStream(first, <span class="keyword">null</span>, decodeBoundsOptions); <span class="comment">//doesn't load, just sets the decodeBounds</span></span><br><span class="line">        first.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> originalWidth = decodeBoundsOptions.outWidth;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> originalHeight = decodeBoundsOptions.outHeight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inSampleSize prefers multiples of 2, but we prefer to prioritize memory savings</span></span><br><span class="line">        <span class="keyword">int</span> sampleSize = Math.min(originalHeight / height, originalWidth / width);</span><br><span class="line">        InputStream second = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(path), <span class="number">16384</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//算出采样比例，并传入作为参数传入下一次解码方法中</span></span><br><span class="line">        decodeBitmapOptions.inSampleSize = sampleSize;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; <span class="number">11</span>) &#123;</span><br><span class="line">            decodeBitmapOptions.inMutable = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(<span class="string">"PSR: Loading image with sample size: "</span> + sampleSize);</span><br><span class="line">        result = BitmapFactory.decodeStream(second, <span class="keyword">null</span>, decodeBitmapOptions);</span><br><span class="line">        <span class="keyword">if</span>(orientation != <span class="number">0</span>) &#123;</span><br><span class="line">            result = Photo.rotateImage(result, orientation);</span><br><span class="line">        &#125;</span><br><span class="line">        second.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        Log.d(<span class="string">"PSR: error decoding image: "</span> + e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError e)&#123;</span><br><span class="line">        Log.d(<span class="string">"PSR: not enough memory to resize image at "</span> + path);</span><br><span class="line">        Log.d(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要明白以上问题的答案，感觉应该查看这个文件。暂且了解以下两个属性吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Options</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 解码器仅查询原图大小，而不会分配内存来保存这些图片的像素</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * If set to true, the decoder will return null (no bitmap), but</span></span><br><span class="line"><span class="comment">                 * the &lt;code&gt;out...&lt;/code&gt; fields will still be set, allowing the caller to</span></span><br><span class="line"><span class="comment">                 * query the bitmap without having to allocate the memory for its pixels.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">boolean</span> inJustDecodeBounds;</span><br><span class="line">       </span><br><span class="line">                <span class="comment">// 采样图片的比例，比如传入4，加载图片有16M, 则加载的图片大小只有1M</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * If set to a value &gt; 1, requests the decoder to subsample the original</span></span><br><span class="line"><span class="comment">                 * image, returning a smaller image to save memory. The sample size is</span></span><br><span class="line"><span class="comment">                 * the number of pixels in either dimension that correspond to a single</span></span><br><span class="line"><span class="comment">                 * pixel in the decoded bitmap. For example, inSampleSize == 4 returns</span></span><br><span class="line"><span class="comment">                 * an image that is 1/4 the width/height of the original, and 1/16 the</span></span><br><span class="line"><span class="comment">                 * number of pixels. Any value &lt;= 1 is treated the same as 1. Note: the</span></span><br><span class="line"><span class="comment">                 * decoder uses a final value based on powers of 2, any other value will</span></span><br><span class="line"><span class="comment">                 * be rounded down to the nearest power of 2.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">int</span> inSampleSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于图片的处理，有挺多盲区的。平常对图片精细的操作很少，诸如上述问题，日常开发App也很少遇到，但是其原理确实应当了解。</p><h2 id="一些零碎的版本追踪"><a href="#一些零碎的版本追踪" class="headerlink" title="一些零碎的版本追踪"></a>一些零碎的版本追踪</h2><p>看到作者作者一步步添加了好多小东西，</p><p>添加Presenter来将Bitmap放置到ImageView</p><p>ImageLoader可以从加载Path和Assets资源文件，抽象成公共的接口</p><p>加载图片的key，缓存使用到，key的生成从加载的大小，加入显示类型，比如center_crop,fit_center</p><p>使用Weak reference避免内存泄漏</p><h2 id="引入android项目后的第一个版本-2013-1-10"><a href="#引入android项目后的第一个版本-2013-1-10" class="headerlink" title="引入android项目后的第一个版本 2013-1-10"></a>引入android项目后的第一个版本 2013-1-10</h2><p>项目使用Flickr网站的图片作为Demo   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity中的一个ListView中的Adapter实现</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View view, ViewGroup container)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ImagePresenter&lt;Photo&gt; presenter;</span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.d(<span class="string">"MyActivity: inflate"</span>);</span><br><span class="line">                ImageView imageView = (ImageView) inflater.inflate(R.layout.photo_grid_square, container, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">final</span> Animation fadeIn = AnimationUtils.loadAnimation(MyActivity.<span class="keyword">this</span>, R.anim.fade_in);</span><br><span class="line">                <span class="comment">// Presenter作为连接ImageView和ImageLoader的桥梁</span></span><br><span class="line">                <span class="comment">// 传入泛型参数包含图片源的基本信息，可以是图片的URL地址或是磁盘地址,这里的Photo包含有了</span></span><br><span class="line">                presenter = <span class="keyword">new</span> ImagePresenter.Builder&lt;Photo&gt;()</span><br><span class="line">                        .setImageView(imageView)</span><br><span class="line">                         <span class="comment">//这里传入一个缓存地址，会优先从磁盘获取的</span></span><br><span class="line">                        .setPathLoader(<span class="keyword">new</span> FlickPathLoader(flickerApi, cacheDir))</span><br><span class="line">                        <span class="comment">// 设置我们的加载ImageLoader哈</span></span><br><span class="line">                        .setImageLoader(<span class="keyword">new</span> CenterCrop&lt;Photo&gt;(imageManager))</span><br><span class="line">                        <span class="comment">// 获取到图片加载到ImageView</span></span><br><span class="line">                        .setImageSetCallback(<span class="keyword">new</span> ImageSetCallback() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageSet</span><span class="params">(ImageView view, <span class="keyword">boolean</span> fromCache)</span> </span>&#123;</span><br><span class="line">                                view.clearAnimation();</span><br><span class="line">                                <span class="keyword">if</span> (!fromCache)</span><br><span class="line">                                    view.startAnimation(fadeIn);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .build();</span><br><span class="line">                imageView.setTag(presenter);</span><br><span class="line">                view = imageView;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                presenter = (ImagePresenter&lt;Photo&gt;) view.getTag();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            presenter.setModel(photos.get(position));</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="看看如何优先从磁盘加载的呢"><a href="#看看如何优先从磁盘加载的呢" class="headerlink" title="看看如何优先从磁盘加载的呢"></a>看看如何优先从磁盘加载的呢</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadPhoto</span><span class="params">(Photo photo, File cacheDir, <span class="keyword">final</span> PhotoCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据photo的信息和缓存地址，定位到对应的文件是否存在哈</span></span><br><span class="line">    File out = <span class="keyword">new</span> File(cacheDir.getPath() + File.separator + photo.id + photo.secret);</span><br><span class="line">    <span class="keyword">if</span> (out.exists()) &#123;</span><br><span class="line">        cb.onDownloadComplete(out.getPath());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.d(<span class="string">"API: missing photo, downloading"</span>);</span><br><span class="line">        <span class="comment">// 开始从网络获取了</span></span><br><span class="line">        downloader.download(getPhotoUrl(photo), out, <span class="keyword">new</span> Downloader.DiskCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDownloadReady</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">                cb.onDownloadComplete(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，我们在看看Downloader是如何加载网络的资源，即download方法,我们找到了Downloader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下载器作为单例存在，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Downloader DOWNLOADER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mainHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其中维护了一个固定6个线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Downloader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HandlerThread workerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"downloader_thread"</span>);</span><br><span class="line">        workerThread.start();</span><br><span class="line">        executor = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        mainHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(String url, File out, DiskCallback cb)</span> </span>&#123;</span><br><span class="line">        post(<span class="keyword">new</span> DiskDownloadWorker(url, out, cb));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务放入线程池中启动</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        executor.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个下载任务如何执行的呢</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskDownloadWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"Downloader: run"</span>);</span><br><span class="line">            HttpURLConnection urlConnection = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//朴素的URLConnection打开流</span></span><br><span class="line">                <span class="keyword">final</span> URL targetUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">                urlConnection = (HttpURLConnection) targetUrl.openConnection();</span><br><span class="line">                InputStream in = <span class="keyword">new</span> BufferedInputStream(urlConnection.getInputStream());</span><br><span class="line">                OutputStream out = <span class="keyword">new</span> FileOutputStream(output);</span><br><span class="line">                <span class="comment">//将输入流写入文件</span></span><br><span class="line">                writeToOutput(in, out);</span><br><span class="line">                out.close();</span><br><span class="line">                in.close();</span><br><span class="line">                <span class="comment">//这里，使用mainHandler来切换当前线程到UI线程中执行</span></span><br><span class="line">                mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cb.onDownloadReady(output.getPath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (urlConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    urlConnection.disconnect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToOutput</span><span class="params">(InputStream in, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">while</span> (((bytesRead = in.read(buffer)) != -<span class="number">1</span>)) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Downloader实现了如何从一个URL转变成一个文件，其中，<br>本身作为单例存在，因为我们对于不同的下载，我们是可以复用同一个线程池的。<br>而使用线程池应付多个图片的请求。<br>另外使用了handler在下载完成后切换到UI线程中执行会回调，回调就是执行展示的操作  </p><p>回到Activiy，我们不能忘了我们的主角<code>ImageLoader</code>啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在onCreate方法中创建ImageLoader</span></span><br><span class="line">ImageManager.Options options = <span class="keyword">new</span> ImageManager.Options();</span><br><span class="line">    options.maxMemorySize = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    options.maxPerSize = <span class="number">40</span>;</span><br><span class="line">    imageManager = <span class="keyword">new</span> ImageManager(<span class="keyword">this</span>, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">//并且监听了Activity的生命周期方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    imageManager.resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    imageManager.pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中ImageLoader主要逻辑在第一版本已经说得差不多了，代码逻辑与最差版本相差不是很大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler mainHandler;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LruPhotoCache memoryCache;    <span class="comment">// 内存最近使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ImageResizer resizer;     <span class="comment">//图片大小转换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;        <span class="comment">//线程池调度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Integer&gt; bitmapReferenceCounter = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SizedBitmapCache bitmapCache;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PhotoDiskCache diskCache;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isBitmapRecyclingEnabled;</span><br></pre></td></tr></table></figure><h2 id="Glide名字出生了-2013-7-17"><a href="#Glide名字出生了-2013-7-17" class="headerlink" title="Glide名字出生了 2013-7-17"></a>Glide名字出生了 2013-7-17</h2><p>伴随着项目包名换成<code>glide</code>，不久之后，引入了Glide这个类，普通用户只需要懂得这个类就ok了，想了解原理的人也可以从这个类开始探索~     看看作者的介绍吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Static helper methods/classes to present a simple unified interface for using glide. Allows 90%</span></span><br><span class="line"><span class="comment"> * of the functionality of the library. The trade off is some extra unused object allocation, and a few unavailable</span></span><br><span class="line"><span class="comment"> * methods. For many users this should be enough to make effective use of the library. For others it can serve as a</span></span><br><span class="line"><span class="comment"> * starting point and example. This class is not thread safe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Glide</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接给创建一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Glide GLIDE = <span class="keyword">new</span> Glide();</span><br><span class="line">    <span class="comment">//定义了两个model，可以加载成图片流的源，File or URL</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class, ModelStreamLoader&gt; classToModelStream = <span class="keyword">new</span> HashMap&lt;Class, ModelStreamLoader&gt;() &#123;&#123;</span><br><span class="line">            put(File.class, <span class="keyword">new</span> FileStreamLoader());</span><br><span class="line">            put(URL.class, <span class="keyword">new</span> UrlStreamLoader());</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    <span class="comment">//之前的大名隐匿于此了</span></span><br><span class="line">    <span class="keyword">private</span> ImageManager imageManager;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Manages building, tagging, retrieving and/or replacing an ImagePresenter for the given ImageView and model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; The type of model that will be loaded into the view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//如何将图片源，加载到的目标ImageView的统一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> T model;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ImageView imageView;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ImagePresenter&lt;T&gt; presenter;</span><br><span class="line">        <span class="keyword">private</span> ImagePresenter.Builder&lt;T&gt; builder;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(T model, ImageView imageView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">            <span class="keyword">this</span>.imageView = imageView;</span><br><span class="line">            <span class="keyword">this</span>.context = imageView.getContext();</span><br><span class="line"></span><br><span class="line">            presenter = (ImagePresenter&lt;T&gt;) imageView.getTag(R.id.image_presenter_id);</span><br><span class="line">            builder = <span class="keyword">new</span> ImagePresenter.Builder&lt;T&gt;()</span><br><span class="line">                    .setImageView(imageView)</span><br><span class="line">                    .setImageLoader(<span class="keyword">new</span> Approximate(getImageManager()));</span><br><span class="line"></span><br><span class="line">            ModelStreamLoader&lt;T&gt; loader = classToModelStream.get(model.getClass());</span><br><span class="line">            <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                builder.setModelStreamLoader(loader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>期间作者改了好多次类名哦，并加了很多注释<br>对于线程安全方面，一些关键方法加了syschronized关键字，或是改用了concurrent包中的集合<br>在加载图片的公开方法上，出现了大致的轮廓，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Glide.load(current)</span><br><span class="line">                    .into(viewHolder.imageView)</span><br><span class="line">                    .with(<span class="keyword">new</span> DirectFlickrStreamLoader(api))</span><br><span class="line">                    .centerCrop()</span><br><span class="line">                    .animate(R.anim.fade_in)</span><br><span class="line">                    .begin();</span><br></pre></td></tr></table></figure><p>使用Vollery in UrlLoader<br>添加一些测试为了方便，图片源添加一个<code>StringLoader</code>，其内部是转换成UrlLoader</p><p>对于UrlLoader，因为最终都是要打开流的，故存在了StreamLoader接口<br>其功能就是打开流，并定义了Callback,用于打开成功或失败的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StreamLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StreamReadyCallback</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStreamReady</span><span class="params">(InputStream is)</span></span>;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span></span>;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadStream</span><span class="params">(StreamReadyCallback cb)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">那么图片流的来源可分为两类，本地的和远程的  </span><br><span class="line">本地的指Android定义流，如Assert读取的文件，提供的协议头 content：file:</span><br><span class="line">远程的包括http和https</span><br><span class="line"></span><br><span class="line">## 允许加载任意的Transformation和加载image通任意的目标</span><br><span class="line"></span><br><span class="line">这个两个功能确实为该框架添加了很多色彩啊  </span><br><span class="line"></span><br><span class="line">设置转场动画，比如加载图片时，需要设置fadeIn加载的动画，看起来确实很舒服,以及暴露了可以加载自定义动画</span><br><span class="line"></span><br><span class="line">新添加了`Target`的概念，这个概念我第一次遇到确实蒙的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Target是定义了可以防止图片的目标，需要处理</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片准备好了时该怎么展示啊</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageReady</span><span class="params">(Bitmap bitmap)</span></span>;</span><br><span class="line">    <span class="comment">//占位图片啊，要注意这里的占位图是包括加载前和加载失败的，在不同状态时，Glide会设置不同的图片</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPlaceholder</span><span class="params">(Drawable placeholder)</span></span>;</span><br><span class="line">    <span class="comment">//获取到该目标能显示多大的图片，如ImageView的wrap_content时，是需要异步的等待结果的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSize</span><span class="params">(SizeReadyCallback cb)</span></span>;</span><br><span class="line">    <span class="comment">//可选性的提供转场动画</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span></span>;</span><br><span class="line">    <span class="comment">//获取和设置Presenter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImagePresenter</span><span class="params">(ImagePresenter imagePresenter)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImagePresenter <span class="title">getImagePresenter</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">总的看，就是一个能放置图片的玩意，应该具备有什么能力(方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">看完这个`Target`，再看`Presenter`吧</span><br><span class="line"></span><br><span class="line">Presenter跟Android中的MVP中P概念是一致的，   </span><br><span class="line">持有View，负责捉取图片，和加载正确大的图片，即使View回收时</span><br><span class="line">类型参数中的T就是Model，定义了图片的来源，这里看看设置Model的方法</span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets a model to load an image from. Each subsequent call will override all previous calls and will prevent any</span></span><br><span class="line"><span class="comment">     * bitmaps that are loaded from previous calls from being displayed even if the load completes successfully. Any</span></span><br><span class="line"><span class="comment">     * image being displayed at the time of this call will be replaced either by the placeholder or by the new image</span></span><br><span class="line"><span class="comment">     * if the load completes synchronously (ie it was in an in memory cache)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *     Note - A load will not begin before the ImagePresenter has determined the width and height of the wrapped</span></span><br><span class="line"><span class="comment">     * view, which can't happen until that view has been made visible and undergone layout out for the first time. Until</span></span><br><span class="line"><span class="comment">     * then the current load is stored. Subsequent calls will replace the stored load</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model The model containing the information required to load a path and/or bitmap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModel</span><span class="params">(<span class="keyword">final</span> T model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!model.equals(currentModel)) &#123;</span><br><span class="line">            loadedFromCache = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> loadCount = ++currentCount;</span><br><span class="line">            currentModel = model;</span><br><span class="line">            isImageSet = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//需要target定好自己的大小后，才会真正加载图片</span></span><br><span class="line">            target.getSize(<span class="keyword">new</span> Target.SizeReadyCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">                    </span><br><span class="line">                    fetchImage(model, width, height, loadCount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            loadedFromCache = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isImageSet) &#123;</span><br><span class="line">                resetPlaceHolder();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fetchImage</span><span class="params">(<span class="keyword">final</span> T model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">final</span> <span class="keyword">int</span> loadCount)</span> </span>&#123;</span><br><span class="line">        imageLoader.clear();</span><br><span class="line">        <span class="keyword">final</span> String id = modelLoader.getId(model);</span><br><span class="line">        <span class="keyword">final</span> StreamLoader sl = modelLoader.getStreamLoader(model, width, height);</span><br><span class="line">        <span class="keyword">final</span> Transformation t = transformationLoader.getTransformation(model);</span><br><span class="line">        <span class="comment">//使用ImageLoader来加载图片</span></span><br><span class="line">        imageToken = imageLoader.fetchImage(id, sl, t, width, height, <span class="keyword">new</span> ImageLoader.ImageReadyCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onImageReady</span><span class="params">(Bitmap image)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (loadCount != currentCount || !canSetImage() || image == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (imageReadyCallback != <span class="keyword">null</span>)</span><br><span class="line">                    imageReadyCallback.onImageReady(target, loadedFromCache);</span><br><span class="line">                target.onImageReady(image);</span><br><span class="line">                isImageSet = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> relevant = loadCount == currentCount;</span><br><span class="line">                <span class="keyword">if</span> (exceptionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    exceptionHandler.onException(e, model, relevant);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若是设置错误的占位图，则会显示啊</span></span><br><span class="line">                <span class="keyword">if</span> (relevant &amp;&amp; canSetPlaceholder()) &#123;</span><br><span class="line">                    target.setPlaceholder(errorDrawable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="暂且看到版本2013-8-31"><a href="#暂且看到版本2013-8-31" class="headerlink" title="暂且看到版本2013-8-31"></a>暂且看到版本2013-8-31</h2><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>好累哦，感觉继续看下去自己脑子要糊了~~</p><p>2013年，有些遥远了啊，想想当时自己还没上大学呢。</p><p>考古的感觉是如何的呢？  </p><p>看着大佬的一步步的从简单的版本一步步到2013-8这个版本，也快一年的工作量，消化不过来了。最初的版本的有个操作，读取文件流仅却不加载到内存的操作，为了获取到图片源的大小，故，可以根据需要展示的图片大小，通过设置采样，不必加载整个文件，就可以加载出我们所需的图片。</p><p>这个操作在android官方文档似乎就有看到呢，且在国内的知名Android博主的文章也提及。而当自己在源码中看到这个真实的代码时，自己确实有些许激动的。</p><p>另个一个感触是，看到开始的这些版本，感觉作者的代码，自己也是大致能完全理解的哈，Glide一步步成为知名框架，是有迹可循的。开始的代码，作者写的也很朴素，之后代码逐渐重构清晰。结合自己看的EventBus源码，感觉大佬的炼成之路真的需要坚持啊。</p><p>另外，教训，感觉之后的源码需要切入某个方面来看，否则好难坚持。</p><p>比如作者添加错误的占位图这个功能时，根据作者写的commit，看的时候，思路就会清晰点。(小提示，以后自己提的commit也要用心点)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##碎碎念&lt;/p&gt;
&lt;p&gt;介绍Glide的文章看了挺多，偶尔也会点击查看部分的Glide的源码，可感觉对Glide的还是不太懂。个人觉得，每个人
的水平不同，对知识点的掌握的面不同，可能他人的已掌握的知识点于自己而言是盲点，，写源码分析的人一般将自己
觉得值得写的东西记录下
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用注解为部分接口添加加密逻辑</title>
    <link href="http://wjploop.github.io/2020/06/13/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E4%B8%BA%E9%83%A8%E5%88%86%E6%8E%A5%E5%8F%A3%E6%B7%BB%E5%8A%A0%E5%8A%A0%E5%AF%86%E9%80%BB%E8%BE%91/"/>
    <id>http://wjploop.github.io/2020/06/13/使用注解为部分接口添加加密逻辑/</id>
    <published>2020-06-13T08:11:27.000Z</published>
    <updated>2020-06-16T09:58:23.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.v2ex.com/t/681294#r_9111029" target="_blank" rel="noopener">使用了 HTTPS 的网络请求， 其中 JSON 数据有必要做额外的加密吗?</a><br>个人疑惑，故在v2ex提了这个问题，大家讨论挺热闹的。</p><p>另外，根据一个网友的评论，收获一篇好文.<a href="https://www.cnblogs.com/yaowen/p/10448603.html" target="_blank" rel="noopener">HTTPS实战之单向验证和双向验证</a></p></blockquote><p>##问题描述及解决</p><p>需要对部分接口中的JSON数据加密，由于仅是部分接口需要处理，故想到用注解来标记需要加密的接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器返回的基础类</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span>&lt;<span class="type">Data</span>&gt;</span>(</span><br><span class="line">    <span class="keyword">val</span> code: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> msg: String?,</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: Data? <span class="comment">// </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>Data</code>是个泛型，不同接口对应着不同类型，在没有加密逻辑时，该JSON数据中<code>data</code>就是相应的JSON对象。</p><p>添加加密逻辑后，<code>data</code>成了加密过后的密文，类型是<code>String</code>, 故想要反序列出我们想要的<code>Data</code>对象，我们需要多一个<strong>额外操作</strong>，先将该密文解密成相应的json，后续使用<code>Gson</code>反序列既可。</p><p>具体步骤<br>1，标记需要加密的接口  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@POST</span>(<span class="string">"public/login"</span>)</span><br><span class="line"><span class="meta">@EncryptStatic</span>  <span class="comment">//使用该注解来标记该接口加密</span></span><br><span class="line"><span class="function">fun <span class="title">test_login</span><span class="params">(@Body requestBody: RequestBody)</span>:Observable&lt;BaseModel&lt;LoginResult&gt;&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个Converter，用于将JSON数据转换成我们想要的对象</span></span></span><br></pre></td></tr></table></figure><p>2，获取接口方法中的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">                                                        Retrofit retrofit) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">    <span class="keyword">int</span> encrypt = <span class="number">0</span>;    <span class="comment">// 用该变量标记加密类型，0，则无加密，1则需机密</span></span><br><span class="line">    <span class="keyword">if</span> (annotations.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            <span class="comment">//查找注解集合中是否存在加密注解</span></span><br><span class="line">            <span class="keyword">if</span> (annotation.annotationType() == EncryptStatic.class) &#123;</span><br><span class="line">                encrypt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation.annotationType() == EncryptDynamic.class) &#123;</span><br><span class="line">                encrypt=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomizeGsonResponseBodyConverter&lt;&gt;(gson, adapter,encrypt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，为对应的注解添加我们的<strong>额外操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//把responsebody转为string</span></span><br><span class="line">    String response = value.string();</span><br><span class="line">    BaseModel baseResponse = gson.fromJson(response, BaseModel.class);</span><br><span class="line">    <span class="keyword">if</span> (encryptType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 将密文解密成对应的Json字符串</span></span><br><span class="line">        String dataStr = EncryptExtKt.aesDecrypt(Objects.requireNonNull(baseResponse.getData().toString()), <span class="string">"&#125;);</span></span><br><span class="line"><span class="string">        // 以下3行实际是拼凑json字符串</span></span><br><span class="line"><span class="string">        T data=gson.fromJson(dataStr, new TypeToken&lt;T&gt;()&#123;&#125;.getType());</span></span><br><span class="line"><span class="string">        baseResponse = new BaseModel(baseResponse.getCode(), baseResponse.getMsg(), data);</span></span><br><span class="line"><span class="string">        response = gson.toJson(baseResponse, BaseModel.class);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    try &#123;</span></span><br><span class="line"><span class="string">        // 将json数据反序列化了哈</span></span><br><span class="line"><span class="string">        return adapter.fromJson(response);</span></span><br><span class="line"><span class="string">    &#125; finally &#123;</span></span><br><span class="line"><span class="string">        value.close();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>##总结</p><p>大概就是这个流程，在json和对象转换之间插入加解密，第一份工作的项目写过这个逻辑，现在不过是加了一个注解。另外，回头看了第一个项目时，发觉自己代码规范居然变糟糕了~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.v2ex.com/t/681294#r_9111029&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用了 HTTPS 的网络请求， 其中 JSON 数据有必要做额外的加密吗?&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://wjploop.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>三个经典排序算法</title>
    <link href="http://wjploop.github.io/2020/06/13/%20%E4%B8%89%E4%B8%AA%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://wjploop.github.io/2020/06/13/ 三个经典排序算法/</id>
    <published>2020-06-12T16:39:04.000Z</published>
    <updated>2021-07-14T11:24:09.619Z</updated>
    
    <content type="html"><![CDATA[<p>面试常聊的几个排序算法，总结整理一下，</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>目前感觉，最有趣也最有挑战的排序<br>思路：  </p><p>将数组视为完全二叉树，其父子关系使用下标确定，<br>root -&gt; left<br>arr[left] = arr[root * 2 +1] (下标从0开始哈)<br>构建大根堆, 所有的二叉树都满足<br>根节点 &gt; ( 左节点 | 右节点 )</p><p>将一个数组构建成一个大根堆，具体操作（堆化操作）<br>假设左右子树都是大根堆，<br>则选择左右节点较大的，与根节点比较：<br>若是小于根节点，符合要求，返回<br>若是大于根节点，则交换根节点和该节点<br>    交换后，该子树需要继续 堆化操作，直至到以下所有子树都符合要求</p><p>堆化操作的<strong>前提</strong>是需要其子树都符合堆的要求，<br>故，将一个源数组堆化，需要从底部的树开始，从下往上，从右往左，依次讲个所有的子树堆化，最后整个二叉树也就堆化了  </p><p>堆化后，假设是大根堆，我们求其正序   </p><p>第一个元素是最大元素，我们选择好该最大元素，与最后一个元素交换，接着，继续堆化nums[0,n-2],num[n]已经排好序了<br>重复以上</p><p>可以看到, 堆排序是选择排序的优化哈</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参考 https://www.cnblogs.com/chengxiao/p/6129630.html</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 堆排序，首先要求时完全二叉树，使用数组的存储结构，叶子节点只会在倒数第二层出现</span></span><br><span class="line"><span class="comment"> * 大根堆，节点值均小于根节点</span></span><br><span class="line"><span class="comment"> * 使用数组存储结构时，根节点与子节点关系可以通过下标换算的，arr[left] = arr[root*2+1] , arr[right] = arr[root*2+2]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">object</span> HeapSort &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">heapSort</span><span class="params">(arr: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//        val arr = intArrayOf(4, 6, 8, 5, 9)</span></span><br><span class="line">        arr.println()</span><br><span class="line">        <span class="keyword">val</span> len = arr.size</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> len / <span class="number">2</span> - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            adjustHeap(arr, i, len)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> len - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            arr.swap(<span class="number">0</span>, k)</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, k)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.println()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以firstRoot开始，使得该节点为最大值</span></span><br><span class="line">    <span class="comment">//注意该调整有个前提，其左右子树已经是个大根堆了</span></span><br><span class="line">    <span class="comment">//故，初始化一个大根堆，则需要最后一个非叶子节点开始，从下往上，从左往右迭代调整</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">adjustHeap</span><span class="params">(arr: <span class="type">IntArray</span>, firstRoot: <span class="type">Int</span>, len: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> root = firstRoot</span><br><span class="line">        <span class="keyword">val</span> max = arr[firstRoot]    <span class="comment">//其实我们就是要找最大的元素</span></span><br><span class="line">        <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            k = root * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (k &lt; len) &#123;</span><br><span class="line">                <span class="comment">//要找到左右节点中较大的哦</span></span><br><span class="line">                <span class="keyword">if</span> (k + <span class="number">1</span> &lt; len &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                    k++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (arr[k] &gt; max) &#123;    <span class="comment">//若是存在叶子节点比root大的情况</span></span><br><span class="line">                    arr[root] = arr[k]</span><br><span class="line">                    root = k    <span class="comment">//root指向该叶子节点，继续循环以该root为节点的树</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (k &lt; len)</span><br><span class="line">        arr[root] = max</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>思路：<br>选择一个中轴，将一个数组分为两部分，使得左边比中轴小，右边比中轴大<br>实际操作中，将第左边界的第一个值设为中轴，迭代访问后面的元素，若是发现比中轴小，则将该元素插入到中轴左侧</p><p>针对左右两部分，递归使用以上操作，递归终止在，对应操作的数组只有一个元素时。  </p><p>时间复杂度，递归深度是log<sub>2</sub>n故，时间复杂度是 nlog<sub>2</sub>n  空间复杂度，递归使用了栈空间，故 log<sub>2</sub>n</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">quickSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        helper(nums, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">helper</span><span class="params">(nums: <span class="type">IntArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> pivot = left</span><br><span class="line">        <span class="keyword">var</span> start = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> end = right</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            println(<span class="string">"pivot:<span class="subst">$&#123;nums[pivot]&#125;</span>,check <span class="subst">$&#123;nums[start]&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">if</span> (nums[start] &lt; nums[pivot]) &#123;</span><br><span class="line">                <span class="comment">//把当前数插入到左端</span></span><br><span class="line">                moveToHead(nums, left, start)</span><br><span class="line">                <span class="comment">//轴也会右移</span></span><br><span class="line">                pivot++</span><br><span class="line">            &#125;</span><br><span class="line">            start++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每一遍结束，pivot都能划分[left,right]</span></span><br><span class="line">        nums.println()</span><br><span class="line"></span><br><span class="line">        helper(nums, left, pivot - <span class="number">1</span>)</span><br><span class="line">        helper(nums, pivot + <span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数组翻转一位</span></span><br><span class="line">    <span class="comment">//这里效率很低啊</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToHead</span><span class="params">(nums: <span class="type">IntArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> temp = nums[right]</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> right downTo left + <span class="number">1</span>) &#123;</span><br><span class="line">            nums[i] = nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>append: 避免移动元素的快排，</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end;</span><br><span class="line">    <span class="comment">// 将中轴取出来，将其保存至变量pivot,随之arr[i]这个坑空出来了</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右往左寻找第一个比中轴小的数，找到其</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        <span class="comment">// 同样，从左边开始，寻找第一个比中轴大的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        System.out.println(<span class="string">"i "</span> + i + <span class="string">", j "</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时i == j</span></span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    quickSort(arr, start, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>思路：  </p><p>1，拆分<br>针对数组，以下标中点将数组划分为左右两部分<br>针对左右两部分，重复以上操作，直至该数组只有一个元素，(递归出口，一个元素是有序的)</p><p>2，合并<br>将拆分的两个部分，两者都是有序数组，合并成一个有序数组<br>重复以上</p><p>关于合并两个有序数组的优化取巧，若是第一个数组中最大的元素比第二数组中最小的元素还小，可直接拼接  </p><p>LeetCode中相关的题目，求数组中的逆序对</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> MergeSort &#123;</span><br><span class="line">    <span class="comment">//另外，可以利用归并排序的稳定性，</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(nums: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> copy = nums.copyOf()</span><br><span class="line">        helper(nums, copy, <span class="number">0</span>, nums.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">helper</span><span class="params">(nums: <span class="type">IntArray</span>, copy: <span class="type">IntArray</span>, left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">        helper(nums, copy, left, mid)</span><br><span class="line">        helper(nums, copy, mid + <span class="number">1</span>, right)</span><br><span class="line">        mergeArr(nums, copy, left, mid, right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序的数组，为了避免每次都要创建一个字数组来保存，</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mergeArr</span><span class="params">(nums: <span class="type">IntArray</span>, copy: <span class="type">IntArray</span>, left: <span class="type">Int</span>, mid: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        nums.println()</span><br><span class="line">        println(<span class="string">"mid:<span class="subst">$&#123;nums[mid]&#125;</span>, left:<span class="subst">$&#123;nums[left]&#125;</span>, right:<span class="subst">$&#123;nums[right]&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依赖上一次合并状态</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> left..right) &#123;</span><br><span class="line">            copy[i] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> i = left</span><br><span class="line">        <span class="keyword">var</span> j = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> k = left</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy[i] &lt;= copy[j]) &#123;</span><br><span class="line">                nums[k++] = copy[i++]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k++] = copy[j++]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            nums[k++] = copy[i++]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            nums[k++] = copy[j++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p><a href="https://github.com/wjploop/LeetCode" target="_blank" rel="noopener">github代码</a></p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试常聊的几个排序算法，总结整理一下，&lt;/p&gt;
&lt;h2 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h2&gt;&lt;p&gt;目前感觉，最有趣也最有挑战的排序&lt;br&gt;思路：  &lt;/p&gt;
&lt;p&gt;将数组视为完
      
    
    </summary>
    
    
      <category term="算法" scheme="http://wjploop.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
